CON ' Header

''    _______ _______ _______ _______                 _______ _______
''   (       |  ____ (  ____ (  ___  )\     /|\     /(       |  ____ \
''   | () () | (    \/ (    \/ (   ) ( \   / ) )   ( | () () | (    \/
''   | || || | (__   | |     | (___) |\ (_) /| |   | | || || | (__
''   | |(_)| |  __)  | | ____|  ___  | \   / | |   | | |(_)| |  __)
''   | |   | | (     | | \_  ) (   ) |  ) (  | |   | | |   | | (
''   | )   ( | (____/\ (___) | )   ( |  | |  | (___) | )   ( | (____/\
''   |/     \(_______(_______)/     \|  \_/  (_______)/     \(_______/
''
''                    -= SEGA MEGA DRIVE EMULATOR =-
''
'' Note: this sucks. not as much.
'' Perhaps more important note: use the included build.sh.

#include "config.spin2"

CON ' Configuration constants (UNUSED WITH CURRENT UPPER CODE)

'' Console region to be reported.
'' Note that a 60Hz system is always emulated,
'' this only affects the version register
USE_REGION = REGION_OVERSEAS_60HZ

REGION_OVERSEAS_60HZ = %10 '' Americas
REGION_DOMESTIC_60HZ = %00 '' Japan
REGION_OVERSEAS_50HZ = %11 '' Europe, Australia
REGION_DOMESTIC_50HZ = %01 '' Narnia, Gensokyo, Oz, Bielefeld

#0,PAD_NONE,PAD_3BUTTON,PAD_6BUTTON

CON ' Common constants

_CLKFREQ = 327_600_000 ' Ignore this unless you're debugging - clock is set by video driver



'DEBUG_BAUD = 115_200*2
'DEBUG_BAUD = 1_000_000

ROM_LOCK  = 7
HINT_LOCK = 8
VINT_LOCK = 9
ZINT_LOCK = 10 ' Z80 VBlank IRQ is sorta independent

STATIC_LOCKS = decod ROM_LOCK | decod HINT_LOCK | decod VINT_LOCK | decod ZINT_LOCK

UPPER_LOAD = $5_0000



DAT ' startup code & zero page
              org
              ' reboot into upper
              coginit #0,##UPPER_LOAD
              'coginit #HUBEXEC,##mk_init
              orgh $14
_clkf         long 0
_clkm         long 0
_mk_init_ptr            long @mk_init ' < $1C
_vdp_outbuffer_ptr      long @outbuffer_loc ' < $20
_vdpr_load_ptr          long @vdpr_entry ' < $24
_vdpc_load_ptr          long @vdpc_entry ' < $28
_zk_init_ptr            long @zk_init ' < $2C
_opn_init_ptr           long @opn_init ' < $30
_cram32_ptr             long @vdp_cram32 ' < $34
_vsram_ptr              long @vdp_cram + $120 ' < $38
_vram_ptr               long @vdp_ram  ' < $3C

              orgh $40
              ' control bit format is %MXYZ_SACB_RLDU
io_pl1_padw   word 0 ' < $40 (populated by upper code)
io_pl2_padw   word 0 ' < $42 (populated by upper code)
io_pl1_dir    byte 0
io_pl1_out    byte 0
io_pl1_state  byte 0
io_pl1_type   byte PAD_6BUTTON ' < $47 (populated by upper code)
io_pl2_dir    byte 0
io_pl2_out    byte 0
io_pl2_state  byte 0
io_pl2_type   byte PAD_6BUTTON ' < $4B (populated by upper code)

io_6btn_timeout long 0 ' Timeout for 6 button state machine


zbus_request  byte $00 ' \/ These two can be read as a word
z80_reset     byte $01 ' Reset is inverted polarity (low = run)
zbus_status   byte $01
psg_register  byte $08 ' selected PSG register + 8
opn_register  word $000 ' selected OPN2 register
opn_timerAflag byte 0
opn_timerBflag byte 0

              orgh $60

' registers loaded into render cog
vdp_registers
vdp_forceSPRreload      long 0
vdp_flags               long 1<<VDPFLAG_H40  ' < $64
vdp_planeAbase          long $C000
vdp_planeBbase          long $E000
vdp_windowbase          long $A000
vdp_spritebase          long $F800
vdp_HScrollbase         long $FC00
vdp_planewidth          long 1+6' basically what to shl the line count with (1+6 -> 64)
vdp_planeheight         long 4' basically what to zerox the thing with (4->32)
vdp_columnScroll        long 0 ' 1 or 0
vdp_HScrollMode         long 3 ' 0 or 2 or 3 (1 is invalid in HW, too)
vdp_windowColumn        long 0
vdp_windowRow           long 0*8 ' pre-chewed to pixels?
vdp_bgcolor             long $00
' I/O related regs. These are arranged as such for a reason
vdp_io_address_w        word 0
vdp_autoinc_b           byte 0
vdp_iomode_b            byte 3 '%W0FH_00CS where W is write flag, C is CRAM flag and S is VSRAM flag. both set -> no access in progress.
                                                ' H is set when awaiting second half of command. F is set if fill is pending
vdp_dmasrc_l            long 0 ' bit 23 is set for fill/copy, bit 22 then selects which
vdp_dmalen_w            word 0
vdp_dma_enable_b        byte 0
vdp_hint_interval_b     byte 0

vdp_linestartct_l       long 0 ' timestamp of current line render start
vdp_cyc2hcnt_w          word 0 ' reciporal of cycles-per-pixel
                        word 0 ' padding

              orgh $E0
' More stuff set by upper code
rom_zerox               byte 22 ' < $E0 - number of valid bits in ROM address - 1 (22 -> 8MB)
machine_version         byte USE_REGION<<6 ' < $E1: version register value
atn_command             byte 0 ' < $E2: 68k COGATN command.
sram_bankreg            byte %10 ' < $E3: $A130F1 reg value. bit0 enables SRAM banking, bit 1 *locks* SRAM (zero unlocks)
sram_write_tstamp       long 0 ' $E4: last write time stamp (|1 so as to never be zero)
sram_map_start          long -1 ' < $E8: SRAM start address
sram_map_end            long -1 ' < $EC: SRAM end address




              orgh $F8
video_line_ctr          long 0
video_frame_ctr         long 0


CON ' Memory constants

#ifdef USE_PSRAM16
PSRAM_PAGESIZE = 0 addbits 9
PSRAM_ASHIFT = 0
#endif

#ifdef USE_PSRAM8
PSRAM_PAGESIZE = 0 addbits 8
PSRAM_ASHIFT = 1
#endif

#ifdef USE_PSRAM4
PSRAM_PAGESIZE = 0 addbits 7
PSRAM_ASHIFT = 2
#endif

#ifdef USE_PSRAM_SLOW
PSRAM_CLKDIV = 3
PSRAM_CYSHL = 0
#else
PSRAM_CLKDIV = 2
PSRAM_CYSHL = 1
#endif



CON ' MotoKore 68000 constants

#0,MK_CARRY_BIT,MK_OVER_BIT,MK_ZERO_BIT,MK_NEG_BIT,MK_EXT_BIT

MK_SUPER_BIT = 13
MK_TRACE_BIT = 15

MK_CARRY_MASK = 1<<MK_CARRY_BIT
MK_OVER_MASK  = 1<<MK_OVER_BIT
MK_ZERO_MASK  = 1<<MK_ZERO_BIT
MK_NEG_MASK   = 1<<MK_NEG_BIT
MK_EXT_MASK   = 1<<MK_EXT_BIT

MK_SUPER_MASK = 1<<MK_SUPER_BIT
MK_TRACE_MASK = 1<<MK_TRACE_BIT


MK_ROMQUE_SIZE = 16 ' words

DMA_BLOCK_SIZE = 32 ' longs


DAT ' MotoKore 68000 cog resident code
              org
mk_cogbase
mk_d0         long 0
mk_d1         long 0
mk_d2         long 0
mk_d3         long 0
mk_d4         long 0
mk_d5         long 0
mk_d6         long 0
mk_d7         long 0
mk_a0         long 0
mk_a1         long 0
mk_a2         long 0
mk_a3         long 0
mk_a4         long 0
mk_a5         long 0
mk_a6         long 0
mk_a7         long 0

mk_othersp    long 0
mk_sr         long 0

mk_nibble_impl_tbl
              long mk_nibble_0 ' 0 (immediate ops)
              long mk_nibble_1 ' 1 (MOVE BYTE)
              long mk_nibble_2 ' 2 (MOVE LONG)
              long mk_nibble_3 ' 3 (MOVE WORD)
              long mk_nibble_4 ' 4 (weird stuff idk)
              long mk_nibble_5 ' 5 (ADDQ/SUBQ and also Scc/DBcc)
              long mk_nibble_6 ' 6 (branches)
              long mk_nibble_7 ' 7 (MOVEQ)
              long mk_nibble_8 ' 8 (OR and stuffs)
              long mk_nibble_9 ' 9 (subtracts)
              long mk_nibble_A ' A (LINE A EMULATOR TRAP)
              long mk_nibble_B ' B (CMP and EOR)
              long mk_nibble_C ' C (AND or stuffs)
              long mk_nibble_D ' D (adds)
              long mk_nibble_E ' E (Bit shifts)
              long mk_nibble_F ' F (LINE F EMULATOR TRAP)



mk_nextop
              'debug("registers: ",ubin_word(mk_sr),13,uhex_reg_array(#mk_d0,#8),13,uhex_reg_array(#mk_a0,#8))
              'debug("last 16 RAM bytes: ",uhex_byte_array(#main_ram + $FFF0,#16))
              'tjnz mk_debug_ctr,#mk_nextop_nohook
              jatn mk_cogatnptr
mk_ihook1     nop
mk_ihook2     nop
mk_nextop_nohook
              'cmp mk_virtualpc,mk_debug_tripwire wz
        'if_z drvh #38
       'if_z  mov mk_debug_tripwire,#0
       'if_z   mov mk_debug_ctr,#1
              'debug("getting op with ",uhex_long(mk_virtualpc))
              'debug(uhex_long_(mk_virtualpc))
              'debug(uhex_word_array(#@fake_rom+$200,#4))
              call mk_getopf
              'debug("got op: ",uhex_word(mk_opword))
              'debug("got op: ",uhex_word(mk_opword)," before ",uhex_long(mk_virtualpc))
              'tjnz mk_debug_tripwire,#.no_trace
              'tjz mk_debug_ctr,#.no_trace
              'sub mk_debug_ctr,#1
              'cmp mk_debug_tripwire,mk_virtualpc wz
        'if_nz jmp #.no_trace
              'debug("tripwired' ",uhex_byte_array(#@zbus_status,#1),uhex_long(mk_virtualpc))
              'call #mk_check_core_integrity
              'debug("got: ",uhex_word_(mk_opword)," before ",uhex_long_(mk_virtualpc),uhex_long(mk_d2,mk_a0,mk_a1))
              'debug("registers: ",ubin_word(mk_sr),13,uhex_reg_array(#mk_d0,#8),13,uhex_reg_array(#mk_a0,#8))

              'debug("got op: ",uhex_word(mk_opword)," before ",uhex_long(mk_virtualpc),uhex_long(mk_a3))
              'waitx ##174_00
.no_trace
              push #mk_nextop
              getnib mk_memtmp0,mk_opword,#3
              altd mk_memtmp0,#mk_nibble_impl_tbl
              jmp 0-0

mk_irq4ptr    long @mk_hub_irq4
mk_irq6ptr    long @mk_hub_irq6
mk_cogatnptr  long @mk_hub_cogatn

mk_write_second_reg_or_ea '' for ops that have two directional modes
              testb mk_opword,#8 wc
        if_c  jmp mk_writef
mk_write_second_reg
              neg pb,#1
              shr pb,mk_shiftit
              setq pb
              and mk_opword,mk_dreg_mask ' assume we don't need it anymore
              alti mk_opword,#%000_100_000
        _ret_ muxq 0-0,mk_memvalue


mk_nibble_0   ' Immediate ops (decode headache!)
              testb mk_opword,#8 wc
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_c_and_z jmp #mk_hub_movep
        if_c  jmp #.register_bitop ' not actually an immediate op...
              getnib mk_optmp2,mk_opword,#2
              cmp mk_optmp2,#%1000 wz
        if_z  jmp #.imm_bitop
              ' ok, we know it's a sized ***I type op
              mov pb,mk_opword
              call #mk_getopimm_auto
              'debug("xxxI type op... imm is ",uhex_long(mk_optmp1))
              mov pb,mk_opword
              and pb,#%111_111
              cmp pb,#%111_100 wz ' <- if Z, is op to SR/CCR
        if_z  mov mk_readf,#mk_rd_sr
        if_z  mov mk_shiftit,#16
        if_z  testb mk_opword,#6 wc
        if_z_and_c  mov mk_writef,#mk_wr_sr
        if_z_and_nc mov mk_writef,#mk_wr_ccr
        if_nz callpb mk_opword,#mk_setup_operand_auto

              call mk_readf
              cmp mk_optmp2,#%1100 wz
        if_z  jmp #mk_cmp_swapped ' CMPI (doesn't write)
              push mk_writef ' setup write return
              cmp mk_optmp2,#%0110 wz
        if_z  jmp #mk_add_common ' ADDI
              cmp mk_optmp2,#%0100 wz
        if_z  jmp #mk_sub_common ' SUBI
              ' ok, only logic ops left
              setr mk_thelogicop,#%0101000_01 ' P2 AND WZ opcode (assume this if no other logic op)
              cmp mk_optmp2,#%0000 wz
        if_z  setr mk_thelogicop,#%0101010_01 ' P2 OR WZ opcode
              cmp mk_optmp2,#%1010 wz
        if_z  setr mk_thelogicop,#%0101011_01 ' P2 XOR WZ opcode
              jmp #mk_multilogic_common

.imm_bitop
              push #.bitop_common
              jmp #mk_getopimm8
.register_bitop
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
              mov mk_optmp1,0-0
.bitop_common
              test mk_opword,#%110_000 wz ' Register op?
              mov pb,mk_opword
        if_z  call #mk_setup_reg32
        if_nz and mk_optmp1,#7
        if_nz call #mk_setup_operand8_move
              call mk_readf
              'debug("doing bitop with ",uhex_byte(mk_optmp1),uhex_long(mk_memvalue))
              testbn mk_memvalue,mk_optmp1 wc
              bitc mk_sr,#MK_ZERO_BIT
              testb mk_opword,#6 wz
              testb mk_opword,#7 wc
        if_00 ret ' BTST
              and mk_optmp1,#31 ' bitfield-sensitive ops ahead
        if_01 bitnot mk_memvalue,mk_optmp1 ' BCHG
        if_1x bitz mk_memvalue,mk_optmp1 ' BCLR/BSET
              'debug("bitop result ",uhex_long(mk_memvalue))
              jmp mk_writef



mk_move_shoot_the_shit ' handle all the common MOVE stuff
               ' Doing MOVEA?
              test mk_opword,#%110_000_000 wz
              testb mk_opword,#6 andz
        if_z  jmp #.movea
              signx mk_memvalue,pa wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
.mangle_ea2   ' format for second operand is stupid
              setnib mk_opword,#0,#3
              mov pa,mk_opword
              and pa,#%111_000_000
              shl pa,#6
              or mk_opword,pa
        _ret_ shr mk_opword,#9
.movea
              shr mk_opword,#9
              and mk_opword,#7
              altr mk_opword,#mk_a0
              signx mk_memvalue,pa
              jmp #mk_nextop ' don't need the rest of the op


mk_nibble_1 ' MOVE (byte)
              callpb mk_opword,#mk_setup_operand8_move
              call mk_readf
              callpa #7,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand8_move
              'debug("in move.b, writing ",uhex_byte(mk_memvalue)," to ",uhex_long(mk_effaddr))
              jmp mk_writef

mk_nibble_3 ' MOVE (word)
              'debug("in move.w")
              callpb mk_opword,#mk_setup_operand16_move
              call mk_readf
              callpa #15,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand16_move
              'debug("in move.w, writing ",uhex_word(mk_memvalue)," to ",uhex_long(mk_effaddr))
              jmp mk_writef

mk_nibble_2 ' MOVE (long)
              callpb mk_opword,#mk_setup_operand32_move
              call mk_readf
              callpa #31,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand32_move
              jmp mk_writef


mk_nibble_5 ' ADDQ/SUBQ/Scc/DBcc
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_nibble_5_not_addsub
              ' get operand
              mov mk_optmp1,mk_opword
              shr mk_optmp1,#9 wc ' C = SUBQ, NC = ADDQ
              and mk_optmp1,#7 wz
        if_z  mov mk_optmp1,#8
              ' Check if An reg
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #.addsubq_areg
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push mk_writef
        if_c  jmp #mk_sub_common
              jmp #mk_add_common

.addsubq_areg
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ sumc 0-0,mk_optmp1


mk_nibble_5_not_addsub
              ' Check if DBCC
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #mk_dbcc
              ' got SCC
              callpb mk_opword,#mk_setup_operand8_move
              call mk_readf ' <- yes, this is stupid but accurate
              getnib pb,mk_opword,#2
              shr pb,#1 wc
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
              muxc mk_memvalue,#255
              jmp mk_writef



mk_cmp
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push #mk_cmp_common
              jmp #mk_get_second_reg

mk_cmpa
              testb mk_opword,#8 wc ' long sized?
        if_nc callpb mk_opword,#mk_setup_operand16_move
        if_c  callpb mk_opword,#mk_setup_operand32_move
              call mk_readf
        if_nc signx mk_memvalue,#15

              shr mk_opword,#9
              and mk_opword,#7
              skipf #%11_111_00 ' Skip swap and shift
              alts mk_opword,#mk_a0
              mov mk_optmp1,0-0
mk_cmp_swapped
              xor mk_memvalue,mk_optmp1
              xor mk_optmp1,mk_memvalue
              xor mk_memvalue,mk_optmp1
mk_cmp_common
              'debug("in mk_cmp_common ",uhex_long(mk_d0),uhex_long(mk_memvalue),uhex_long(mk_optmp1),udec(mk_shiftit))
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' NOTE: the operands are swapped compared to sub_common
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              subs mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              sub mk_optmp1,mk_memvalue wcz
              bitc mk_sr,#MK_CARRY_BIT
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT



mk_nibble_9
mk_nibble_D
              ' ADD/SUB (X/A)
              ' check for ADDA/SUBA
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_addsuba
              ' check for ADDX/SUBX
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_z  jmp #mk_hub_addsubx

              ' Okay, normal ADD/SUB
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              call #mk_get_second_reg
              push #mk_write_second_reg_or_ea
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_nc jmp #mk_sub_withdir
              ' fall through
mk_add_common
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              adds mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual add
              add mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT

        _ret_  shr mk_memvalue,mk_shiftit

mk_sub_withdir
              ' if dir bit clear, swap operands
              testb mk_opword,#8 wc
        if_nc xor mk_memvalue,mk_optmp1
        if_nc xor mk_optmp1,mk_memvalue
        if_nc xor mk_memvalue,mk_optmp1
mk_sub_common
              'debug("in mk_sub_common ",uhex_long(mk_d0),uhex_long(mk_memvalue),uhex_long(mk_optmp1),udec(mk_shiftit))
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit

              ' generate stupid overflow flag
              mov mk_optmp0,mk_memvalue
              subs mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              sub mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT

        _ret_  shr mk_memvalue,mk_shiftit

mk_addsuba
              setq mk_dreg_mask
              muxq .adda_op,mk_opword
              testb mk_opword,#8 wc ' long sized?
        if_nc callpb mk_opword,#mk_setup_operand16_move
        if_c  callpb mk_opword,#mk_setup_operand32_move
              call mk_readf
              'debug("in mk_adda: ",uhex_long(mk_memvalue))
        if_nc signx mk_memvalue,#15
              testb mk_opword,#14 wc ' C = ADDA,NC = SUBA ?
.adda_op _ret_ sumnc mk_a0,mk_memvalue





' Memory R/W primitives
mk_setup_operand_auto ' with ea-supplying op in pb
                 ' make sure size field is not %11 (will be treated as 16bit)
              testb pb,#6 wc
        if_c  jmp #mk_setup_operand16
              testb pb,#7 wc
        if_c  jmp #mk_setup_operand32
              ' Fall through!
mk_setup_operand8
              'debug("in mk_setup_operand8 ",ubin(pb))
              mov mk_shiftit,#24
mk_setup_operand8_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg8
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm8
              call #mk_compute_ea
mk_setup_ea8
              'debug("in mk_setup_ea8 ",uhex_long(mk_effaddr))
              mov pb,mk_effaddr
              zerox pb,#23
              cmp pb,mk_ram_begin wc
        if_ae jmp #mk_setup_ram8
              cmp pb,mk_rom_stop wc
        if_ae jmp #mk_setup_io8
              ' fall through
mk_setup_rom8
              mov  mk_readf,#mk_rd8_rom
              mov  mk_writef,#mk_wrrom
              mov  mk_eacache,mk_romio_area_ptr
              ret wcz


mk_setup_operand16
              'debug("in mk_setup_operand16 ",ubin(pb))
              mov mk_shiftit,#16
mk_setup_operand16_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg16
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm16
              or  pb,#%01_000_000
              call #mk_compute_ea
mk_setup_ea16
              testb mk_effaddr,#0 wc
        if_c  jmp #mk_address_error
              mov pb,mk_effaddr
              zerox pb,#23
              cmp pb,mk_ram_begin wc
        if_ae jmp #mk_setup_ram16
              cmp pb,mk_rom_stop wc
        if_ae jmp #mk_setup_io16
              ' fall through
mk_setup_rom16
              mov  mk_readf,#mk_rd16_rom
              mov  mk_writef,#mk_wrrom
              mov  mk_eacache,mk_romio_area_ptr
              ret wcz


mk_setup_operand32
              mov mk_shiftit,#0
mk_setup_operand32_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg32
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm32
              or  pb,#%10_000_000
              call #mk_compute_ea
mk_setup_ea32
              testb mk_effaddr,#0 wc
        if_c  jmp #mk_address_error
              mov pb,mk_effaddr
              zerox pb,#23
              cmp pb,mk_ram_begin wc
        if_ae jmp #mk_setup_ram32
              cmp pb,mk_rom_stop wc
        if_ae jmp #mk_setup_io32
              ' fall through
mk_setup_rom32
              mov  mk_readf,#mk_rd32_rom
              mov  mk_writef,#mk_wrrom
              mov  mk_eacache,mk_romio_area_ptr
              ret wcz

mk_setup_reg32
              and pb,#%1_111
              sets mk_rd32_reg,pb
              setd mk_wr32_reg,pb
              mov  mk_readf,#mk_rd32_reg
              mov  mk_writef,#mk_wr32_reg
              ret wcz

mk_ea_impl_tbl
              long mk_ea_direct
              long mk_ea_postinc
              long mk_ea_predec
              long mk_ea_displace
              long mk_ea_index
              long mk_ea_headache


mk_rd8_reg
        _ret_ getbyte mk_memvalue,0-0,#0
mk_wr8_reg
        _ret_ setbyte 0-0,mk_memvalue,#0
mk_rd16_reg
        _ret_ getword mk_memvalue,0-0,#0
mk_wr16_reg
        _ret_ setword 0-0,mk_memvalue,#0
mk_rd32_reg
        _ret_ mov mk_memvalue,0-0
mk_wr32_reg
        _ret_ mov 0-0,mk_memvalue

mk_rd8_rom    call   #mk_readrom_ea
mk_rd8_ram
        _ret_ rdbyte mk_memvalue,mk_eacache
mk_wr8_ram
              'call #mk_debug_wrchk8
        _ret_ wrbyte mk_memvalue,mk_eacache

mk_rd16_rom   call   #mk_readrom_ea
mk_rd16_ram
              rdword mk_memvalue,mk_eacache
        _ret_ movbyts mk_memvalue,#%%3201
mk_wr16_ram
              'call #mk_debug_wrchk16
              movbyts mk_memvalue,#%%3201
        _ret_ wrword mk_memvalue,mk_eacache

mk_rd32_rom   call   #mk_readrom_ea32
mk_rd32_ram
              rdlong mk_memvalue,mk_eacache
        _ret_ movbyts mk_memvalue,#%%0123
mk_wr32_ram
              'call #mk_debug_wrchk32
              movbyts mk_memvalue,#%%0123
        _ret_ wrlong mk_memvalue,mk_eacache

mk_wrrom      ret ' obviously nothing

mk_rdimm
        _ret_ mov mk_memvalue,mk_eacache


mk_longio_tmp long 0

mk_rd32_io
              call #mk_rd16_io
              getword mk_longio_tmp,mk_memvalue,#0
              add mk_eacache,#2
              call #mk_rd16_io
        _ret_ setword mk_memvalue,mk_longio_tmp,#1
mk_wr32_io
              mov mk_longio_tmp,mk_memvalue
              shr mk_memvalue,#16
              call #mk_wr16_io
              add mk_eacache,#2
              getword mk_memvalue,mk_longio_tmp,#0
              ' fall through
mk_wr16_io
              'debug("mk_wr16_io ",uhex(mk_effaddr),uhex_long($7f))
              cmp mk_eacache,mk_vdp_begin wc
        if_ae jmp #vdpio_write16
              cmp mk_eacache,mk_iog_begin wc
        if_ae jmp #iog_write16
              cmp mk_eacache,mk_sram_begin wc
        if_ae cmpr mk_eacache,mk_sram_stop wc
        if_ae jmp #sram_write16
              debug("undecoded IO WORD WRITE: ",uhex_(mk_effaddr),uhex_long(mk_virtualpc))
              ret wcz ' undecoded IO?
mk_rd16_io
              cmp mk_eacache,mk_vdp_begin wc
        if_ae jmp #vdpio_read16
              cmp mk_eacache,mk_iog_begin wc
        if_ae jmp #iog_read16
              cmp mk_eacache,mk_sram_begin wc
        if_ae cmpr mk_eacache,mk_sram_stop wc
        if_ae jmp #sram_read16
              debug("undecoded IO WORD READ: ",uhex(mk_effaddr))
              ret wcz ' undecoded IO?
mk_rd8_io
              cmp mk_eacache,mk_vdp_begin wc
        if_ae jmp #vdpio_read8
              cmp mk_eacache,mk_iog_begin wc
        if_ae jmp #iog_read8
              cmp mk_eacache,mk_sram_begin wc
        if_ae cmpr mk_eacache,mk_sram_stop wc
        if_ae jmp #sram_read8
              mov mk_memvalue,#0 ' TODO
              ret wcz
mk_wr8_io
              'debug("mk_wr8_io ",uhex(mk_effaddr))
              cmp mk_eacache,mk_vdp_begin wc
        if_ae jmp #vdpio_write8
              cmp mk_eacache,mk_iog_begin wc
        if_ae jmp #iog_write8
              cmp mk_eacache,mk_sram_begin wc
        if_ae cmpr mk_eacache,mk_sram_stop wc
        if_ae jmp #sram_write8
              mov mk_memvalue,#0 ' TODO
              ret wcz

mk_wr_sr
              xor mk_memvalue,mk_sr
              testn mk_memvalue,#255 wz
              xor mk_memvalue,mk_sr
              testb mk_sr,#MK_SUPER_BIT wc
  if_nz_or_nc jmp #mk_hub_wr_sr

mk_wr_ccr
              setq #%11111
              muxq mk_sr,mk_memvalue
              ret wcz
mk_rd_sr
        _ret_ mov mk_memvalue,mk_sr


mk_multilogic
              call #mk_get_second_reg
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push #mk_write_second_reg_or_ea
mk_multilogic_common
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit

mk_thelogicop and mk_memvalue,mk_optmp1 wz

              bitz mk_sr,#MK_ZERO_BIT
              testb mk_memvalue,#31 wz
              bitz mk_sr,#MK_NEG_BIT
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK
        _ret_ shr mk_memvalue,mk_shiftit


mk_illegal
              debug("ILLEGAL INSTRUCTION ",uhex_word(mk_opword))
              'drvh #38
              mov pb,#$10
              jmp #mk_hub_trapit


mk_getop_ram
              mov mk_memtmp0,mk_virtualpc
              add mk_virtualpc,#2
              setword mk_memtmp0,#1,#1 ' main_ram!
              rdword mk_opword,mk_memtmp0
        _ret_ movbyts mk_opword,#%%3201

mk_romque_refill
              mov mk_romio_target,mk_romque_area_ptr
              mov mk_romio_length,#MK_ROMQUE_SIZE/2
              mov mk_romque_left,#MK_ROMQUE_SIZE
              mov ptra,mk_romque_area_ptr
              mov pa,mk_virtualpc
              ' Handle not long-aligned access (must logically be word aligned though!)
              rczr pa wcz
              zerox pa,#20 ' Limit to 8 MB range
        if_c  sub  mk_romio_target,#2
        if_c  add  mk_romio_length,#1
              call #mk_readrom
mk_getop_rom
              'debug("in getop_rom with ",udec(mk_romque_left))
              djf mk_romque_left,#mk_romque_refill
              add mk_virtualpc,#2
              rdword mk_opword,ptra++
              movbyts mk_opword,#%%3201
              ret wcz
mk_romque_left    long 0


mk_condition_truth_table
              '' Remember, status register is %XNZVC
              long $10001 * %1111_1111_1111_1111 '' %0000 : True
              'long $10001 * %0000_0000_0000_0000 '' %0001 : False
              long $10001 * %0000_0101_0000_0101 '' %0010 : High
              'long $10001 * %1111_1010_1111_1010 '' %0011 : Low or same
              long $10001 * %0101_0101_0101_0101 '' %0100 : carry clear
              'long $10001 * %1010_1010_1010_1010 '' %0101 : carry set
              long $10001 * %0000_1111_0000_1111 '' %0110 : not equal
              'long $10001 * %1111_0000_1111_0000 '' %0111 : equal
              long $10001 * %0011_0011_0011_0011 '' %1000 : overflow clear
              'long $10001 * %1100_1100_1100_1100 '' %1001 : overflow set
              long $10001 * %0000_0000_1111_1111 '' %1010 : plus
              'long $10001 * %1111_1111_0000_0000 '' %1011 : minus
              long $10001 * %1100_1100_0011_0011 '' %1100 : greater or equal (N==V)
              'long $10001 * %0011_0011_1100_1100 '' %1101 : less than (N!=V)
              long $10001 * %0000_1100_0000_0011 '' %1110 : greater than (N==V)&!Z (???)
              'long $10001 * %1111_0011_1111_1100 '' %1111 : less or equal (N!=V)|Z (???)



mk_shift_impl_tbl
              long mk_do_asr
              long mk_do_asl
              long mk_do_lsr
              long mk_do_lsl
              long mk_do_roxr
              long mk_do_roxl
              long mk_do_ror
              long mk_do_rol

mk_flowop_impl_tbl
              long mk_hub_reset
              long mk_hub_nop
              long mk_hub_stop
              long mk_hub_rte
              long mk_illegal
              long mk_hub_rts
              long mk_hub_trapv
              long mk_hub_rtr


mk_iog_begin  long $00_A00000
mk_vdp_begin  long $00_C00000
mk_ram_begin  long $00_E00000
mk_romio_area_ptr long @mk_romio_area
mk_romque_area_ptr long @mk_romque_area
mk_dreg_mask      long %111_000_000_000


mk_bit31      long  negx
#ifdef USE_PSRAM16
mk_psram_pinfield long PSRAM_BASE addpins 15
mk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + 8
mk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD
#endif
#ifdef USE_PSRAM8
mk_psram_pinfield long PSRAM_BASE addpins 7
mk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + 8
mk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE
#endif
#ifdef USE_PSRAM4
mk_psram_pinfield long PSRAM_BASE addpins 3
mk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_4DAC1 + 8
mk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_4P_4DAC1_WFBYTE
#endif
#ifdef USE_HYPER
mk_hyper_addr_cmd1 long (HYPER_BASE<<17)|X_PINS_ON | X_IMM_4X8_1DAC8 + 4
mk_hyper_addr_cmd2 long (HYPER_BASE<<17)|X_PINS_ON | X_IMM_4X8_1DAC8 + 2
mk_hyper_read_cmd  long (HYPER_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE
#endif

mk_nco_fast   long $8000_0000
#ifdef USE_PSRAM_EITHER
#ifdef USE_PSRAM_SLOW
mk_nco_slow   long $2AAA_AAAB
#else
mk_nco_slow   long $4000_0000
#endif
#else
mk_nco_slow   long $4000_0000
#endif

mk_cogvar_start

mk_debug_tripwire long $00173E
mk_debug_ctr  long 0

mk_rom_stop   res 1
mk_sram_begin res 1
mk_sram_stop  res 1

mk_virtualpc  res 1 ' PC in virtual space
mk_effaddr    res 1 ' calculated effective address
mk_shiftit    res 1 ' operand MSB shift
mk_branchdisplace res 1 ' branch target
mk_opword     res 1 ' opcode

mk_readf      res 1 ' operand read pointer
mk_writef     res 1 ' operand write pointer
mk_getopf     res 1 ' opword get pointer

mk_optmp0     res 1
mk_optmp1     res 1
mk_optmp2     res 1

mk_eatmp0     res 1
mk_eatmp1     res 1


mk_romio_length res 1
mk_romio_target res 1
mk_romio_tmp1   res 1
mk_romio_tmp2   res 1
mk_romio_zerox  res 1

              fit $1F0
              org $1F0

mk_memtmp0    res 1
mk_memtmp1    res 1
mk_memtmp2    res 1
mk_memtmp3    res 1
mk_memvalue   res 1 ' memory read/write value
mk_eacache    res 1 ' remapped EA
              fit $1F6
DAT ' MotoKore 68000 LUT resident code
mk_lutbase
              org 512
#ifdef USE_PSRAM16
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF
#elseifdef USE_PSRAM8
              long $00
              long $11
              long $22
              long $33
              long $44
              long $55
              long $66
              long $77
              long $88
              long $99
              long $AA
              long $BB
              long $CC
              long $DD
              long $EE
              long $FF
#else
              long 0[16]
#endif

mk_readrom_ea32
              mov mk_romio_length,#2
              skipf #%10
mk_readrom_ea
              mov pa,mk_effaddr
              mov mk_romio_length,#1
              rczr pa wcz
              mov mk_romio_target,mk_romio_area_ptr
        if_c  sub mk_romio_target,#2
        if_z  sub mk_romio_target,#1



        { '' HUB RAM as ROM
mk_readrom
              zerox pa,mk_romio_zerox ' Limit to ROM size
              shl pa,#2
              zerox pa,#16 ' <- ROM SIZE HERE (16 = 128k)
              add pa,##fake_rom
              mov mk_memtmp0,mk_romio_target
              'debug("ROM read from ",uhex_long(pa)," to ",uhex_long(mk_romio_target))
              rep @.readrom,mk_romio_length
              rdlong mk_romio_tmp1,pa
              add pa,#4
              wrlong mk_romio_tmp1,mk_memtmp0
              add mk_memtmp0,#4
.readrom
              ret wcz
        '}
#ifdef USE_PSRAM_EITHER
mk_readrom
              zerox pa,mk_romio_zerox ' Limit to ROM size
              locktry #ROM_LOCK wc
        if_nc jmp #$-1
              wrfast  mk_bit31,mk_romio_target
              mov mk_romio_tmp2,pa
              add mk_romio_tmp2,mk_romio_length
              mov mk_romio_tmp1,pa
              bith mk_romio_tmp1,#PSRAM_PAGESIZE
              add mk_romio_tmp1,#1 ' mk_romio_tmp1 has start of next page
              cmpsub mk_romio_tmp2,mk_romio_tmp1 wcz ' IF C, mk_romio_tmp2 now has longs that cross over boundary
        if_c  sub mk_romio_length,mk_romio_tmp2
              call #mk_psram_readburst
   if_nc_or_z lockrel #ROM_LOCK
   if_nc_or_z ret wcz
              mov pa,mk_romio_tmp1
              mov mk_romio_length,mk_romio_tmp2
              call #mk_psram_readburst
              lockrel #ROM_LOCK
              ret wcz

mk_psram_readburst
              mov mk_memtmp0,#(8+PSRAM_WAIT)<<PSRAM_CYSHL
              shl mk_romio_length,#PSRAM_ASHIFT+1+PSRAM_CYSHL
              add mk_memtmp0,mk_romio_length
#ifndef USE_PSRAM16
              shl pa,#PSRAM_ASHIFT ' convert long address to native address (becomes no-op with USE_PSRAM16)
#endif
              setbyte pa,#$EB,#3
              ' Reverse nibble order
              splitb  pa
              rev     pa
              movbyts pa, #%%0123
              mergeb  pa
#ifdef USE_PSRAM_SLOW
              drvl  #PSRAM_CLK ' must be 2 ops before xinit
#endif
              drvh  #PSRAM_SELECT
              drvl  mk_psram_pinfield
              xinit mk_psram_addr_cmd,pa
              wypin mk_memtmp0,#PSRAM_CLK
              setq mk_nco_fast
              xcont #PSRAM_WAIT*PSRAM_CLKDIV+PSRAM_DELAY,#0
#ifndef USE_PSRAM_SLOW
              shr mk_romio_length,#PSRAM_CYSHL ' Becomes no-op with USE_PSRAM_SLOW
#endif
              setword mk_psram_read_cmd,mk_romio_length,#0
              waitxmt
              fltl mk_psram_pinfield
              setq mk_nco_slow
              xcont mk_psram_read_cmd,#0
              waitxfi
#ifdef USE_PSRAM_SLOW
              drvl #PSRAM_SELECT
        _ret_ fltl #PSRAM_CLK
#else
        _ret_ drvl #PSRAM_SELECT
#endif
#endif
#ifdef USE_HYPER
mk_readrom
              zerox pa,mk_romio_zerox ' Limit to ROM size
              locktry #ROM_LOCK wc
        if_nc jmp #$-1
              ' No need for page wrapping considerations, go straight into burst read
              mov mk_memtmp0,#(6+HYPER_WAIT)
              shl mk_romio_length,#2
              add mk_memtmp0,mk_romio_length
              ' Prepare command
              rczr pa wcz
              rczl mk_romio_tmp1
              and mk_romio_tmp1,#%11
              shl mk_romio_tmp1,#9
              setbyte pa,#%101_00000,#3 ' read linear burst
              movbyts pa, #%%0123
              drvh #HYPER_SELECT
              drvl #HYPER_BASE addpins 7
              drvl #HYPER_CLK ' Init clock pin with correct (?) alignment
              xinit mk_hyper_addr_cmd1,pa
              wypin mk_memtmp0,#HYPER_CLK ' setup clock periods
              xcont mk_hyper_addr_cmd2,mk_romio_tmp1
              setq mk_nco_fast
              xcont #HYPER_WAIT*2+HYPER_DELAY,#0
              wrfast mk_bit31,mk_romio_target
              setword mk_hyper_read_cmd,mk_romio_length,#0
              waitxmt
              fltl #HYPER_BASE addpins 7
              setq mk_nco_slow
              xcont mk_hyper_read_cmd,#0
              waitxfi
              drvl #HYPER_SELECT
              fltl #HYPER_CLK ' put clock into reset
              lockrel #ROM_LOCK
              ret wcz
#endif



              '' DEBUG NONSENSE: DELETE WHEN DONE
              {
mk_debug_wrchk8
              cmp mk_eacache,##@main_ram+$1510 wz
        if_ne cmp mk_eacache,##@main_ram+$1511 wz
        if_ne cmp mk_eacache,##@main_ram+$1512 wz
        if_ne cmp mk_eacache,##@main_ram+$1513 wz
        if_ne ret wcz
              debug("wrchk8: ",uhex_byte_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc))
              ret wcz
              '' DEBUG NONSENSE: DELETE WHEN DONE
mk_debug_wrchk16
              cmp mk_eacache,##@main_ram+$1510 wz
        if_ne cmp mk_eacache,##@main_ram+$1512 wz
        if_ne ret wcz
              debug("wrchk16: ",uhex_word_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc))
              ret wcz
              '' DEBUG NONSENSE: DELETE WHEN DONE
mk_debug_wrchk32
              cmp mk_eacache,##@main_ram+$150C wz
        if_ne cmp mk_eacache,##@main_ram+$1510 wz
        'if_ne cmp mk_eacache,##@main_ram+$C642 wz
        'if_ne cmp mk_memvalue,##$9BEA_3228    wz
        if_ne ret wcz
              debug("wrchk32: ",uhex_long_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc),uhex_long(mk_d0),uhex_long(mk_a0))
              ret wcz
'}
              {
mk_debug_wrchk8
              getword mk_memtmp0,mk_a7,#0
              getword mk_memtmp1,mk_eacache,#0
              sub mk_memtmp1,mk_memtmp0
              cmp mk_memtmp1,#16 wc
        if_ae ret wcz
              debug("wrchk8: ",uhex_byte_(mk_memvalue),uhex_word_(mk_a7,mk_eacache),uhex_long_(mk_virtualpc),uhex_long_(mk_a0))
              ret wcz
              '}

mk_setup_ram8
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd8_ram
              mov  mk_writef,#mk_wr8_ram
              ret wcz
mk_setup_reg8
              ' Address register 8 bit ops are illegal, so don't care
              and pb,#%1_111
              sets mk_rd8_reg,pb
              setd mk_wr8_reg,pb
              mov  mk_readf,#mk_rd8_reg
              mov  mk_writef,#mk_wr8_reg
              ret wcz
mk_setup_io8
              mov  mk_eacache,pb
              mov  mk_readf,#mk_rd8_io
              mov  mk_writef,#mk_wr8_io
              'debug("in mk_setup_io8 ",uhex_long(mk_effaddr))
              'jmp pb wcz
              ret wcz

mk_setup_imm8
              call #mk_setup_imm16
              and mk_eacache,#255
              ret wcz

mk_setup_ram16
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd16_ram
              mov  mk_writef,#mk_wr16_ram
              ret wcz
mk_setup_reg16
              'debug("in mk_setup_reg16 ",ubin(pb))
        'if_nz jmp #mk_setup_areg ' Address register is always 32 bit
              and pb,#%1_111
              sets mk_rd16_reg,pb
              setd mk_wr16_reg,pb
              mov  mk_readf,#mk_rd16_reg
              mov mk_writef,#mk_wr16_reg
              ret wcz
mk_setup_io16
              mov  mk_eacache,pb
              mov  mk_readf,#mk_rd16_io
              mov  mk_writef,#mk_wr16_io
              ret wcz
mk_setup_imm16
              mov mk_eatmp0,mk_opword
              call mk_getopf
              mov mk_eacache,mk_opword
              mov mk_opword,mk_eatmp0
              mov  mk_readf,#mk_rdimm
              mov  mk_writef,#mk_illegal
              ret wcz

mk_setup_ram32
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd32_ram
              mov  mk_writef,#mk_wr32_ram
              ret wcz


mk_setup_io32
              mov  mk_eacache,pb
              mov  mk_readf,#mk_rd32_io
              mov  mk_writef,#mk_wr32_io
              ret wcz
mk_setup_imm32
              call #mk_setup_imm16
              mov mk_eatmp0,mk_opword
              call mk_getopf
              rolword mk_eacache,mk_opword,#0
              mov mk_opword,mk_eatmp0
              ret wcz



mk_compute_ea ' CAN AND WILL OVERWRITE FLAGS
              'debug("In mk_compute_ea ",ubin(pb))
              mov mk_eatmp1,pb
              shr mk_eatmp1,#3 wcz '< just to drive the point home
              and mk_eatmp1,#7
              altd mk_eatmp1,#mk_ea_impl_tbl - 2 ' non-memory modes shouldn't appear here
              jmp 0-0

mk_ea_direct
              and pb,#7
              alts pb,#mk_a0
        _ret_ mov mk_effaddr,0-0

mk_nibble_E   ' shifts
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK ' These are cleared by default
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #.memshift
              mov pb,mk_opword
              andn pb,#%00_111_000
              call #mk_setup_operand_auto
              xor mk_shiftit,#31 ' <- change into MSB's index
              ' get shift amount
              call #mk_get_second_reg
              testb mk_opword,#5 wc
        if_nc mov mk_optmp1,pb wz
  if_nc_and_z mov mk_optmp1,#8
              and mk_optmp1,#63 wz
              ' move shift mode bits into place
              testb mk_opword,#8 wz
              shr  mk_opword,#2
              bitz mk_opword,#0
.do_shift
              call mk_readf
              'debug("regshift amount is ",udec(mk_optmp1),"also, ",udec(mk_shiftit)," shift val is ",uhex_long(mk_memvalue))
              and mk_opword,#7
              altd mk_opword,#mk_shift_impl_tbl
              call 0-0
.done
              zerox mk_memvalue,mk_shiftit wz
              testb mk_memvalue,mk_shiftit wc
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              'debug("shift result ",uhex_long(mk_memvalue))
              jmp mk_writef

.memshift
              mov pb,mk_opword
              call #mk_setup_operand16_move
              mov mk_shiftit,#15
              mov mk_optmp1,#1
              shr mk_opword,#8 ' get shift mode bits into place
              jmp #.do_shift

mk_zeroroxx
              testb mk_sr,#MK_EXT_BIT wc
        _ret_ bitc mk_sr,#MK_CARRY_BIT
mk_zeroshift
        _ret_ bitl mk_sr,#MK_CARRY_BIT

mk_do_asr
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wz
              shr mk_memvalue,#1 wc
              bitz mk_memvalue,mk_shiftit
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_asl
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              shl mk_memvalue,#1
              testb mk_memvalue,mk_shiftit wz
        if_z_ne_c bith mk_sr,#MK_OVER_BIT
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_lsr
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              shr mk_memvalue,#1 wc
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_lsl
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              shl mk_memvalue,#1
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_ror
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              shr mk_memvalue,#1 wc
              bitc mk_memvalue,mk_shiftit
.loop
        _ret_ muxc mk_sr,#MK_CARRY_MASK

mk_do_rol
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              rcl mk_memvalue,#1
.loop
        _ret_ muxc mk_sr,#MK_CARRY_MASK

mk_do_roxr
              tjz mk_optmp1,#mk_zeroroxx
              rep @.loop,mk_optmp1
              testb mk_sr,#MK_EXT_BIT wz
              shr mk_memvalue,#1 wc
              bitz mk_memvalue,mk_shiftit
              muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
.loop
              ret
mk_do_roxl
              tjz mk_optmp1,#mk_zeroroxx
              rep @.loop,mk_optmp1
              testb mk_sr,#MK_EXT_BIT wc
              testb mk_memvalue,mk_shiftit wz
              rcl mk_memvalue,#1
              muxz mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
.loop
              ret



mk_nibble_4   ' AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
              mov pb,mk_opword ' set this up
              testb mk_opword,#8 wc
        if_c  jmp #.lea_chk  ' got LEA or CHK
              testb mk_opword,#11 wc
        if_nc jmp #.negop_or_srmove ' got NEGX/CLR/NEG/NOT or SR move
              testb mk_opword,#9 wc
        if_c  jmp #.complex ' got one of.. those..
              testb mk_opword,#7 wc
        if_c  jmp #.movem_ext   ' got EXT
              testb mk_opword,#6 wc
        if_nc jmp #mk_hub_nbcd  ' got NBCD
              ' must be SWAP/PEA
              test mk_opword,#%110_000 wz
        if_z  jmp #.swap
              ' ok, PEA
              call #mk_compute_ea ' mk_opword already in PB
              mov mk_memvalue,mk_effaddr
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              jmp mk_writef

.complex
              testb mk_opword,#10 wc
        if_nc jmp #mk_hub_tst_tas
              testb mk_opword,#7 wc
        if_c  jmp #.jmp_jsr
              testb mk_opword,#5 wc
        if_nc jmp #mk_hub_link_trap
              testb mk_opword,#4 wc
        if_nc jmp #mk_hub_moveusp
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              altd mk_optmp0,#mk_flowop_impl_tbl
              jmp 0-0


.swap
              and mk_opword,#15
              altd mk_opword,#mk_d0
              movbyts 0-0,#%%1032
              altd mk_opword,#mk_d0
              shl 0-0,#0 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
        _ret_ andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK


.lea_chk
              testb mk_opword,#6 wc
        if_nc jmp #mk_hub_chk ' got CHK
              ' do LEA
              call #mk_compute_ea ' mk_opword already in PB
              setnib mk_opword,#1,#3
              alti mk_opword,#%000_100_000
        _ret_ mov 0-0,mk_effaddr

.movem_ext
              ' An mode here is technically illegal. We just treat it as extend.
              test mk_opword,#%110_000 wz
        if_nz jmp #mk_hub_movem
              testb mk_opword,#6 wc
        if_nc call #mk_setup_operand16_move
        if_c  call #mk_setup_operand32_move
              call mk_readf
        if_nc signx mk_memvalue,#7 wcz
        if_c  signx mk_memvalue,#15 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              jmp mk_writef

.negop_or_srmove
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_srmove ' is move from/to SR/CCR
              call #mk_setup_operand_auto ' mk_opword already in PB
              call mk_readf
              shl mk_memvalue,mk_shiftit
              testb mk_opword,#9 wz
        if_z  jmp #.clr_not ' got CLR or NOT
              ' ok, must be NEG/NEGX
              testb mk_opword,#10 wc
        if_nc jmp #mk_hub_negx
              ' got NEG
              neg mk_memvalue wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              muxnz mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
              cmp mk_memvalue,mk_bit31 wz
              bitz mk_sr,#MK_OVER_BIT
              sar mk_memvalue,mk_shiftit
              jmp mk_writef

.clr_not
              testbn mk_opword,#10 wz ' Z set if CLR
        if_z  mov mk_memvalue,#0 wc
        if_nz not mk_memvalue wc
              bitc mk_sr,#MK_NEG_BIT
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK
              shr mk_memvalue,mk_shiftit wz
              bitz mk_sr,#MK_ZERO_BIT
              jmp mk_writef


.jmp_jsr
              call #mk_compute_ea
              mov mk_branchdisplace,mk_effaddr
              sub mk_branchdisplace,mk_virtualpc
              testb mk_opword,#6 wc ' if NC, got JSR
        if_c  jmp #mk_dobranch
              ' fall through
mk_call
              ' Push return address on stack
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              'debug("SP after call: ",uhex_long(mk_a7),uhex_long(mk_virtualpc),shex_long(mk_branchdisplace))
              jmp #mk_dobranch




mk_nibble_C   ' MULx/AND/EXG/ABCD
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_mul ' MULU/MULS
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_nz setr mk_thelogicop,#%0101000_01 ' P2 AND WZ opcode
        if_nz jmp #mk_multilogic ' AND
              test mk_opword,#%11_000_000 wz
        if_z  jmp #mk_hub_abcd
              jmp #mk_hub_exg

mk_nibble_8   ' DIVx/OR/SBCD
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_div ' DIVU/DIVS
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_nz setr mk_thelogicop,#%0101010_01 ' P2 OR WZ opcode
        if_nz jmp #mk_multilogic ' OR
              'test mk_opword,#%11_000_000 wz
              jmp #mk_hub_sbcd

mk_nibble_B   ' CMP (M/A)
              ' check for CMPA
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_cmpa
              ' check for CMP
              testb mk_opword,#8 wc
        if_nc jmp #mk_cmp
              ' check for CMPM
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #mk_hub_cmpm
              ' Ok, is EOR
              setr mk_thelogicop,#%0101011_01 ' P2 XOR WZ opcode
              jmp #mk_multilogic ' XOR


mk_dbcc       ' DBcc
              ' compute destination first...
              call #mk_getopimm16
              signx mk_optmp1,#15
              sub mk_optmp1,#2
              mov mk_branchdisplace,mk_optmp1
              ' check condition
              getnib pb,mk_opword,#2
              shr pb,#1 wc
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
        if_c  ret ' terminated...
              and mk_opword,#7
              alts mk_opword,#mk_d0
              getword mk_optmp0,0-0,#0
              sub mk_optmp0,#1 wc
              altd mk_opword,#mk_d0
              setword 0-0,mk_optmp0,#0
        if_nc jmp #mk_dobranch
              ret

mk_get_second_reg
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
        _ret_ mov mk_optmp1,0-0

mk_getopimm_auto
              testb pb,#6 wc
        if_c  jmp #mk_getopimm16
              testb pb,#7 wc
        if_c  jmp #mk_getopimm32
              ' fall through!
mk_getopimm8
              mov mk_optmp0,mk_opword
              call mk_getopf
              getbyte mk_optmp1,mk_opword,#0
        _ret_ mov mk_opword,mk_optmp0
mk_getopimm16
              mov mk_optmp0,mk_opword
              call mk_getopf
              mov mk_optmp1,mk_opword
        _ret_ mov mk_opword,mk_optmp0
mk_getopimm32
              mov mk_optmp0,mk_opword
              call mk_getopf
              mov mk_optmp1,mk_opword
              call mk_getopf
              rolword mk_optmp1,mk_opword,#0
        _ret_ mov mk_opword,mk_optmp0



mk_nibble_6   ' branches
              ' compute destination
              mov mk_optmp1,mk_opword
              signx mk_optmp1,#7 wz
        if_z  call #mk_getopimm16
              signx mk_optmp1,#15
        if_z  sub mk_optmp1,#2
              mov mk_branchdisplace,mk_optmp1
              ' check condition
              getnib pb,mk_opword,#2
              shr pb,#1 wcz
        if_c_and_z jmp #mk_call
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
        if_nc ret
              ' fall through
mk_dobranch
              'debug(uhex_long(mk_virtualpc),shex_long(mk_branchdisplace))
              'mov mk_optmp0,mk_virtualpc '' <--- DELETE THIS WHEN DONE DEBUGGING
              add mk_virtualpc,mk_branchdisplace
              {
              'cmp mk_virtualpc,##$17E6 wz
        'if_e  jmp #.sussy_wussy
              cmp mk_virtualpc,#$1FF wcz
        if_be jmp #.sussy_wussy
              cmps mk_branchdisplace,##$3FFFFF wc
        if_ae jmp #.sussy_wussy
              cmps mk_branchdisplace,##-$3FFFFF wc
        if_ae jmp #.not_a_sussy_baka
.sussy_wussy
              debug("Sussy branch from ",uhex_long_(mk_optmp0)," to ",uhex_long_(mk_virtualpc),uhex_long(mk_a4,mk_a6,mk_d3),uhex_long_array(#@main_ram+$1510,#1))
.not_a_sussy_baka '}
              'debug("branching ",shex(mk_branchdisplace)," to ",uhex_long(mk_virtualpc))
              testb mk_virtualpc,#0 wc
        if_c  jmp #mk_address_error_debug ' TODO: maybe make AE function code read program in this case?
              tjz ptra,#.notfast ' if que not active, this isn't relevant
              ' see if fast branch within que is ok
              sar mk_branchdisplace,#1
              sub mk_romque_left,mk_branchdisplace
              cmp mk_romque_left,#MK_ROMQUE_SIZE+1 wc ' see below
              'debug("would be ",sdec(mk_romque_left))
              ' C set means that (romque_left>=0 && romque_left <= MK_ROMQUE_SIZE). That is the valid range
              ' (Yes, 0 is valid for our purposes, since that will just correctly refill the que on the next getop call)
        if_nc jmp #.notfast
              shl mk_branchdisplace,#1
              add ptra,mk_branchdisplace
              jmp #mk_nextop
.notfast
              mov mk_romque_left,#0
              mov ptra,#0
              mov pb,mk_virtualpc
              zerox pb,#23
              cmp pb,mk_rom_stop wc
        if_ae jmp #.not_rom
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop

.not_rom
              cmp pb,mk_ram_begin wc
        if_b  jmp #mk_address_error_debug ' not the appropriate trap, but good enough
              mov mk_getopf,#mk_getop_ram
              jmp #mk_nextop

              fit 1024

DAT ' MotoKore 68000 hub resident code

              orgh


mk_ea_predec
              mov mk_eatmp0,pb
              and mk_eatmp0,#7
              shr pb,#6
              decod pb ' is now step value
              cmp mk_eatmp0,#7 wz ' A7 is a special snowflake...
        if_z  fge pb,#2

              altd mk_eatmp0,#mk_a0
              sub 0-0,pb
              alts mk_eatmp0,#mk_a0
        _ret_ mov mk_effaddr,0-0

mk_ea_postinc
              mov mk_eatmp0,pb
              and mk_eatmp0,#7
              shr pb,#6
              decod pb ' is now step value
              cmp mk_eatmp0,#7 wz ' A7 is a special snowflake...
        if_z  fge pb,#2

              alts mk_eatmp0,#mk_a0
              mov mk_effaddr,0-0
              altd mk_eatmp0,#mk_a0
        _ret_ add 0-0,pb

mk_ea_displace
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0

              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              signx mk_opword,#15
              add mk_effaddr,mk_opword
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_ea_index
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0
              'debug(if(mk_debug_ctr),"from address register: ",uhex_long_(mk_effaddr))

              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              ' handle index reg
              getnib pb,mk_opword,#3
              alts pb,#mk_d0
              mov pb,0-0
              testb mk_opword,#11 wc
        if_nc signx pb,#15
              'debug(if(mk_debug_ctr),"from index register: ",uhex_long_(pb))
              add mk_effaddr,pb
              ' handle displacement
              signx mk_opword,#7
              'debug(if(mk_debug_ctr),"from displacement: ",uhex_long_(mk_opword))
               add mk_effaddr,mk_opword
              'debug(if(mk_debug_ctr),"final: ",uhex_long_(mk_effaddr))
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_ea_headache
              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              'debug("in mk_ea_headache ",uhex_word(mk_opword))
              rczr pb wcz
        if_01 jmp #.longabs
        if_11 jmp #.index
              signx mk_opword,#15 ' absolute short or PC displacement
              mov mk_effaddr,mk_opword
        if_1x add mk_effaddr,mk_virtualpc
        if_1x sub mk_effaddr,#2
        _ret_ mov mk_opword,mk_eatmp1 ' restore

.longabs
              mov  mk_effaddr,mk_opword
              call mk_getopf
              rolword mk_effaddr,mk_opword,#0
        _ret_ mov mk_opword,mk_eatmp1 ' restore

.index
              mov mk_effaddr,mk_virtualpc
              sub mk_effaddr,#2
              ' handle index reg
              getnib pb,mk_opword,#3
              alts pb,#mk_d0
              mov pb,0-0
              testb mk_opword,#11 wc
        if_nc signx pb,#15
              add mk_effaddr,pb
              ' handle displacement
              signx mk_opword,#7
              add mk_effaddr,mk_opword
              'debug("computed address for (d8,PC,Dn) is ",uhex_long(mk_effaddr),uhex_long(mk_virtualpc))
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_hub_wr_sr
              ' Status register write escalated
              ' C is still super bit from SR
        if_nc mov pb,#$20 ' privilege violation
        if_nc jmp #mk_hub_trapit
mk_hub_set_sr
              'debug("in mk_hub_set_sr ",uhex_word(mk_sr,mk_memvalue),uhex_long(mk_virtualpc))
              testb mk_sr,#MK_SUPER_BIT wc
              testb mk_memvalue,#MK_SUPER_BIT xorc
              ' switching supervisor/user: swap stack pointers
        if_c  xor mk_a7,mk_othersp
        if_c  xor mk_othersp,mk_a7
        if_c  xor mk_a7,mk_othersp

              ' configure hooks
              and mk_memvalue,##%10100111_00011111
              testb mk_memvalue,#MK_TRACE_BIT wc
        if_c  mov mk_ihook1,##(%1111_1101100_0<<20) + @mk_hub_tracehook ' JMP #\mk_hub_tracehook
        if_c  jmp #.no_irqhooks
              ' check irq level
              getnib pb,mk_memvalue,#2
              cmp pb,#6 wc
        if_ae mov mk_ihook1,#0 ' NOP
        if_b  mov mk_ihook1,##(%1111_1011110_010_000000101<<9)+mk_irq6ptr ' JSE2 mk_irq6ptr
              cmp pb,#4 wc
        if_ae mov mk_ihook2,#0 ' NOP
        if_b  mov mk_ihook2,##(%1111_1011110_010_000000100<<9)+mk_irq4ptr ' JSE1 mk_irq4ptr
.no_irqhooks

              mov mk_sr,mk_memvalue
              ret wcz

mk_hub_irq6
              debug("Vertical IRQ hits at ",uhex_long(mk_virtualpc))
              mov pb,#6
              skip #1
mk_hub_irq4
              mov pb,#4
mk_hub_do_irq
              'debug("running IRQ ",udec(pb))
              'debug(uhex_word_array(#@vdp_ram+$FB60,#2))
              'waitx ##10_000_000
              ' get vector
              mov mk_optmp0,pb
              shl mk_optmp0,#2
              add mk_optmp0,##mk_vectorcache+$60
              rdlong mk_branchdisplace,mk_optmp0
              sub mk_branchdisplace,mk_virtualpc
              ' set supervisor mode, unset trace mode and set interrupt priority
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith pb,#MK_SUPER_BIT-8
              setbyte mk_memvalue,pb,#1
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              'waitx ##_CLKFREQ/120
              jmp #mk_dobranch




mk_hub_tracehook
              getnib pb,mk_sr,#2
              cmp pb,#6 wc
        if_b  JSE2 mk_irq6ptr
              cmp pb,#4 wc
        if_b  JSE1 mk_irq4ptr
              mov pb,#$24
              jmp #mk_hub_trapit


mk_nibble_A   ' Line A emulator
              mov pb,#$28
              jmp #mk_hub_trapit

mk_nibble_F   ' Line F emulator
              mov pb,#$2C
              ' fall through
mk_hub_trapit
              debug("handling trap with vector ",uhex_(pb)," @ ",uhex_long(mk_virtualpc))
              ' get vector
              add pb,##mk_vectorcache
              rdlong mk_branchdisplace,pb
              sub mk_branchdisplace,mk_virtualpc
              ' set supervisor mode, unset trace mode
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith mk_memvalue,#MK_SUPER_BIT
              bitl mk_memvalue,#MK_TRACE_BIT
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              jmp #mk_dobranch

mk_address_error_debug
              'drvh #38
              debug("special edition spicy address error ")
              'jmp #$
mk_address_error ' can basically only happen due to misalignment?
              debug("something something address error ",uhex_long(mk_effaddr),uhex_long(mk_virtualpc),uhex_long(mk_optmp0))
              debug(uhex_long(mk_a0))
              'jmp #$
              ' get vector
              rdlong mk_branchdisplace,##mk_vectorcache+$0C
              sub mk_branchdisplace,mk_virtualpc
              mov mk_optmp1,mk_effaddr ' save for later
              ' set supervisor mode, unset trace mode
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith mk_memvalue,#MK_SUPER_BIT
              bitl mk_memvalue,#MK_TRACE_BIT
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              ' push instruction in progress (maybe)
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_opword
              call mk_writef
              ' push erroneous address
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_optmp1
              call mk_writef
              ' push flags
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              ' slight problem: we don't know half this shit
              mov mk_memvalue,#%10_001 ' assume it's a data read. It's probably a data read. Isn't it?
              testb mk_optmp2,#MK_SUPER_BIT wc
              bitc mk_memvalue,#2 ' we do know what mode we were in though
              call mk_writef
              jmp #mk_dobranch








mk_hub_stop
              call #mk_getopimm16
              debug("STOP instruction ",uhex_word(mk_opword),uhex_word(mk_optmp1)," encountered")
              'debug(uhex_word_array(#vdp_ram+$C418,#16))
               mov mk_memvalue,mk_optmp1
               call #mk_wr_sr
.waitloop
              pollatn wc
        if_c  rdbyte pb,#atn_command wc
        if_c  jmp #mk_hub_hotreset
              getnib pb,mk_sr,#2
              cmp pb,#6 wc
        if_b  JSE2 mk_irq6ptr
              cmp pb,#4 wc
        if_b  JSE1 mk_irq4ptr
              jmp #.waitloop
              debug("jooo wtf")

mk_hub_reset
              debug("RESET instruction ",uhex_word(mk_opword)," encountered")
              jmp #$

mk_hub_nop
              waitx #32 ' make NOP slow - backport from NeoYume
              ' Mega special hack to make SEGA logo in Sonic 1 sound correct.
              ' Detect NOP + DBF loop and apply extra delay
              rdlong mk_optmp0,ptra
              movbyts mk_optmp0,#%%2301
              andn mk_optmp0,#7 ' mask out register no
              cmp mk_optmp0,##((-4)<<16)|%0101_0001_11001_000 wz
              cmps mk_romque_left,#2 wc
        if_01 waitx #100

              cmp mk_opword,##$4E71 wz
        if_z  ret
              debug("weird NOP ? ",uhex_word(mk_opword),uhex_long(mk_virtualpc))
              ret



mk_hub_rte
              testb mk_sr,#MK_SUPER_BIT wc
        if_nc mov pb,#$20 ' privilege violation
        if_nc jmp #mk_hub_trapit
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              call mk_readf
              mov mk_optmp2,mk_memvalue ' only write SR after we're done popping
              add mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              mov mk_branchdisplace,mk_memvalue
              sub mk_branchdisplace,mk_virtualpc
              add mk_a7,#4
              'debug("RTE from ",uhex_long_(mk_virtualpc)," to ",uhex_long(mk_memvalue))
              mov mk_memvalue,mk_optmp2 ' only write SR after we're done popping
              push ##mk_dobranch
              jmp #mk_wr_sr

mk_hub_rtr
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              call mk_readf
              call #mk_wr_ccr
              add mk_a7,#2
              ' fall through
mk_hub_rts
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              'debug("SP before RTS: ",uhex_long(mk_a7),uhex_long(mk_memvalue),uhex_long(mk_virtualpc))
              mov mk_branchdisplace,mk_memvalue
              sub mk_branchdisplace,mk_virtualpc
              add mk_a7,#4
              jmp #mk_dobranch


mk_hub_trapv
              testb mk_sr,#MK_OVER_BIT wc
        if_nc ret
              mov pb,#$1C
              jmp #mk_hub_trapit

mk_hub_moveusp
              testb mk_sr,#MK_SUPER_BIT wc
        if_nc mov pb,#$20
        if_nc jmp #mk_hub_trapit ' TODO: proper non-supervisor trap
              mov pb,mk_opword
              and pb,#7
              testb mk_opword,#3 wc ' if C, read USP, if NC, write USP
              debug("in mk_hub_moveusp ",uhex_word(mk_opword),udec(pb),uhex_long(mk_othersp),uhex_long(mk_nibble_impl_tbl+3),uhex_long(inb))
        if_c  altd pb,#mk_a0
        if_c  mov 0-0,mk_othersp
        if_nc alts pb,#mk_a0
        if_nc mov mk_othersp,0-0
              debug("in mk_hub_moveusp again ",uhex_word(mk_opword),udec(pb),uhex_long(mk_othersp),uhex_long(mk_nibble_impl_tbl+3))
              ret



mk_hub_tst_tas
              getbyte mk_optmp0,mk_opword,#0
              cmp mk_optmp0,#%11_111_100 wz
        if_z  jmp #mk_illegal
              test mk_opword,#%11_000_000 wcz
        if_00 andn pb,#%11_000_000 ' convert TAS to TST.B (Note: if_00 here really means ""if_11"" (not zero and even parity))
              call #mk_setup_operand_auto
              call mk_readf
              'debug("in TST/TAS with ",uhex_long(mk_virtualpc),uhex_word(mk_opword),uhex(mk_memvalue),uhex(mk_shiftit),uhex(mk_d0))
              shl mk_memvalue,mk_shiftit wz
              testb mk_memvalue,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              'debug("SR after",ubin_word(mk_sr))
              test mk_opword,#%11_000_000 wcz
        if_c_or_z ret ' not TAS
              test mk_opword,#%00_111_000 wz
        if_nz ret ' not register TAS (memory TAS is broken due to buggy SEGA bus logic)
              shr mk_memvalue,#24
              or mk_memvalue,#$80
              jmp mk_writef

mk_hub_link_trap
              testb mk_opword,#4 wc
        if_nc jmp #.trap
              testb mk_opword,#3 wc
        if_c  jmp #.unlk
              ' okay, LINK
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              call #mk_setup_ea32
              alts mk_optmp0,#mk_a0
              mov mk_memvalue,0-0
              call mk_writef
              altd mk_optmp0,#mk_a0
              mov 0-0,mk_a7
              call #mk_getopimm16
              signx mk_optmp1,#15
        _ret_ add mk_a7,mk_optmp1


.unlk         ' UNLK
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              alts mk_optmp0,#mk_a0
              mov mk_a7,0-0
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              altd mk_optmp0,#mk_a0
              mov 0-0,mk_memvalue
        _ret_ add mk_a7,#4


.trap
              getnib pb,mk_opword,#0
              shl pb,#2
              add pb,#$80
              jmp #mk_hub_trapit


mk_nibble_7 ' MOVEQ
              mov pb,mk_opword
              and pb,mk_dreg_mask
              signx mk_opword,#7 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              alti pb,#%000_100_000
.moveop _ret_ mov mk_d0,mk_opword


mk_hub_movem  ' MOVEM
              call #mk_getopimm16
              testb mk_opword,#10 wc
        if_c  neg mk_optmp2,#1
        if_c  jmp #.movem_do_read
              'debug(ubin_word(mk_opword))
              test mk_opword,#%011_000 wz
        if_z  mov mk_optmp2,#mk_a7
        if_z  jmp #.movem_do_predec_write
              mov mk_optmp2,#0
              call #mk_compute_ea
              jmp #.movem_write

              ' MOVEM normal write
.writeloop
              testb mk_opword,#6 wc ' long/word ?
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_writef
        if_c  add mk_effaddr,#4
        if_nc add mk_effaddr,#2
.movem_write
              'debug("at .movem_write ",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1))
              alti mk_optmp2,#%000_000_111 ' increment register ptr
              mov mk_memvalue,0-0
              'debug("got value ",uhex_long(mk_memvalue),uhex_long(mk_optmp2))
              shr mk_optmp1,#1 wcz
        if_c  jmp #.writeloop
        if_nc_and_nz jmp #.movem_write
              ret



              ' MOVEM predec write
.movem_do_predec_write
              mov pb,mk_opword
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0
              jmp #.movem_predec_write

.predec_write_loop
              testb mk_opword,#6 wc ' long/word ?
        if_c  sub mk_effaddr,#4
        if_nc sub mk_effaddr,#2
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_writef
.movem_predec_write
              'debug("at .movem_predec_write ",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1))
              alti mk_optmp2,#%000_000_110 ' decrement register ptr
              mov mk_memvalue,0-0
              shr mk_optmp1,#1 wcz
        if_c  jmp #.predec_write_loop
        if_nc_and_nz jmp #.movem_predec_write
              ' done.
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ mov 0-0,mk_effaddr

              ' MOVEM read
.movem_do_read
              call #mk_compute_ea
              jmp #.movem_read

.readloop

              testb mk_opword,#6 wc ' long/word ?
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_readf
        if_nc signx mk_memvalue,#15
              altd mk_optmp2,#mk_d0
              mov 0-0,mk_memvalue
        if_c  add mk_effaddr,#4
        if_nc add mk_effaddr,#2
.movem_read
              'debug("at .movem_read",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1),uhex_word(mk_opword))
              add mk_optmp2,#1
              shr mk_optmp1,#1 wcz
        if_c  jmp #.readloop
        if_nc_and_nz jmp #.movem_read
              ' if empty
              mov pb,mk_opword
              and pb,#%111_000
              cmp pb,#%011_000 wz ' is postinc mode?
        if_nz ret
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ mov 0-0,mk_effaddr




mk_hub_movep  ' MOVEP
              debug("in mk_hub_movep")
              ' compute address
              call #mk_getopimm16
              signx mk_optmp1,#15
              mov mk_effaddr,mk_optmp1
              getnib pb,mk_opword,#0 ' will be %1xxx
              alts pb,#mk_d0
              add mk_effaddr,0-0

              testb mk_opword,#7 wc
        if_c  jmp #.movep_write

              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              testb mk_opword,#6 wc
        if_nc mov mk_shiftit,#16
        if_nc jmp #.read_done
              mov mk_shiftit,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
.read_done
              mov mk_memvalue,mk_optmp2
              jmp #mk_write_second_reg


.movep_write
              call #mk_get_second_reg
              testb mk_opword,#6 wc
        if_nc shl mk_optmp1,#16
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#3
              call mk_writef
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#2
              call mk_writef
              testb mk_opword,#6 wc
        if_nc ret
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#1
              call mk_writef
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#0
              jmp mk_writef



mk_hub_mul    ' MULU/MULS
              mov pb,mk_opword
              call #mk_setup_operand16_move
              call mk_readf
              mov pb,mk_opword
              and pb,mk_dreg_mask
              testb mk_opword,#8 wc ' set c if signed
        if_nc alti pb,#%000_100_000
        if_nc mul 0-0,mk_memvalue wz
        if_c  alti pb,#%000_100_000
        if_c  muls 0-0,mk_memvalue wz
              bitz mk_sr,#MK_ZERO_BIT
              alti pb,#%000_100_000
              testb 0-0,#31 wz
              bitz mk_sr,#MK_NEG_BIT
        _ret_ andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK

mk_hub_div    ' DIVU/DIVS
              mov pb,mk_opword
              call #mk_setup_operand16_move
              call mk_readf ' get divider
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
              mov mk_optmp0,0-0 ' get divisor
              tjz mk_memvalue,#.by_zero
              testb mk_opword,#8 wz ' set z if signed
        if_z  signx mk_memvalue,#15
        if_z  abs mk_memvalue wc
        if_z  wrc mk_optmp1 ' bit 0 holds appropriate result sign
        if_z  abs mk_optmp0 wc
              qdiv mk_optmp0,mk_memvalue
        if_z_and_c bitnot mk_optmp1,#0
              bitl mk_sr,#MK_CARRY_BIT
              getqx mk_memvalue    ' quotient
              getqy mk_optmp0      ' remainder
              ' Apply sign
        if_z  testb mk_optmp1,#0 wc
        if_z  negc mk_memvalue
        if_z  negc mk_optmp0
              testb mk_memvalue,#15 wc
              bitc mk_sr,#MK_NEG_BIT
              ' Check overflow
              mov mk_optmp1,mk_memvalue
        if_z  signx mk_memvalue,#15
        if_nz zerox mk_memvalue,#15
              cmp mk_optmp1,mk_memvalue wz
              bitnz mk_sr,#MK_OVER_BIT
        if_nz bith mk_sr,#MK_NEG_BIT ' Undocumented flag
        if_nz ret
              ' set Z flag (not set on overflow?)
              cmp mk_memvalue,#0 wz
              bitz mk_sr,#MK_ZERO_BIT
              ' write back
              setword mk_memvalue,mk_optmp0,#1
              altd pb,#mk_d0
        _ret_ mov 0-0,mk_memvalue

.by_zero
              mov pb,#$14
              ' Strange flags...
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK|MK_NEG_MASK
              testb mk_opword,#8 wc ' set c if signed
        if_c  bith mk_sr,#MK_ZERO_BIT
        if_c  jmp #mk_hub_trapit
              shr mk_optmp0,#16
              cmps mk_optmp0,#0 wcz
              bitz mk_sr,#MK_ZERO_BIT
              bitc mk_sr,#MK_NEG_BIT
              jmp #mk_hub_trapit


mk_hub_srmove
              call #mk_setup_operand16_move
              testb mk_opword,#10 wc ' FROM (NC) or TO (C) SR
        if_nc push mk_writef
        if_nc jmp #mk_rd_sr
              testb mk_opword,#9 wz ' if to SR, to whole SR (Z) or CCR only (NZ)
        if_z  push #mk_wr_sr
        if_nz push #mk_wr_ccr
              jmp mk_readf



mk_hub_exg
              ' okay got EXG
              ' encoding is a bit stupid, see manual
              mov pb,mk_opword
              and pb,#7 ' register Y
              mov pa,mk_opword
              shr pa,#9
              and pa,#7 ' register X
              testb mk_opword,#3 wc
              testb mk_opword,#7 wz
        if_c  add pb,#8
        if_c_and_nz add pa,#8
              alts pb,#mk_d0
              mov mk_optmp0,0-0
              alts pa,#mk_d0
              mov mk_optmp1,0-0
              altd pb,#mk_d0
              mov 0-0,mk_optmp1
              altd pa,#mk_d0
        _ret_ mov 0-0,mk_optmp0


mk_hub_abcd   ' ABCD
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              alts mk_optmp0,#mk_d0
              getbyte mk_optmp1,0-0,#0
              alts mk_optmp2,#mk_d0
              getbyte mk_memvalue,0-0,#0
.doit
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L52
              ' compute ss
              testb mk_sr,#MK_EXT_BIT wc
              mov mk_optmp0,mk_memvalue
              addx mk_optmp0,mk_optmp1
              ' compute bc
              mov mk_optmp2,mk_memvalue
              and mk_optmp2,mk_optmp1
              andn mk_memvalue,mk_optmp0 ' note: don't need the original operands anymore
              or mk_optmp2,mk_memvalue
              andn mk_optmp1,mk_optmp0 ' note: ^^
              or mk_optmp2,mk_optmp1
              and mk_optmp2,#$88
              ' compute dc
              mov mk_memvalue,mk_optmp0
              add mk_memvalue,#$66
              xor mk_memvalue,mk_optmp0
              and mk_memvalue,#$110
              shr mk_memvalue,#1
              ' compute corf
              or mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              add mk_memvalue,mk_optmp0
              ' write to register if needed
              testb mk_opword,#3 wc
        if_nc and mk_opword,mk_dreg_mask ' don't need opword anymore
        if_nc alti mk_opword,#%000_100_000
        if_nc setbyte 0-0,mk_memvalue,#0
              ' compute carry
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT
              ' returns either to nextop or mk_writef
.memmode
              altd mk_optmp0,#mk_a0
              sub  0-0,#1
              alts mk_optmp0,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              call mk_readf
              mov mk_optmp1,mk_memvalue
              altd mk_optmp2,#mk_a0
              sub  0-0,#1
              alts mk_optmp2,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              ' - jmp into mk_readf
              ' - returns into .doit
              ' - returns into mk_writef
              push mk_writef
              loc pb,#.doit
              push pb
              jmp mk_readf


mk_hub_sbcd
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              alts mk_optmp0,#mk_d0
              getbyte mk_optmp1,0-0,#0
              alts mk_optmp2,#mk_d0
              getbyte mk_memvalue,0-0,#0
.doit
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L80
              ' compute dd
              testb mk_sr,#MK_EXT_BIT wc
              mov mk_optmp0,mk_memvalue
              subx mk_optmp0,mk_optmp1
              ' compute bc
              not mk_optmp2,mk_memvalue
              and mk_optmp2,mk_optmp1
              not  mk_memvalue ' note: don't need the original operands anymore
              and mk_memvalue,mk_optmp0
              or mk_optmp2,mk_memvalue
              and mk_optmp1,mk_optmp0 ' note: ^^
              or mk_optmp2,mk_optmp1
              and mk_optmp2,#$88
              ' compute corf
              mov mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              subr mk_memvalue,mk_optmp0
              ' write to register if needed
              testb mk_opword,#3 wc
        if_nc and mk_opword,mk_dreg_mask ' don't need opword anymore
        if_nc alti mk_opword,#%000_100_000
        if_nc setbyte 0-0,mk_memvalue,#0
              ' compute carry
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT
              ' returns either to nextop or mk_writef
.memmode
              altd mk_optmp0,#mk_a0
              sub  0-0,#1
              alts mk_optmp0,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              call mk_readf
              mov mk_optmp1,mk_memvalue
              altd mk_optmp2,#mk_a0
              sub  0-0,#1
              alts mk_optmp2,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              ' - jmp into mk_readf
              ' - returns into .doit
              ' - returns into mk_writef
              push mk_writef
              loc pb,#.doit
              push pb
              jmp mk_readf




mk_hub_nbcd
              'debug ("in NBCD with ",uhex(mk_opword))
              call #mk_setup_operand8_move ' opword still in PB!
              call mk_readf
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L104
              ' compute dd
              neg mk_optmp0,mk_memvalue
              testb mk_sr,#MK_EXT_BIT wc
        if_c  sub mk_optmp0,#1
              ' compute bc
              mov mk_optmp2,mk_memvalue
              or mk_optmp2,mk_optmp0
              and mk_optmp2,#$88
              ' compute corf
              mov mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              subr mk_memvalue,mk_optmp0
              ' compute carry
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
              bitc mk_sr,#MK_NEG_BIT
              jmp mk_writef



mk_hub_addsubx
              'debug("in mk_hub_addsubx")
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              ' read source
              mov pb,mk_opword ' operand is already register
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read destination
              mov pb,mk_opword
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              call #mk_setup_operand_auto
              call mk_readf
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_nc jmp #.do_sub
              ' fall  through
.do_add
              'debug("in .do_add with ",uhex(mk_memvalue),uhex(mk_optmp1),udec(mk_shiftit))
              testb mk_sr,#MK_EXT_BIT wc
              ' must be rcl for correct ripple carry
              rcl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              addsx mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual add
              testb mk_sr,#MK_EXT_BIT wc
              addx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              'debug("got result ",uhex(mk_memvalue))
              jmp mk_writef

.do_sub
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_memvalue
              testb mk_sr,#MK_EXT_BIT wc
              subsx mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              testb mk_sr,#MK_EXT_BIT wc
              subx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              jmp mk_writef

.memmode
              ' read source
              mov pb,mk_opword
              xor pb,#%101_000 ' turn into -(An) (is %001_xxx to begin with)
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read destination
              mov pb,mk_opword
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              or pb,#%100_000 ' turn into -(An) (is %001_xxx to begin with)
              call #mk_setup_operand_auto
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_c  loc pb,#.do_add
        if_nc loc pb,#.do_sub
              push pb
              jmp mk_readf



mk_hub_negx
              '' NOTE: operand is already set up and shifted
              mov mk_optmp1,mk_memvalue
              mov mk_memvalue,#0
              mov mk_optmp0,#0
              testb mk_sr,#MK_EXT_BIT wc
              subsx mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              testb mk_sr,#MK_EXT_BIT wc
              subx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              'debug("negx result ",uhex_long(mk_memvalue),ubin(mk_shiftit))
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              jmp mk_writef


mk_hub_cmpm
              ' read destination
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              or pb,#%011_000 ' turn into (An)+
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read source
              mov pb,mk_opword
              or pb,#%011_000 ' turn into (An)+
              call #mk_setup_operand_auto
              push #mk_cmp_common
              jmp mk_readf

mk_hub_chk
              call #mk_setup_operand16_move ' pb already loaded
              call mk_readf
              call #mk_get_second_reg
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK ' Undocumented flags
              cmps mk_optmp1,#0 wcz
              bitz mk_sr,#MK_ZERO_BIT ' Undocumented flag
              mov pb,#$18
        if_b  bith mk_sr,#MK_NEG_BIT
        if_b  jmp #mk_hub_trapit
              cmps mk_optmp1,mk_memvalue wcz
        if_be ret
              bitl mk_sr,#MK_NEG_BIT
              jmp #mk_hub_trapit

mk_hub_cogatn
              rdbyte pb,#atn_command wcz
        if_z  jmp #mk_nextop
        if_c  jmp #mk_hub_hotreset
              jmp #mk_hub_cogatn


DAT ' MotoKore 68000 init code


              orgh
mk_init
              ' load code
              setq #495
              rdlong 0,##@mk_cogbase
              setq2 #511
              rdlong 0,##@mk_lutbase

              ' Compute timing constant for H counter emulation
              ' (note that "pixel" here means hcounter values, which are actually 2 pixels)
              rdlong pa,#_clkf
              qmul pa,##round(6.36e-5/211.0*4294967296.0) ' cy/s * s/px -> cy/px
              getqy pa ' cycles per pixel
              getqx pb ' fractional part
              rolword pa,pb,#1
              qfrac #1,pa
              getqx pa ' our timing reciporal
              wrword pa,#vdp_cyc2hcnt_w
              debug("H counter timing constant: ",udec_word_array(#vdp_cyc2hcnt_w,#1))

              ' Compute timing constant for 6-button state machine reset
              rdlong pa,#_clkf
              qdiv pa,##666 ' 1.5 ms - unfortunate reciporal
              getqx pa
              wrlong pa,#io_6btn_timeout

              ' Reset I/O ports (so it seems like we're cold-booting)
              wrbyte #0,#io_pl1_dir
              wrbyte #0,#io_pl2_dir
              wrbyte #0,#io_pl1_out
              wrbyte #0,#io_pl2_out


              ' allocate all the locks like some sort of maniac
              {
              mov pa,#0
              rep @.lockmadness,#16
              locknew pb wc
        if_nc bith pa,pb
.lockmadness
              ' deallocate all the ones we don't want
              andn pa,##STATIC_LOCKS
              mov pb,#0
              rep @.lockmadness2,#16
              shr pa,#1 wc
        if_c  lockret pb
              add pb,#1
.lockmadness2}

              rdbyte mk_romio_zerox,#rom_zerox
              sub mk_romio_zerox,#2 ' we apply it to long-unit addresses

              rdlong mk_sram_begin,#sram_map_start
              rdlong mk_sram_stop,#sram_map_end

              ' Reset ROM/SRAM mapping
              rdbyte mk_memvalue,#sram_bankreg
              call #sram_set_bank

#ifdef USE_PSRAM_EITHER
              fltl #PSRAM_CLK
#ifdef USE_PSRAM_SLOW
              wrpin ##P_PULSE|P_OE|(PSRAM_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #PSRAM_CLK
              wxpin ##3 + (2<<16), #PSRAM_CLK
#else
              wrpin ##P_TRANSITION|P_OE|(PSRAM_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #PSRAM_CLK
              wxpin #1, #PSRAM_CLK
              drvl #PSRAM_CLK
#endif

              wrpin ##P_INVERT_OUTPUT,#PSRAM_SELECT
              drvl #PSRAM_SELECT

              wrpin ##(PSRAM_SYNC_DATA ? P_SYNC_IO : P_ASYNC_IO),mk_psram_pinfield

              setxfrq mk_nco_slow
              waitx #200
#endif
#ifdef USE_HYPER
              fltl #HYPER_CLK
              wrpin ##P_TRANSITION|P_OE|(HYPER_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #HYPER_CLK
              wxpin #2, #HYPER_CLK

              wrpin ##P_INVERT_OUTPUT,#HYPER_SELECT
              drvl #HYPER_SELECT

              wrpin ##(HYPER_SYNC_DATA ? P_SYNC_IO : P_ASYNC_IO),#HYPER_BASE addpins 7

              drvh #HYPER_RESET

              setxfrq mk_nco_slow
              waitx #200
#endif

              ' setup interrupts
              setse1 #$10+HINT_LOCK
              setse2 #$10+VINT_LOCK
              'drvl #38 addpins 1 ' DEBUG LEDs

              ' cache vector table
              mov pa,#0
              mov mk_romio_length,#64
              mov mk_romio_target,##mk_vectorcache
              call #mk_readrom
              debug(uhex_long_array(#mk_vectorcache,#64))
              ' preswap to little endian
              loc ptra,#mk_vectorcache
              rep @.vswaplp,#64
              rdlong pb,ptra
              movbyts pb,#%%0123
              wrlong pb,ptra++
.vswaplp

mk_hub_hotreset
              wrbyte #0,#atn_command
              mov mk_sr,##MK_SUPER_MASK + (7<<8)
              mov mk_ihook1,#0
              mov mk_ihook2,#0
              'call #mk_check_core_integrity
              ' initialize PC and SP
              mov mk_virtualpc,#0
              rdlong mk_branchdisplace,##mk_vectorcache+$04
              rdlong mk_a7,##mk_vectorcache+$00
              debug("inital pc and sp ",uhex_long(mk_branchdisplace),uhex_long(mk_a7))
              mov ptra,#0
              neg mk_romque_left,#1
              jmp #mk_dobranch

              {
mk_check_core_integrity
              loc ptrb,#@mk_nibble_impl_tbl
              mov mk_eatmp1,#mk_nibble_impl_tbl
              'debug("Checking core integrity...")
.chklp
              cmp mk_eatmp1,#mk_cogvar_start wcz
        if_z  ret wcz
              rdlong mk_eatmp0,ptrb++
              alti mk_eatmp1,#%000_000_111
              mov pb,0-0
              cmp mk_eatmp0,pb wz
              ' ignore intentionally self-modifying code
        if_z jmp #.chklp
        if_nz cmp mk_eatmp1,#mk_ihook1+1 wz
        if_nz cmp mk_eatmp1,#mk_ihook2+1 wz
        if_nz cmp mk_eatmp1,#mk_thelogicop+1 wz
        if_nz cmp mk_eatmp1,#mk_romque_left+1 wz
        if_nz cmp mk_eatmp1,#mk_rd8_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr8_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_rd16_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr16_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_rd32_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr32_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_longio_tmp+1 wz
        if_nz cmp mk_eatmp1,#mk_addsuba+8+1 wz
        if_nz cmp mk_eatmp1,#mk_psram_read_cmd+1 wz
        if_z jmp #.chklp
              drvh #39
              sub mk_eatmp1,#1
              debug("Core integrity violation @ ",uhex_(mk_eatmp1)," expected ",uhex_long_(mk_eatmp0)," got ",uhex_long_(pb),dly(#1000))
              add mk_eatmp1,#1
              jmp #.chklp   '}

DAT ' I/O glue code


iog_write16
              ' test special cases
              testb mk_eacache,#16 wc
        if_nc jmp #zbus_write16
              testb mk_eacache,#12 wc
              testb mk_eacache,#13 wz
        if_c_and_z  jmp #time_write16
        if_c  shr mk_memvalue,#8
        if_c  jmp #iog_z80_ctrl
              mov mk_memtmp0,mk_eacache
              shr mk_memtmp0,#1
              jmp #iog_write8_internal
              ' memvalue not being 0..255 should be handled everywhere, anyways
iog_write8
              'debug("in iog_write8 with ",uhex_long(mk_eacache))
              ' everything is 8 bit, so we only really care about that
              testb mk_eacache,#16 wc
        if_nc jmp #zbus_write
              testb mk_eacache,#12 wc
              testb mk_eacache,#13 wz
        if_c_and_z  jmp #time_write8
        if_c  jmp #iog_z80_ctrl
              mov mk_memtmp0,mk_eacache
              shr mk_memtmp0,#1 wc
        if_nc ret wcz ' even address ???????
iog_write8_internal
              'debug("in iog_write8_internal with ",uhex_long(mk_eacache))
              ' Okay, got genuine register write
              getnib pa,mk_memtmp0,#0
              fle pa,#7
              mul pa,#4
              jmprel pa
.iog_regwr_base
              orgh .iog_regwr_base + 0*4*4 ' ???? ($A10001)
              ret wcz
              orgh .iog_regwr_base + 1*4*4 ' player 1 controller out ($A10003)
              rdword mk_memtmp0,#io_pl1_dir
              wrbyte mk_memvalue,#io_pl1_out
              jmp #.pl1_setout
              orgh .iog_regwr_base + 2*4*4 ' player 2 controller out ($A10005)
              rdword mk_memtmp0,#io_pl2_dir
              wrbyte mk_memvalue,#io_pl2_out
              jmp #.pl2_setout
              orgh .iog_regwr_base + 3*4*4 ' modem out ($A10007)
              ret wcz
              orgh .iog_regwr_base + 4*4*4 ' player 1 direction ($A10009)
              rdword mk_memtmp0,#io_pl1_dir
              wrbyte mk_memvalue,#io_pl1_dir
              jmp #.pl1_setout
              orgh .iog_regwr_base + 5*4*4 ' player 2 direction ($A1000B)
              rdword mk_memtmp0,#io_pl2_dir
              wrbyte mk_memvalue,#io_pl2_dir
              jmp #.pl2_setout
              orgh .iog_regwr_base + 6*4*4 ' modem direction ($A1000D)
              ret wcz
              orgh .iog_regwr_base + 7*4*4 ' ???? don't care  ($A1000F)
              ret wcz

.pl1_setout
              rdword mk_memtmp1,#io_pl1_dir

              pollct1 wc ' if timer elapsed, reset controller state machine
        if_c  wrbyte #0,#io_pl1_state

              testb mk_memtmp0,#6+8 wc ' old out bit
              testbn mk_memtmp0,#6 orc ' if dir is low, pullup
              testb mk_memtmp1,#6+8 wz ' new out bit
              testbn mk_memtmp1,#6 orz ' if dir is low, pullup

    if_not_10 ret wcz ' Return if not falling edge
              ' increment state
              rdbyte mk_memtmp2,#io_pl1_state
              incmod mk_memtmp2,#3
              wrbyte mk_memtmp2,#io_pl1_state
              ' reset timeout
              rdlong mk_memtmp0,#io_6btn_timeout
              getct mk_memtmp2
              addct1 mk_memtmp2,mk_memtmp0
              ret wcz

.pl2_setout
              rdword mk_memtmp1,#io_pl2_dir

              pollct2 wc ' if timer elapsed, reset controller state machine
        if_c  wrbyte #0,#io_pl2_state

              testb mk_memtmp0,#6+8 wc ' old out bit
              testbn mk_memtmp0,#6 orc ' if dir is low, pullup
              testb mk_memtmp1,#6+8 wz ' new out bit
              testbn mk_memtmp1,#6 orz ' if dir is low, pullup

    if_not_10 ret wcz ' Return if not falling edge
              ' increment state
              rdbyte mk_memtmp2,#io_pl2_state
              incmod mk_memtmp2,#3
              wrbyte mk_memtmp2,#io_pl2_state
              ' reset timeout
              rdlong mk_memtmp0,#io_6btn_timeout
              getct mk_memtmp2
              addct2 mk_memtmp2,mk_memtmp0
              ret wcz

time_write16
              getbyte mk_memtmp0,mk_eacache,#0
              bith mk_memtmp0,#0
              jmp #time_write_internal
time_write8
              getbyte mk_memtmp0,mk_eacache,#0
              bith mk_memtmp0,#0 wcz
        if_nc ret wcz ' ignore even address
time_write_internal
              cmp mk_memtmp0,#$F1 wz
        if_z  jmp #sram_set_bank
              ' Undecoded....
              ret wcz


zbus_write16
              shr mk_memvalue,#8 ' Only MSB gets through
zbus_write
              debug("Z80 Bus write! ",uhex_long_(mk_eacache),uhex_byte_(mk_memvalue),uhex_long_(mk_virtualpc),uhex_byte_array_(#@zbus_status,#1))
              mov pa,mk_eacache
              zerox pa,#14 ' 68000 access is always to lower 32k, I think?
              testb pa,#14 wc
        if_nc jmp #.zram_write

              cmp pa,##$6000 wc
        if_b  jmp #opn_portwrite
              cmp pa,##$6100 wc
        if_b  jmp #.zbus_bank_write
              cmp pa,##$7F00 wc
        if_b  ret wcz ' Unused area
              ' VDP through Z bus... I think PSG might need to be present here?
              ret wcz


.zram_write
              zerox pa,#12 ' RAM is 8K
              add pa,##@z80_ram
              wrbyte mk_memvalue,pa
              ret wcz

.zbus_bank_write
              ' This technically should work, but I sure hope I don't need to emulate it...
              ret wcz





iog_z80_ctrl
              testb mk_eacache,#0 wc ' odd address??
        if_c  ret wcz
              and mk_memvalue,#1
              debug("Z80 control: ",uhex_long(mk_eacache,mk_virtualpc),udec(mk_memvalue))
              testb mk_eacache,#8 wc ' Is bus request?
        if_c  wrbyte mk_memvalue,#zbus_request
        if_c  ret wcz
        'if_c bitnot mk_memvalue,#0 ' hack: no Z80, so update status accordingly
        'if_c wrbyte mk_memvalue,#zbus_status
              testb mk_eacache,#9 wc ' Is Z80 reset? TODO
        if_c  bitnot mk_memvalue,#0
        if_c  wrbyte mk_memvalue,#z80_reset
        if_c  ret wcz
              ' if neither bus request or reset register, it is the DRAM refresh register (don't care)
              ret wcz

iog_read16
              'debug("in iog_read16 ",uhex_long(mk_eacache))
              testb mk_eacache,#16 wc
        if_nc jmp #zbus_read16
              mov mk_memvalue,#0
              testb mk_eacache,#12 wc
        if_c  call #iog_z80_poll
        if_c  shl mk_memvalue,#8
        if_c  ret wcz
              add mk_eacache,#1
              call #iog_read8
              sub mk_eacache,#1
              ret wcz

zbus_read16
              call #zbus_read
        _ret_ movbyts mk_memvalue,#%%2200

zbus_read
              debug("Z80 Bus read! ",uhex_long_(mk_eacache),uhex_long_(mk_virtualpc),uhex_byte_array_(#@zbus_status,#1))

              mov pa,mk_eacache
              zerox pa,#14 ' 68000 access is always to lower 32k, I think?
              testb pa,#14 wc
        if_nc jmp #.zram_read

              cmp pa,##$6000 wc
        if_b  jmp #opn_statusread
              cmp pa,##$7F00 wc
        if_b  ret wcz ' Unused area / bank register
              ' VDP through Z bus... I think V count might need to be present here?
              mov mk_memvalue,#0 ' TODO
              ret wcz

.zram_read
              zerox pa,#12 ' RAM is 8K
              add pa,##@z80_ram
              rdbyte mk_memvalue,pa
              ret wcz


iog_read8
              ' everything is 8 bit, so we only really care about that
              testb mk_eacache,#16 wc
        if_nc jmp #zbus_read
              mov mk_memvalue,#0
              testb mk_eacache,#12 wc
        if_c  jmp #iog_z80_poll
              mov mk_memtmp0,mk_eacache
              shr mk_memtmp0,#1 wc
        if_nc ret wcz ' LSB always reads zero?
              ' Okay, got genuine register read
              getnib pa,mk_memtmp0,#0
              fle pa,#7
              mul pa,#4
              jmprel pa
.iog_regrd_base
              orgh .iog_regrd_base + 0*4*4 ' version  ($A10001)
              rdbyte mk_memvalue,#machine_version
              ret wcz
              orgh .iog_regrd_base + 1*4*4 ' player 1 controller data ($A10003)
              jmp #io_pl1_padread
              orgh .iog_regrd_base + 2*4*4 ' player 2 controller data ($A10005)
              jmp #io_pl2_padread
              orgh .iog_regrd_base + 3*4*4 ' modem data ($A10007)
              mov mk_memvalue,#0
              ret wcz
              orgh .iog_regrd_base + 4*4*4 ' player 1 direction ($A10009)
              rdbyte mk_memvalue,#io_pl1_dir
              ret wcz
              orgh .iog_regrd_base + 5*4*4 ' player 2 direction ($A1000B)
              rdbyte mk_memvalue,#io_pl2_dir
              ret wcz
              orgh .iog_regrd_base + 6*4*4 ' modem direction ($A1000D)
              mov mk_memvalue,#0
              ret wcz
              orgh .iog_regrd_base + 7*4*4 ' ???? don't care ($A1000F)
              mov mk_memvalue,#0
              ret wcz


io_pl1_padread
              pollct1 wc ' if timer elapsed, reset controller state machine
        if_c  wrbyte #0,#io_pl1_state

              rdword mk_memtmp0,#io_pl1_dir ' out state in top byte
              mov mk_memvalue,#$7F
              rdbyte mk_memtmp3,#io_pl1_type wz
        if_z  jmp #.done ' No controller: all pins pulled up
              rdbyte mk_memtmp2,#io_pl1_state
              cmp mk_memtmp3,#PAD_6BUTTON wz
        if_z  cmp mk_memtmp2,#3 wz ' Z set -> read 6btn data
              testb mk_memtmp0,#6+8 wc ' TH out bit
              testbn mk_memtmp0,#6 orc ' if TH dir bit not set, pull up

              rdword mk_memvalue,#io_pl1_padw
              mov mk_memtmp1,mk_memvalue
              'debug("padrd ",uhex_word_(mk_memtmp0,mk_memvalue),uhex_byte_(mk_memtmp2,mk_memtmp3))

        if_0x or mk_memvalue,#%1100
        if_01 or mk_memvalue,#%1111
        if_0x shr mk_memtmp1,#2
        if_11 shr mk_memtmp1,#8
        if_0x setq #%11_0000
        if_11 setq #%00_1111
        if_not_10 muxq mk_memvalue,mk_memtmp1
        ' Needed to fix SGDK games
              cmp mk_memtmp3,#PAD_6BUTTON wz
        if_z  cmp mk_memtmp2,#0 wz
        if_01 andn mk_memvalue,#%1111

              and mk_memvalue,#$7F
              xor mk_memvalue,#$7F
.done
              ' Force output pins to fixed state
              getbyte pa,mk_memtmp0,#1
              and mk_memtmp0,#127
              setq mk_memtmp0
              muxq mk_memvalue,pa
              'debug("padv ",uhex_byte_(mk_memvalue))
              ret wcz


io_pl2_padread
              pollct2 wc ' if timer elapsed, reset controller state machine
        if_c  wrbyte #0,#io_pl2_state

              rdword mk_memtmp0,#io_pl2_dir ' out state in top byte
              mov mk_memvalue,#$7F
              rdbyte mk_memtmp3,#io_pl2_type wz
        if_z  jmp #.done ' No controller: all pins pulled up
              rdbyte mk_memtmp2,#io_pl2_state
              cmp mk_memtmp3,#PAD_6BUTTON wz
        if_z  cmp mk_memtmp2,#3 wz ' Z set -> read 6btn data
              testb mk_memtmp0,#6+8 wc ' TH out bit
              testbn mk_memtmp0,#6 orc ' if TH dir bit not set, pull up

              rdword mk_memvalue,#io_pl2_padw
              mov mk_memtmp1,mk_memvalue

        if_0x or mk_memvalue,#%1100
        if_01 or mk_memvalue,#%1111
        if_0x shr mk_memtmp1,#2
        if_11 shr mk_memtmp1,#8
        if_0x setq #%11_0000
        if_11 setq #%00_1111
        if_not_10 muxq mk_memvalue,mk_memtmp1
        ' Needed to fix SGDK games
              cmp mk_memtmp3,#PAD_6BUTTON wz
        if_z  cmp mk_memtmp2,#0 wz
        if_01 andn mk_memvalue,#%1111

              and mk_memvalue,#$7F
              xor mk_memvalue,#$7F
.done
              ' Force output pins to fixed state
              getbyte pa,mk_memtmp0,#1
              and mk_memtmp0,#127
              setq mk_memtmp0
              muxq mk_memvalue,pa
              ret wcz


iog_z80_poll
              testb mk_eacache,#0 wc ' odd address??
        if_c  ret wcz
              rdbyte mk_memvalue,#zbus_status
              and mk_memvalue,#1
              ret wcz

DAT ' SRAM handlers

sram_set_bank ' $A130F1 handler
              'drvh #38
              and mk_memvalue,#%11
              wrbyte mk_memvalue,#sram_bankreg
              ' Handle banking
              cmps mk_sram_begin,#0 wc
        if_nc testbn mk_memvalue,#0 wc
        if_nc mov mk_rom_stop,mk_sram_begin
        if_nc bitl mk_rom_stop,#0 ' force word alignment
        if_c  decod mk_rom_stop,#encod $00_80_0000 ' Without MegaCD, $400000..$7FFFFF is a ROM mirror
              ret wcz


sram_write16
              'drvh #39
              rdbyte pa,#sram_bankreg
              testb pa,#1 wc
        if_c  ret wcz ' SRAM locked
              loc pa,#save_ram
              add pa,mk_eacache
              sub pa,mk_sram_begin
              '' upper code guarantees that SRAM range isn't too large for buffer
              movbyts mk_memvalue,#%%2301
              wrword mk_memvalue,pa

              getct pa
              or pa,#1
              wrlong pa,#sram_write_tstamp
              ret wcz

sram_write8
              'drvh #39
              rdbyte pa,#sram_bankreg
              testb pa,#1 wc
        if_c  ret wcz ' SRAM locked
              loc pa,#save_ram
              add pa,mk_eacache
              sub pa,mk_sram_begin
              '' upper code guarantees that SRAM range isn't too large for buffer
              wrbyte mk_memvalue,pa

              getct pa
              or pa,#1
              wrlong pa,#sram_write_tstamp
              ret wcz

sram_read16
              loc pa,#save_ram
              add pa,mk_eacache
              sub pa,mk_sram_begin
              rdword mk_memvalue,pa
              movbyts mk_memvalue,#%%2301
              ret wcz

sram_read8
              loc pa,#save_ram
              add pa,mk_eacache
              sub pa,mk_sram_begin
              rdbyte mk_memvalue,pa
              ret wcz




CON ' MegaVDP constants


VDPFLAG_VINT = 9
VDPFLAG_HINT = 8

VDPFLAG_WINDOWN = 7
VDPFLAG_WINRIGHT = 6

VDPFLAG_BLANK = 4
VDPFLAG_SHADHL = 3
VDPFLAG_LACED_DOUBLERES = 2 ' Vertical double res mode
VDPFLAG_LACED_OUTPUT = 1 ' Interlace output (see MegaVGA)
VDPFLAG_H40 = 0

RENDERBUFFER_SIZE = 336*3+(4*2)
RENDERBUFFER_PLANEB = 4*2
RENDERBUFFER_PLANEA = 336*1 + 4*2
RENDERBUFFER_SPRITES = 336*2 + 4*2

OUTBUFFER_WIDTH = 320

DAT ' MegaVDP index renderer
org
vdpr_tmp1               res 1
vdpr_tmp2               res 1
vdpr_tmp3               res 1
vdpr_tmp4               res 1

org
vdpr_entry
              add ptrb,##@vdpr_lutcode-@vdpr_entry
              setq2 #511
              rdlong 512-512,ptrb
              jmp #vdpr_prepareFrame
vdpr_linelp
.linewait
              rdlong vdpr_tmp1,#video_line_ctr
              cmp vdpr_tmp1,vdpr_curline wz
        if_e  jmp #.linewait
              mov vdpr_curline,vdpr_tmp1
              getct vdpr_tmp1
              wrlong vdpr_tmp1,#vdp_linestartct_l
              rdlong vdpr_curframe,#video_frame_ctr
              'debug(sdec(vdpr_curline))

              cmps vdpr_curline,##-1 wc
        if_b  jmp #vdpr_linelp
              cmps vdpr_curline,#224 wcz
        if_z  jmp #vdpr_line224
        if_ae jmp #vdpr_linelp


              ' Reload registers
              setq #vdpr_registers_end-vdpr_forceSPRreload-1
              rdlong vdpr_forceSPRreload,vdpr_registerptr

              sub vdpr_hint_ctr,#1 wc
        if_c  rdbyte vdpr_hint_ctr,#vdp_hint_interval_b
              testb vdpr_flags,#VDPFLAG_HINT andc
        if_c  locktry #HINT_LOCK
              lockrel #HINT_LOCK

              tjs vdpr_curline,#vdpr_prepareFrame
              tjnz vdpr_forceSPRreload,vdpr_doSPRreload_ptr

vdpr_doRender
              mov vdpr_renderbuffer_curline,vdpr_renderbuffer
              testb vdpr_curline,#0 wc
        if_c  add vdpr_renderbuffer_curline,##RENDERBUFFER_SIZE

              ' Set current effective line (prog vs. lace)
              mov vdpr_effline,vdpr_curline
              testb vdpr_flags,#VDPFLAG_LACED_DOUBLERES wz
              testb vdpr_curframe,#0 wc
        if_z  rcl vdpr_effline,#1

              ' Refresh VSRAM
              setq #19
              rdlong vdpr_vsram_buffer,vdpr_vsramptr

              ' Plane A / Window split handling...
              cmp vdpr_curline,vdpr_windowRow wc
              testb vdpr_flags,#VDPFLAG_WINDOWN xorc
              testb vdpr_flags,#VDPFLAG_WINRIGHT wz
        if_c  mov vdpr_windowColumnsNow,vdpr_screenwidth
        if_nc mov vdpr_windowColumnsNow,vdpr_windowColumn
        if_nc_and_z subr vdpr_windowColumnsNow,#40


              ' H Scroll handling
              mov  vdpr_tmp1,vdpr_curline
              test vdpr_HScrollMode,#3 wcz ' Z = whole screen, NZ_AND_C = per 8px, NZ_AND_NC = per line
        if_z  mov  vdpr_tmp1,#0
 if_nz_and_c  andn vdpr_tmp1,#7 ' Truncate for 8px
              shl  vdpr_tmp1,#2 ' Entries are long
              add  vdpr_tmp1,vdpr_HScrollbase
              add  vdpr_tmp1,vdpr_vramptr
              rdlong vdpr_current_hscroll,vdpr_tmp1
              'setword vdpr_current_hscroll,vdpr_curframe,#1 ''DEBUG!
              bmask vdpr_hscroll_mask,vdpr_planewidth
              shr vdpr_hscroll_mask,#2
              shl vdpr_hscroll_mask,#1



              mov ptra,vdpr_renderbuffer_curline

              ' write metadata into render buffer
              mov  vdpr_tmp1,vdpr_bgcolor
              mov  vdpr_tmp2,vdpr_flags
              setq #2-1
              wrlong vdpr_tmp1,ptra++

              testb vdpr_flags,#VDPFLAG_BLANK wc
        if_c  setq #(RENDERBUFFER_SIZE - 4*2)/4 - 1
        if_c  wrlong #0,ptra++
        if_c  jmp #vdpr_doSPRreload ' force sprite table reload on blank lines. Makes Sonic2 multiplayer work.

              add ptra,#8 ' skip over scratch area

              ' Render Plane B (Background)
              mov vdpr_tileiter,vdpr_screenwidth


              ' Tile base address
              getword vdpr_tileptr,vdpr_current_hscroll,#1
              signx vdpr_tileptr,#15
              'add vdpr_tileptr,vdpr_curframe 'DEBUG!
              neg vdpr_tileptr
              mov vdpr_tmp1,vdpr_tileptr
              sar vdpr_tileptr,#3-1
              and vdpr_tileptr,vdpr_hscroll_mask
              add vdpr_tileptr,vdpr_planeBbase

              and vdpr_tmp1,#7 wz
              sub ptra,vdpr_tmp1
        if_nz add vdpr_tileiter,#1

              mov vdpr_vscroll_getter,vdpr_vscroll_getter_planeB
              ' Set vscroll for partial column
              testbn vdpr_tileptr,#1 andz
              testbn vdpr_columnscroll,#0 orz
              testb  vdpr_flags,#VDPFLAG_H40 wc
        if_x1 getword vdpr_current_vscroll,vdpr_vsram_buffer+0,#1
        if_x1 add vdpr_vscroll_getter,vdpr_columnscroll
        if_10 getword vdpr_current_vscroll,vdpr_vsram_buffer+19,#1
        if_10 and     vdpr_current_vscroll,vdpr_vsram_buffer+19
        if_00 mov     vdpr_current_vscroll,#0


              decod vdpr_hscroll_sub,vdpr_planewidth

              call  #vdpr_renderPlane





              ' Render Plane A / window
              testb vdpr_flags,#VDPFLAG_WINRIGHT wc
        if_nc call #vdpr_renderWindow
              call #vdpr_renderPlaneA
              testb vdpr_flags,#VDPFLAG_WINRIGHT wc
        if_c  call #vdpr_renderWindow



              mov ptra,vdpr_renderbuffer_curline
              add ptra,##RENDERBUFFER_SPRITES+8


              ' Oh no, sprite time?
              '---------------------

              ' Scan for sprites we want and put them in a buffer
              ' This is neccessary, yes
              neg vdpr_sprScanIdx,vdpr_screenwidth
              shl vdpr_sprScanIdx,#1
              sub vdpr_sprScanIdx,#1
              neg vdpr_lsprEntryFirst,vdpr_screenwidth
              sar vdpr_lsprEntryFirst,#1
              altd vdpr_lsprEntryFirst,#vdpr_lspr_ids_end - 1
              neg 0-0,#511

              mov vdpr_lsprEntry,vdpr_lsprEntryFirst
              mov vdpr_sprTilesLeft,vdpr_screenwidth
              sub vdpr_sprTilesLeft,#1
              mov vdpr_tmp4,#0 ' Used to keep track of wether we found a non-mask sprite

.sprscanlp
              ijz vdpr_sprScanIdx,#.scandone
              alts vdpr_sprScanIdx,#vdpr_sprc_vpos_end
              mov vdpr_sprline,0-0 ' get VPOS
              altgb vdpr_sprScanIdx,#vdpr_sprc_vsize_end
              getbyte vdpr_sprVsize

              subr vdpr_sprline,vdpr_effline
              'debug(sdec(vdpr_sprScanIdx,vdpr_sprline,vdpr_sprVsize))
              cmp vdpr_sprline,vdpr_sprVsize wc
        if_ae jmp #.sprscanlp
              'debug("Got it ",sdec(vdpr_lsprEntry))
              ' Got one in range!!
              altd vdpr_lsprEntry,#vdpr_lspr_ids_end
              mov 0-0,vdpr_sprScanIdx
              altd vdpr_lsprEntry,#vdpr_lspr_vline_end
              mov 0-0,vdpr_sprline

              ' Handle tile limit
              altgb vdpr_sprScanIdx,#vdpr_sprc_hsize_end
              getbyte vdpr_tmp2
              sub vdpr_sprTilesLeft,vdpr_tmp2

              altgb vdpr_sprScanIdx,#vdpr_sprc_id_end
              getbyte vdpr_tmp2

              ' get rest of sprite data from VRAM
              shl vdpr_tmp2,#3
              add vdpr_tmp2,vdpr_spritebase
              add vdpr_tmp2,vdpr_vramptr
              add vdpr_tmp2,#4
              rdlong vdpr_tmp2,vdpr_tmp2
              altd vdpr_lsprEntry,#vdpr_lspr_long2_end
              mov 0-0,vdpr_tmp2

              ' Handle masking nonsense (if X=0 and not first sprite)
              test vdpr_tmp2,vdpr_maskingtest wz
              modc _nz wc
              subsx vdpr_tmp4,#0 wc ' C set if non-mask sprite found

  if_nz_or_nc ijnz vdpr_lsprEntry,#.sprscanlp
.scandone_uhhh
  if_z_and_c  add vdpr_lsprEntry,#1
.scandone

              jmp #vdpr_doSpriteDraw



vdpr_line224
              ' Do Vertical interrupt and stuff
              testb vdpr_flags,#VDPFLAG_VINT wc
         if_c locktry #VINT_LOCK wc
              locktry #ZINT_LOCK
        'if_c  drvnot #39 ' LED DEBUG
              lockrel #VINT_LOCK
              lockrel #ZINT_LOCK
              jmp #vdpr_linelp


vdpr_prepareFrame
              ' Line -1: prepare frame

              'debug("Prepare frame! ",udec(vdpr_curframe))
              testb vdpr_flags,#VDPFLAG_H40 wc
        if_c  mov vdpr_screenwidth,#40
        if_nc mov vdpr_screenwidth,#32
              mov vdpr_screenwidth_pixels,vdpr_screenwidth
              shl vdpr_screenwidth_pixels,#3

              ' Set up interlace or progressive
              testb vdpr_flags,#VDPFLAG_LACED_DOUBLERES wz
        if_z  mov vdpr_tileline_mask,#%1111_00
        if_nz mov vdpr_tileline_mask,#%0111_00
        if_z  mov vdpr_lace3or4,#4
        if_nz mov vdpr_lace3or4,#3
        if_z  mov vdpr_lace5or6,#6
        if_nz mov vdpr_lace5or6,#5
        if_z  mov vdpr_lace8or9,#9
        if_nz mov vdpr_lace8or9,#8
        if_z  mov vdpr_lace128or256,#256
        if_nz mov vdpr_lace128or256,#128

              ' Reset H-int counter
              rdbyte vdpr_hint_ctr,#vdp_hint_interval_b

              jmp vdpr_doSPRreload_ptr
              ' always reload sprites ( DROP THROUGH!)

vdpr_doSPRreload_ptr long vdpr_doSPRreload ' lol

vdpr_renderPlane
              wrfast vdpr_con_bit31,ptra
              skipf #%111 ' First tile always has buggy VSCROLL
vdpr_renderPlane_loop
              testb vdpr_tileptr,#1 wc
vdpr_vscroll_getter
        if_nc mov 0-0,0-0 ' replaced by different instruction per plane
        if_nc add vdpr_vscroll_getter,vdpr_columnScroll ' inc S of getter by 1 if column scroll mode

              mov  vdpr_tmp1,vdpr_effline
              add  vdpr_tmp1,vdpr_current_vscroll

              mov vdpr_tileline_offset,vdpr_tmp1
              shl vdpr_tileline_offset,#2
              and vdpr_tileline_offset,vdpr_tileline_mask


              shr  vdpr_tmp1,vdpr_lace3or4
              zerox vdpr_tmp1,vdpr_planeheight
              shl  vdpr_tmp1,vdpr_planewidth
              add  vdpr_tmp1,vdpr_tileptr
              add  vdpr_tmp1,vdpr_vramptr
              rdword vdpr_tile,vdpr_tmp1

              add  vdpr_tileptr,#2
              test vdpr_tileptr,vdpr_hscroll_mask wz
        if_z  sub  vdpr_tileptr,vdpr_hscroll_sub

              testb vdpr_tile,#12 wc ' flip bit
              mov vdpr_tmp4,vdpr_tile
              shl vdpr_tmp4,vdpr_lace5or6
              zerox vdpr_tmp4,#15
              add vdpr_tmp4,vdpr_tileline_offset
        if_c  xor vdpr_tmp4,vdpr_tileline_mask'#7<<2
              add vdpr_tmp4,vdpr_vramptr ' Tile data address!
              rdlong vdpr_tiledata,vdpr_tmp4

              ' rogloh's optimized variant...

              ' Prepare attributes
              mov vdpr_tmp1, vdpr_tile
              shr vdpr_tmp1, #13 ' Just pal+priority
              shl vdpr_tmp1, #4
              movbyts vdpr_tmp1, #%%0000

              testb vdpr_tile, #11 wc ' mirror bit
    if_nc     splitb vdpr_tiledata ' reverse nibbles in tile
    if_nc     rev vdpr_tiledata
    if_nc     movbyts vdpr_tiledata, #%%0123
    if_nc     mergeb vdpr_tiledata

              ' bit magic (space out nybbles)
              getword vdpr_tilebuffer1, vdpr_tiledata, #1    ' first group
              movbyts vdpr_tilebuffer1, #%%3120
              mergew vdpr_tilebuffer1
              movbyts vdpr_tilebuffer1, #%%3120
              splitw vdpr_tilebuffer1
              getword vdpr_tilebuffer2, vdpr_tiledata, #0    ' second group
              movbyts vdpr_tilebuffer2, #%%3120
              mergew vdpr_tilebuffer2
              movbyts vdpr_tilebuffer2, #%%3120
              splitw vdpr_tilebuffer2

              or vdpr_tilebuffer1,vdpr_tmp1
              or vdpr_tilebuffer2,vdpr_tmp1

              'setq #1
              'wrlong vdpr_tilebuffer1,ptra++
              wflong vdpr_tilebuffer1
              wflong vdpr_tilebuffer2
        _ret_ djnz vdpr_tileiter,#vdpr_renderPlane_loop



'hnormal_skipf long %100_100_100_100_100_100_100_100_1
'hmirror_skipf long %010_010_010_010_010_010_010_010

vdpr_vscroll_getter_planeA if_nc getword vdpr_current_vscroll,vdpr_vsram_buffer,#0
vdpr_vscroll_getter_planeB if_nc getword vdpr_current_vscroll,vdpr_vsram_buffer,#1
vdpr_vscroll_getter_window if_always and vdpr_current_vscroll,#0

vdpr_pixnibtest       long 15<<0,15<<8,15<<16,15<<24

vdpr_maskingtest      long $01FF_0000

vdpr_curline            long 0
vdpr_curframe           long 0

vdpr_spr_leftedge long -7

vdpr_con_minus1  long -1
vdpr_con_bit31   long 1<<31

vdpr_renderbuffer       long @renderbuffer_loc
vdpr_vramptr            long @vdp_ram
vdpr_vsramptr           long @vdp_cram + $120
vdpr_registerptr        long @vdp_registers



vdpr_vsram_buffer       long 0[20] ' VSRAM buffer


'' VDP registers in order as loaded from RAM
vdpr_forceSPRreload     res 1 ' Fake register to force VDP sprite cache reload
vdpr_flags              res 1
vdpr_planeAbase         res 1
vdpr_planeBbase         res 1
vdpr_windowbase         res 1
vdpr_spritebase         res 1
vdpr_HScrollbase        res 1
vdpr_planewidth         res 1 ' basically what to shl the line count with (1+6 -> 64)
vdpr_planeheight        res 1 ' basically what to zerox the thing with (4->32)
vdpr_columnScroll       res 1 ' 1 or 0
vdpr_HScrollMode        res 1  ' 0 or 2 or 3 (1 is invalid in HW, too)
vdpr_windowColumn       res 1
vdpr_windowRow          res 1 ' pre-chewed to pixels
vdpr_bgcolor            res 1
vdpr_registers_end

vdpr_screenwidth        res 1 ' 40 or 32
vdpr_screenwidth_pixels res 1 ' just vdpr_screenwidth * 8
vdpr_hscroll_mask       res 1 ' H scroll address mask
vdpr_hscroll_sub        res 1 ' Byte size of one plane row
vdpr_renderbuffer_curline res 1

vdpr_hint_ctr           res 1

vdpr_effline            res 1
vdpr_tileline_mask      res 1
vdpr_lace3or4           res 1
vdpr_lace5or6           res 1
vdpr_lace8or9           res 1
vdpr_lace128or256       res 1

vdpr_tileiter           res 1
vdpr_tile               res 1
vdpr_tileptr            res 1
vdpr_tileline_offset    res 1
vdpr_current_vscroll    res 1 ' for current plane/column
vdpr_current_hscroll    res 1 ' for current line
vdpr_windowColumnsNow   res 1

vdpr_sprScanIdx         res 1
'vdpr_sprScanMax         res 1
vdpr_lsprEntry          res 1
vdpr_lsprEntryFirst     res 1
vdpr_sprTilesLeft       res 1
vdpr_sprline            res 1
vdpr_sprVsize           res 1
vdpr_sprHsize           res 1
vdpr_sprHpos            res 1

vdpr_tiledata           res 1
vdpr_tilebuffer1        res 1
vdpr_tilebuffer2        res 1


vdpr_sprc_vpos          res 80 ' sprite VPOS cache (longs)
vdpr_sprc_vpos_end
vdpr_sprc_vsize         res 80/4 ' sprite VSIZE cache (bytes)
vdpr_sprc_vsize_end
vdpr_sprc_hsize         res 80/4 ' sprite HSIZE cache (bytes)
vdpr_sprc_hsize_end
vdpr_sprc_id            res 80/4 ' sprite ID cache (bytes)
vdpr_sprc_id_end


                        res 1 ' buffer because lol
vdpr_lspr_ids           res 20 ' sprite IDs for this line
vdpr_lspr_ids_end
vdpr_lspr_long2         res 20
vdpr_lspr_long2_end
vdpr_lspr_vline         res 20
vdpr_lspr_vline_end



                        fit 496
org $200
vdpr_lutcode

vdpr_doSPRreload
              mov vdpr_forceSPRreload,#0
              wrlong #0,vdpr_registerptr

              mov vdpr_tmp4,#0 ' link ID
              mov vdpr_tmp3,vdpr_screenwidth
              shl vdpr_tmp3,#1 ' Sprite list limit
              testb vdpr_flags,#VDPFLAG_H40 wc
        if_c  mov vdpr_sprScanIdx,#0 ' cache ID (H40)
        if_nc mov vdpr_sprScanIdx,#16 ' cache ID (H32)

.sprcachelp
              mov ptra,vdpr_tmp4
              shl ptra,#3 ' entries are 8 byte each
              add ptra,vdpr_spritebase
              add ptra,vdpr_vramptr

              ' We only cache the first 2 words (like HW)
              rdlong vdpr_tmp1,ptra

              mov vdpr_tmp2,vdpr_tmp1
              zerox vdpr_tmp2 ,vdpr_lace8or9 ' get YPOS (mask with $3FF)
              altr vdpr_sprScanIdx,#vdpr_sprc_vpos
              subs vdpr_tmp2,vdpr_lace128or256 ' Bring into screen space and store

              altsb vdpr_sprScanIdx,#vdpr_sprc_id
              setbyte vdpr_tmp4 ' Store this sprite's ID

              getbyte vdpr_tmp4,vdpr_tmp1,#2 ' Get Link
              and vdpr_tmp4,#$7F
              cmp vdpr_tmp4,vdpr_tmp3 wcz
        if_ae mov vdpr_tmp4,#0 ' Out of bounds sprite ID is same as zero

              ' Handle sizes
              getnib vdpr_tmp2,vdpr_tmp1,#6
              and vdpr_tmp2,#3
              add vdpr_tmp2,#1
              shl vdpr_tmp2,vdpr_lace3or4 ' store in pixels to help scan code later
              altsb vdpr_sprScanIdx,#vdpr_sprc_vsize
              setbyte vdpr_tmp2

              getnib vdpr_tmp2,vdpr_tmp1,#6
              shr vdpr_tmp2,#2
              add vdpr_tmp2,#1
              altsb vdpr_sprScanIdx,#vdpr_sprc_hsize
              setbyte vdpr_tmp2


              incmod vdpr_sprScanIdx,#80-1 wc ' Inc cache ID
        if_nc tjnz vdpr_tmp4,#.sprcachelp ' Loop if space left and not end of list

        if_c  jmp #vdpr_linelp ' All sprite slots filled!

              ' If not, fill remaining slots with Y=0
.sprunusedlp
              altd vdpr_sprScanIdx,#vdpr_sprc_vpos
              mov 0-0,#0
              altsb vdpr_sprScanIdx,#vdpr_sprc_vsize
              setbyte #0
              incmod vdpr_sprScanIdx,#80-1 wc ' Inc cache ID
        if_nc jmp #.sprunusedlp

              jmp #vdpr_linelp




vdpr_renderWindow
              ' Render Plane A, but as Window


              mov ptra,vdpr_renderbuffer_curline
              add ptra,##RENDERBUFFER_PLANEA+8

              mov vdpr_tileiter,vdpr_windowColumnsNow wcz
        if_be ret

              mov vdpr_vscroll_getter,vdpr_vscroll_getter_window
              and vdpr_current_vscroll,#0

              ' Tile base address
              mov vdpr_tileptr,vdpr_windowbase
              testb vdpr_flags,#VDPFLAG_H40 wc
        if_nc mov  vdpr_planewidth,#6 ' H32
        if_c  mov  vdpr_planewidth,#7 ' H40

              ' Handle window split nonsense
              mov vdpr_tmp2,vdpr_screenwidth
              sub vdpr_tmp2,vdpr_windowColumnsNow
              shl vdpr_tmp2,#1
              testb vdpr_flags,#VDPFLAG_WINRIGHT wc
        if_c  add vdpr_tileptr,vdpr_tmp2
              shl vdpr_tmp2,#3-1
        if_c  add ptra,vdpr_tmp2

              mov vdpr_hscroll_sub,#0 ' no wrapping (relevant when plane width is 32 tiles in H40 mode)

              jmp  #vdpr_renderPlane ' tail call


vdpr_renderPlaneA
              ' Render Plane A (Foreground)


              mov ptra,vdpr_renderbuffer_curline
              add ptra,##RENDERBUFFER_PLANEA+8

              mov vdpr_tileiter,vdpr_screenwidth
              subs vdpr_tileiter,vdpr_windowColumnsNow wcz
        if_z_or_c ret




              ' Tile base address
              getword vdpr_tileptr,vdpr_current_hscroll,#0
              signx vdpr_tileptr,#15
              neg vdpr_tileptr
              mov vdpr_tmp1,vdpr_tileptr
              sar vdpr_tileptr,#3-1

              ' Handle window split nonsense
              mov vdpr_tmp2,vdpr_windowColumnsNow
              shl vdpr_tmp2,#1
              testb vdpr_flags,#VDPFLAG_WINRIGHT wc
        if_nc add vdpr_tileptr,vdpr_tmp2
              shl vdpr_tmp2,#3-1
        if_nc add ptra,vdpr_tmp2

              and vdpr_tileptr,vdpr_hscroll_mask
              add vdpr_tileptr,vdpr_planeAbase

              and vdpr_tmp1,#7 wz
              sub ptra,vdpr_tmp1
        if_nz add vdpr_tileiter,#1

              mov vdpr_vscroll_getter,vdpr_vscroll_getter_planeA
              ' Set vscroll for partial column
              testbn vdpr_tileptr,#1 andz
              testbn vdpr_columnscroll,#0 orz
              testb  vdpr_flags,#VDPFLAG_H40 wc
        if_x1 getword vdpr_current_vscroll,vdpr_vsram_buffer+0,#0
        if_x1 add vdpr_vscroll_getter,vdpr_columnscroll
        if_10 getword vdpr_current_vscroll,vdpr_vsram_buffer+19,#1
        if_10 and     vdpr_current_vscroll,vdpr_vsram_buffer+19
        if_00 mov     vdpr_current_vscroll,#0

              decod vdpr_hscroll_sub,vdpr_planewidth

              jmp #vdpr_renderPlane ' tail call


vdpr_doSpriteDraw

              ' clear sprite layer
              setq #(320/4)-1
              wrlong #0,ptra

              ' Actually draw the sprites
.sprdrawlp
              sub vdpr_lsprEntry,#1
              alts vdpr_lsprEntry,#vdpr_lspr_ids_end
              mov vdpr_sprScanIdx,0-0
              add vdpr_sprScanIdx,#80
              tjs vdpr_sprScanIdx,#vdpr_spritesDone

              'wrlong ##$FF_FF_FF_FF,ptra

              ' get rest of sprite data
              altgb vdpr_sprScanIdx,#vdpr_sprc_vsize
              getbyte vdpr_sprVsize
              alts vdpr_lsprEntry,#vdpr_lspr_long2_end
              getword vdpr_tile,0-0,#0
              alts vdpr_lsprEntry,#vdpr_lspr_long2_end
              getword vdpr_sprHpos,0-0,#1
              zerox vdpr_sprHpos,#8 ' mask to $1FF
              subs vdpr_sprHpos,#128 ' bring into screen space

              altgb vdpr_sprScanIdx,#vdpr_sprc_hsize
              getbyte vdpr_sprHsize  ' get H size (used as loop counter)

              ' We draw from right to left, for some reason
              mov vdpr_tmp1,vdpr_sprHsize
              shl vdpr_tmp1,#3
              add vdpr_sprHpos,vdpr_tmp1


              ' Prepare tile address
              mov vdpr_tmp4,vdpr_tile
              zerox vdpr_tmp4,#10
              shl vdpr_tmp4,vdpr_lace3or4'#3
              testb vdpr_tile,#12 wc ' flip bit
        if_c  add vdpr_tmp4,vdpr_sprVsize
        if_c  sub vdpr_tmp4,#1
              alts vdpr_lsprEntry,#vdpr_lspr_vline_end
              sumc vdpr_tmp4,0-0
              shl vdpr_tmp4,#2
              add vdpr_tmp4,vdpr_vramptr ' Tile data address!

              shl vdpr_sprVsize,#2 ' shift up V size so it becomes VRAM distance between columns

              ' Handle mirror
              testb vdpr_tile,#11 wc ' mirror bit
              mov vdpr_tmp1,vdpr_sprHsize
              sub vdpr_tmp1,#1
              mul vdpr_tmp1,vdpr_sprVsize
        if_nc adds vdpr_tmp4,vdpr_tmp1
        if_nc neg vdpr_sprVsize


.sprtilelp
              sub vdpr_sprHpos,#8
              ' Handle tile limit
              adds vdpr_sprTilesLeft,#1 wc
              ' In range?
        if_nc cmps vdpr_sprHpos,vdpr_spr_leftedge wc
        if_nc cmps vdpr_screenwidth_pixels,vdpr_sprHpos wc
        if_c  jmp #.skiptile


              rdlong vdpr_tiledata,vdpr_tmp4

              ' rogloh's optimized variant...

              ' Prepare attributes
              mov vdpr_tmp1, vdpr_tile
              shr vdpr_tmp1, #13 ' Just pal+priority

              testb vdpr_tile, #11 wc ' mirror bit
    if_nc     splitb vdpr_tiledata ' reverse nibbles in tile
    if_nc     rev vdpr_tiledata
    if_nc     movbyts vdpr_tiledata, #%%0123
    if_nc     mergeb vdpr_tiledata

              ' bit magic (space out nybbles)
              getword vdpr_tilebuffer1, vdpr_tiledata, #1    ' first group
              movbyts vdpr_tilebuffer1, #%%3120
              mergew vdpr_tilebuffer1
              movbyts vdpr_tilebuffer1, #%%3120
              splitw vdpr_tilebuffer1
              getword vdpr_tilebuffer2, vdpr_tiledata, #0    ' second group
              movbyts vdpr_tilebuffer2, #%%3120
              mergew vdpr_tilebuffer2
              movbyts vdpr_tilebuffer2, #%%3120
              splitw vdpr_tilebuffer2

              ' add attributes to  non-transparent pixels
              test vdpr_tilebuffer1,vdpr_pixnibtest+0 wz
        if_nz setnib vdpr_tilebuffer1,vdpr_tmp1,#1
              test vdpr_tilebuffer1,vdpr_pixnibtest+1 wz
        if_nz setnib vdpr_tilebuffer1,vdpr_tmp1,#3
              test vdpr_tilebuffer1,vdpr_pixnibtest+2 wz
        if_nz setnib vdpr_tilebuffer1,vdpr_tmp1,#5
              test vdpr_tilebuffer1,vdpr_pixnibtest+3 wz
        if_nz setnib vdpr_tilebuffer1,vdpr_tmp1,#7

              test vdpr_tilebuffer2,vdpr_pixnibtest+0 wz
        if_nz setnib vdpr_tilebuffer2,vdpr_tmp1,#1
              test vdpr_tilebuffer2,vdpr_pixnibtest+1 wz
        if_nz setnib vdpr_tilebuffer2,vdpr_tmp1,#3
              test vdpr_tilebuffer2,vdpr_pixnibtest+2 wz
        if_nz setnib vdpr_tilebuffer2,vdpr_tmp1,#5
              test vdpr_tilebuffer2,vdpr_pixnibtest+3 wz
        if_nz setnib vdpr_tilebuffer2,vdpr_tmp1,#7

              ' Figure out where to draw
              mov vdpr_tmp1,ptra
              add vdpr_tmp1,vdpr_sprHpos

              setq #1
              wmlong vdpr_tilebuffer1,vdpr_tmp1

.skiptile
              add vdpr_tmp4,vdpr_sprVsize ' advance to next column
              djnz vdpr_sprHsize,#.sprtilelp

              jmp #.sprdrawlp

vdpr_spritesDone
              jmp #vdpr_linelp


DAT ' MegaVDP compositor
org
vdpc_entry


vdpc_linelp

.linewait
              rdlong vdpc_tmp1,#video_line_ctr
              sub vdpc_tmp1,#1
              cmp vdpc_tmp1,vdpc_curline wz
        if_e  jmp #.linewait
              mov vdpc_curline,vdpc_tmp1
              cmp vdpc_curline,#224 wc
        if_ae jmp #.linewait
              'debug(udec(vdpc_curline))


              ' Load colors
              setq #(64*3)-1
              rdlong vdpc_colors,vdpc_cramptr

              mov ptra,vdpc_outbuffer
              testb vdpc_curline,#0 wc
        if_c  add ptra,##OUTBUFFER_WIDTH*4

              wrfast #0,ptra

              mov ptra,vdpc_renderbuffer
        if_c  add ptra,##RENDERBUFFER_SIZE

              setq #2-1
              rdlong vdpc_bgcolor,ptra++

              setq2 #(336*3)/4 - 1
              rdlong 0,ptra++

              mov ptrb,#(0+8)/4
              mov ptra,#(336+8)/4
              mov vdpc_ptrs,#(336*2+8)/4

              testb vdpc_flags,#VDPFLAG_SHADHL wc
              muxc vdpc_4prioIdxes_base,vdpc_shadhlbits '$20_20_20_20 for Shad/HL mode, zero for normal

              testb vdpc_flags,#VDPFLAG_H40 wc
        if_c  mov vdpc_iter,#320/4
        if_nc mov vdpc_iter,#256/4
        'if_nc rep #1,#(320-256)/2
        'if_nc wflong #0


              ' Uncomment this and the next one to check that VDPC is still running
              {
              testb vdpc_curline,#1 wc
              negc vdpc_colors+32,#1
              '}
              '' Uncomment to view CRAM
              {
              sub vdpc_iter,#128/4
              setd pa,#vdpc_colors
              rep #4,#64
              alti pa,#%000_100_000
              wflong 0-0
              alti pa,#%000_111_000
              wflong 0-0
              '}
.pixellp

              rdlut vdpc_4pixelsB,ptrb++

              rdlut vdpc_4pixelsA,ptra++

              rdlut vdpc_4pixelsS,vdpc_ptrs
              add vdpc_ptrs,#1

              ' priority bit gathering madness
              mov vdpc_4prioIdxes,vdpc_4prioIdxes_base
              setq vdpc_priobits
              muxq vdpc_4prioIdxes,vdpc_4pixelsB
              shr vdpc_4prioIdxes,#1
              muxq vdpc_4prioIdxes,vdpc_4pixelsA
              shr vdpc_4prioIdxes,#1
              muxq vdpc_4prioIdxes,vdpc_4pixelsS
              shr vdpc_4prioIdxes,#3
              ' Should now have 4 bytes of the form %0000_SABM (Sprite prio, A prio, B prio, mode)

              ' Generate "is 14,30,46,62?" data
              mov vdpc_tmp3,vdpc_4pixelsS
              xor vdpc_tmp3,vdpc_hlcolor

              and vdpc_4pixelsB,vdpc_colorbits
              and vdpc_4pixelsA,vdpc_colorbits
              and vdpc_4pixelsS,vdpc_colorbits


              getbyte vdpc_priorities,vdpc_4prioIdxes,#0
              'mov vdpc_priorities,#%0001
              altd vdpc_priorities,#vdpc_prioskipfs
              skipf 0-0

              mov vdpc_pixelOut,vdpc_bgcolor

              mov vdpc_shadhl,#00 ' Base state shadowed
              mov vdpc_shadhl,#64 ' Base state normal

              test vdpc_4pixelsB,vdpc_pnibs+0 wz ' Low priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#0

              test vdpc_4pixelsA,vdpc_pnibs+0 wz ' Low priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#0

              getbyte vdpc_tmp1,vdpc_4pixelsS,#0 ' Low priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 3E, +1 for 3F
              test vdpc_tmp3,vdpc_pnibs+0 wz
  if_c_and_z  mov vdpc_shadhl,#64
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1


              test vdpc_4pixelsB,vdpc_pnibs+0 wz ' High priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#0
        if_nz mov vdpc_shadhl,#64

              test vdpc_4pixelsA,vdpc_pnibs+0 wz ' High priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#0
        if_nz mov vdpc_shadhl,#64


              getbyte vdpc_tmp1,vdpc_4pixelsS,#0 ' High priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 7E, +1 for 7F
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1
  if_c_and_nz mov vdpc_shadhl,#64

              {
              alts vdpc_pixelOut,#vdpc_colors
              mov vdpc_pixelOut,0-0
              cmps vdpc_shadhl,#0 wcz
        if_nz shr vdpc_pixelOut,#1
        if_nz muxc vdpc_pixelOut,vdpc_halfpix
              wflong vdpc_pixelOut
              }
              fges vdpc_shadhl,#0 ' No need to limit top
              add vdpc_pixelOut,vdpc_shadhl
              altd vdpc_pixelOut,#vdpc_colors
              wflong 0-0



              getbyte vdpc_priorities,vdpc_4prioIdxes,#1
              altd vdpc_priorities,#vdpc_prioskipfs
              skipf 0-0

              mov vdpc_pixelOut,vdpc_bgcolor

              mov vdpc_shadhl,#00 ' Base state shadowed
              mov vdpc_shadhl,#64 ' Base state normal

              test vdpc_4pixelsB,vdpc_pnibs+1 wz ' Low priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#1

              test vdpc_4pixelsA,vdpc_pnibs+1 wz ' Low priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#1

              getbyte vdpc_tmp1,vdpc_4pixelsS,#1 ' Low priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 3E, +1 for 3F
              test vdpc_tmp3,vdpc_pnibs+1 wz
  if_c_and_z  mov vdpc_shadhl,#64
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1


              test vdpc_4pixelsB,vdpc_pnibs+1 wz ' High priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#1
        if_nz mov vdpc_shadhl,#64

              test vdpc_4pixelsA,vdpc_pnibs+1 wz ' High priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#1
        if_nz mov vdpc_shadhl,#64


              getbyte vdpc_tmp1,vdpc_4pixelsS,#1 ' High priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 7E, +1 for 7F
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1
  if_c_and_nz mov vdpc_shadhl,#64

              {
              alts vdpc_pixelOut,#vdpc_colors
              mov vdpc_pixelOut,0-0
              cmps vdpc_shadhl,#0 wcz
        if_nz shr vdpc_pixelOut,#1
        if_nz muxc vdpc_pixelOut,vdpc_halfpix
              wflong vdpc_pixelOut
              }
              fges vdpc_shadhl,#0 ' No need to limit top
              add vdpc_pixelOut,vdpc_shadhl
              altd vdpc_pixelOut,#vdpc_colors
              wflong 0-0



              getbyte vdpc_priorities,vdpc_4prioIdxes,#2
              altd vdpc_priorities,#vdpc_prioskipfs
              skipf 0-0

              mov vdpc_pixelOut,vdpc_bgcolor

              mov vdpc_shadhl,#00 ' Base state shadowed
              mov vdpc_shadhl,#64 ' Base state normal

              test vdpc_4pixelsB,vdpc_pnibs+2 wz ' Low priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#2

              test vdpc_4pixelsA,vdpc_pnibs+2 wz ' Low priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#2

              getbyte vdpc_tmp1,vdpc_4pixelsS,#2 ' Low priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 3E, +1 for 3F
              test vdpc_tmp3,vdpc_pnibs+2 wz
  if_c_and_z  mov vdpc_shadhl,#64
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1


              test vdpc_4pixelsB,vdpc_pnibs+2 wz ' High priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#2
        if_nz mov vdpc_shadhl,#64

              test vdpc_4pixelsA,vdpc_pnibs+2 wz ' High priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#2
        if_nz mov vdpc_shadhl,#64


              getbyte vdpc_tmp1,vdpc_4pixelsS,#2 ' High priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 7E, +1 for 7F
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1
  if_c_and_nz mov vdpc_shadhl,#64

              {
              alts vdpc_pixelOut,#vdpc_colors
              mov vdpc_pixelOut,0-0
              cmps vdpc_shadhl,#0 wcz
        if_nz shr vdpc_pixelOut,#1
        if_nz muxc vdpc_pixelOut,vdpc_halfpix
              wflong vdpc_pixelOut
              }
              fges vdpc_shadhl,#0 ' No need to limit top
              add vdpc_pixelOut,vdpc_shadhl
              altd vdpc_pixelOut,#vdpc_colors
              wflong 0-0




              getbyte vdpc_priorities,vdpc_4prioIdxes,#3
              altd vdpc_priorities,#vdpc_prioskipfs
              skipf 0-0

              mov vdpc_pixelOut,vdpc_bgcolor

              mov vdpc_shadhl,#00 ' Base state shadowed
              mov vdpc_shadhl,#64 ' Base state normal

              test vdpc_4pixelsB,vdpc_pnibs+3 wz ' Low priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#3

              test vdpc_4pixelsA,vdpc_pnibs+3 wz ' Low priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#3

              getbyte vdpc_tmp1,vdpc_4pixelsS,#3 ' Low priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 3E, +1 for 3F
              test vdpc_tmp3,vdpc_pnibs+3 wz
  if_c_and_z  mov vdpc_shadhl,#64
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1


              test vdpc_4pixelsB,vdpc_pnibs+3 wz ' High priority B
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsB,#3
        if_nz mov vdpc_shadhl,#64

              test vdpc_4pixelsA,vdpc_pnibs+3 wz ' High priority A
        if_nz getbyte vdpc_pixelOut,vdpc_4pixelsA,#3
        if_nz mov vdpc_shadhl,#64


              getbyte vdpc_tmp1,vdpc_4pixelsS,#3 ' High priority S
              cmp vdpc_tmp1,#$3E wcz
              modc %1111 wc
        if_nc sumnz vdpc_shadhl,#64 ' -1 for 7E, +1 for 7F
              test vdpc_tmp1,#15 wz
  if_c_and_nz mov vdpc_pixelOut,vdpc_tmp1
  if_c_and_nz mov vdpc_shadhl,#64

              {
              alts vdpc_pixelOut,#vdpc_colors
              mov vdpc_pixelOut,0-0
              cmps vdpc_shadhl,#0 wcz
        if_nz shr vdpc_pixelOut,#1
        if_nz muxc vdpc_pixelOut,vdpc_halfpix
              wflong vdpc_pixelOut
              }
              fges vdpc_shadhl,#0 ' No need to limit top
              add vdpc_pixelOut,vdpc_shadhl
              altd vdpc_pixelOut,#vdpc_colors
              wflong 0-0


              'add vdpc_tmp1,#1
              djnz vdpc_iter,#.pixellp

              testb vdpc_flags,#VDPFLAG_H40 wc
        'if_nc rep #1,#(320-256)/2
        if_nc rep #1,#(320-256)/1
        if_nc wflong #0


              jmp #vdpc_linelp

vdpc_prioskipfs long

              ''    SH      AH  BH   SL       AL BL nd BG
              ''        ns                ns
              long %1111111_111_111__00000010_00_00_01_0 ' SL AL BL normal
              long %1111111_111_111__00000100_00_00_10_0 ' SL AL BL shad/hl
              long %1111111_111_000__00000010_00_11_01_0 ' SL AL BH normal
              long %1111111_111_000__00000100_00_11_01_0 ' SL AL BH shad/hl

              long %1111111_000_111__00000010_11_00_01_0 ' SL AH BL normal
              long %1111111_000_111__00000100_11_00_01_0 ' SL AH BL shad/hl
              long %1111111_000_000__00000010_11_11_01_0 ' SL AH BH normal
              long %1111111_000_000__00000100_11_11_01_0 ' SL AH BH shad/hl

              long %0000010_111_111__11111111_00_00_01_0 ' SH AL BL normal
              long %0000100_111_111__11111111_00_00_10_0 ' SH AL BL shad/hl
              long %0000010_111_000__11111111_00_11_01_0 ' SH AL BH normal
              long %0000100_111_000__11111111_00_11_01_0 ' SH AL BH shad/hl

              long %0000010_000_111__11111111_11_00_01_0 ' SH AH BL normal
              long %0000100_000_111__11111111_11_00_01_0 ' SH AH BL shad/hl
              long %0000010_000_000__11111111_11_11_01_0 ' SH AH BH normal
              long %0000100_000_000__11111111_11_11_01_0 ' SH AH BH shad/hl



vdpc_outbuffer          long @outbuffer_loc
vdpc_renderbuffer       long @renderbuffer_loc

vdpc_cramptr            long @vdp_cram32

vdpc_4prioIdxes_base    long 0

vdpc_halfpix            long $80_80_80_00

vdpc_shadhlbits         long $20_20_20_20
vdpc_colorbits          long $3F_3F_3F_3F
vdpc_priobits           long $40_40_40_40
vdpc_hlcolor            long $0E_0E_0E_0E

vdpc_pnibs              long 15<<0,15<<8,15<<16,15<<24

vdpc_ptrs               res 1

vdpc_tmp1               res 1
vdpc_tmp2               res 1
vdpc_tmp3               res 1
vdpc_tmp4               res 1
{
vdpc_pixelB             res 1
vdpc_pixelA             res 1
vdpc_pixelS             res 1
}

vdpc_4prioIdxes         res 1

vdpc_4pixelsB           res 1
vdpc_4pixelsA           res 1
vdpc_4pixelsS           res 1

vdpc_pixelOut           res 1
vdpc_shadhl             res 1

vdpc_priorities         res 1

vdpc_iter               res 1

vdpc_curline            res 1

vdpc_colors             res 64*3

vdpc_bgcolor            res 1
vdpc_flags              res 1
{
vdpc_planeB             res 336/4
vdpc_planeA             res 336/4
vdpc_planeS             res 336/4 }

                        fit 496

DAT ' MegaVDP I/O Interface
              orgh

vdpio_read8
              testb mk_eacache,#0 wc
              call #vdpio_read16
        if_nc shr mk_memvalue,#8
              and mk_memvalue,#255
              ret wcz

vdpio_read16
              mov pa,mk_eacache
              shr pa,#2 ' A0/A1 are not decoded by VDP
              and pa,#$7 wz
        if_z  jmp #.rd_dataport
              cmp pa,#1 wz
        if_z  jmp #.rd_status
              ' H/V counter

              ' TODO: H count, interlace mode
              mov mk_memvalue,#0
              rdlong pa,#video_line_ctr
              'debug("read Vline: ",sdec_(pa))
              cmps pa,#$EB wc
        if_ae sub pa,#6 ' weird quirk...

              setbyte mk_memvalue,pa,#1

              ' Hcount...
              ' make head hurt
              '                | calc val | needed val
              ' scanline start |        0 |        164
              ' border end     |       18 |        182
              ' hblank start   |       19 |        228
              ' hblank end     |       46 |        255
              ' active start   |       47 |          0
              ' active end     |      210 |        163

              setq #1
              rdlong mk_memtmp0,#vdp_linestartct_l ' vdp_cyc2hcnt_w in mk_memtmp1
              getct pa
              sub pa,mk_memtmp0
              mul pa,mk_memtmp1
              shr pa,#16
              fle pa,#210
              cmp pa,#19 wcz
        if_b  add pa,#164
        if_b  skip #%111
              cmp pa,#47 wcz
        if_b  add pa,#228-19
        if_ae sub pa,#47

              setbyte mk_memvalue,pa,#0
              ret wcz


.rd_status
              mov mk_memvalue,##%001101_10_0000_0000
              setq #1
              rdlong mk_memtmp0,#video_line_ctr
              cmp mk_memtmp0,#224 wc ' Also clears C for negative values
              muxnc mk_memvalue,#%1000_1000 ' vint/vblank flag
              rdlong pa,#vdp_flags
              testb pa,#VDPFLAG_VINT wc
        if_nc bitl mk_memvalue,#7 ' VInt didn't occur if it wasn't enabled
              testb pa,#VDPFLAG_LACED_OUTPUT wc
              testb mk_memtmp1,#0 andc
              muxc mk_memvalue,#%0001_0000 ' odd field flag
              'bitrnd mk_memvalue,#2 ' HACK: randomize Hblank flag
              bith mk_memvalue,#9 ' HACK: FIFO always empty
              ' Hblank flag
              setq #1
              rdlong mk_memtmp0,#vdp_linestartct_l ' vdp_cyc2hcnt_w in mk_memtmp1
              getct pa
              sub pa,mk_memtmp0
              mul pa,mk_memtmp1
              shr pa,#16
              cmpr pa,#179-164 wc
        if_c  cmp pa,#5+47 wc
              bitc mk_memvalue,#2

              'debug("VDP status ",uhex_word_(mk_memvalue),uhex_long(mk_virtualpc))
              'debug(uhex_word_array(#@vdp_ram+$C000,#3))
              ret wcz


.rd_dataport
              rdlong mk_memtmp0,#vdp_io_address_w wc
              debug("data port read with ",uhex_long_(mk_memtmp0),uhex_long(mk_virtualpc))
        if_c  ret wcz ' read is ignored in write mode
              ' handle address autoincrement
              getbyte pa,mk_memtmp0,#2
              add pa,mk_memtmp0
              wrword pa,#vdp_io_address_w
              ' do stuff
              testb mk_memtmp0,#24 wz ' CRAM flag?
              testb mk_memtmp0,#25 wc ' VSRAM flag?
        if_00 setword mk_memtmp0,#vdp_ram>>16,#1
    if_not_00 and  mk_memtmp0,#63<<1
        if_01 loc  pa,#\vdp_cram+$120
        if_10 loc  pa,#\vdp_cram
    if_not_00 add  mk_memtmp0,pa
              rdword mk_memvalue,mk_memtmp0
              debug("got ",uhex_word_(mk_memvalue))
              ret wcz


vdpio_write8
              movbyts mk_memvalue,#%%2200
vdpio_write16
              'debug("got vdpio_write ",uhex_long(mk_eacache),uhex_long(mk_memvalue),uhex_long($7F))
              mov pa,mk_eacache
              shr pa,#2 ' A0/A1 are not decoded by VDP
              and pa,#$7 wz
        if_z  jmp #.wr_dataport
              cmp pa,#$4 wc
        if_ae shr mk_memvalue,#8
        if_ae jmp #psg_portwrite ' will also beget debug port writes, but those would frick shit up, anyways
              ' okay, write control port (also begets HV count writes, but those would lock up)
              'debug("cp write ",uhex_word_(mk_memvalue),uhex_long_(mk_virtualpc))
              rdbyte mk_memtmp0,#vdp_iomode_b
              rdword mk_memtmp2,#vdp_io_address_w
              testb mk_memtmp0,#4 wc
        if_c  jmp #.asetup_2nd
              
              ' Address lower bits are updated even if register write
              setq ##bmask 13
              muxq mk_memtmp2,mk_memvalue
              wrword mk_memtmp2,#vdp_io_address_w
         
              ' why is the control port format so obnoxious???
              testb mk_memvalue,#15 wc
              testb mk_memvalue,#14 wz
    if_not_10 jmp #.asetup_1st
              ' phew, got a register write
              wrbyte #$03,#vdp_iomode_b
              mov pa,mk_memvalue
              shr pa,#4 ' 16 instr per reg should be enough
              and pa,#%11111_0000
              fle pa,#$18*16
              jmprel pa
.vdp_regwr_base
              orgh .vdp_regwr_base + $00*16*4 ' mode 1
              ' %xxLHxMFD
              ' L - mask left 8 px (TODO (?))
              ' H - Hblank IRQ enable (TODO)
              ' M - mask colors (don't care)
              ' F - freeze HV counter (don't care(???))
              ' D - Disable display (I think this literally disables the video??? don't care???)
              rdlong pa,#vdp_flags
              testb mk_memvalue,#4 wc
              bitc pa,#VDPFLAG_HINT
              wrlong pa,#vdp_flags
              ret wcz
              orgh .vdp_regwr_base + $01*16*4 ' mode 2
              ' %XEVDPMxx
              ' X - 128k VRAM (don't care)
              ' E - Enable display
              ' V - Vblank IRQ enable
              ' D - DMA enable
              ' P - PAL V30 mode (don't care)
              ' M - MegaDrive/Master System compat select (don't care)
              rdlong pa,#vdp_flags
              testb mk_memvalue,#5 wc
              bitc pa,#VDPFLAG_VINT
              testb mk_memvalue,#6 wc
              bitnc pa,#VDPFLAG_BLANK
              wrlong pa,#vdp_flags
              testb mk_memvalue,#4 wc
              wrc pa
              wrbyte pa,#vdp_dma_enable_b
              ret wcz
              orgh .vdp_regwr_base + $02*16*4 ' plane A address
              and mk_memvalue,#%00111000
              shl mk_memvalue,#10
              wrlong mk_memvalue,#vdp_planeAbase
              ret wcz
              orgh .vdp_regwr_base + $03*16*4 ' window address
              and mk_memvalue,#%00111110
              shl mk_memvalue,#10
              wrlong mk_memvalue,#vdp_windowbase
              ret wcz
              orgh .vdp_regwr_base + $04*16*4 ' plane B address
              ' WHY IS THIS DIFFERENT THAN PLANE A??!?!?!?!?
              and mk_memvalue,#%00000111
              shl mk_memvalue,#13
              wrlong mk_memvalue,#vdp_planeBbase
              ret wcz
              orgh .vdp_regwr_base + $05*16*4 ' sprite table address
              and mk_memvalue,#127
              shl mk_memvalue,#9
              wrlong mk_memvalue,#vdp_spritebase
              debug("sprite base set: ",uhex_long_(mk_memvalue))
              ret wcz
              orgh .vdp_regwr_base + $06*16*4 ' ????
              ret wcz
              orgh .vdp_regwr_base + $07*16*4 ' background color
              and mk_memvalue,#63
              wrlong mk_memvalue,#vdp_bgcolor
              ret wcz
              orgh .vdp_regwr_base + $08*16*4 ' ????
              ret wcz
              orgh .vdp_regwr_base + $09*16*4 ' ????
              ret wcz
              orgh .vdp_regwr_base + $0A*16*4 ' horizontal IRQ distance
              wrbyte mk_memvalue,#vdp_hint_interval_b
              ret wcz
              orgh .vdp_regwr_base + $0B*16*4 ' mode 3
              ' %xxxxIVHH
              ' I - external IRQ enable (don't care)
              ' V - column scroll enable
              ' HH - hscroll enable
              testb mk_memvalue,#2 wc
              wrc pa
              wrlong  pa,#vdp_columnscroll
              and mk_memvalue,#3
              wrlong  mk_memvalue,#vdp_hscrollmode
              ret wcz
              orgh .vdp_regwr_base + $0C*16*4 ' mode 4
              ' %HxxxSIIH
              ' H - H40 enable - both bits must be the same
              ' I - Interlace enables (rendering and output)
              ' S - shadow/highlight
              ' luckily, this matches our VDPFLAGS exactly. Weird,huh?
              and mk_memvalue,#%1111
              rdbyte pa,#vdp_flags
              setq #%1111
              muxq pa,mk_memvalue
              wrbyte pa,#vdp_flags
              ret wcz
              orgh .vdp_regwr_base + $0D*16*4 ' H scroll table address
              and mk_memvalue,#%00111111
              shl mk_memvalue,#10
              wrlong mk_memvalue,#vdp_hscrollbase
              ret wcz
              orgh .vdp_regwr_base + $0E*16*4 ' don't care
              ret wcz
              orgh .vdp_regwr_base + $0F*16*4 ' auto increment
              wrbyte mk_memvalue,#vdp_autoinc_b
              ret wcz
              orgh .vdp_regwr_base + $10*16*4 ' plane sizes
              rczr mk_memvalue wcz
        if_00 wrlong #5+1,#vdp_planewidth ' 32 tiles
        if_01 wrlong #6+1,#vdp_planewidth ' 64 tiles
        if_1x wrlong #7+1,#vdp_planewidth '128 tiles
              rczr mk_memvalue wcz
              rczr mk_memvalue wcz
        if_00 wrlong #4,#vdp_planeheight ' 32 tiles
        if_01 wrlong #5,#vdp_planeheight ' 64 tiles
        if_1x wrlong #6,#vdp_planeheight '128 tiles
              ret wcz
              orgh .vdp_regwr_base + $11*16*4 ' window H config
              rdbyte pa,#vdp_flags
              testb mk_memvalue,#7 wc
              bitc pa,#VDPFLAG_WINRIGHT
              and mk_memvalue,#31
              shl mk_memvalue,#1
              wrbyte pa,#vdp_flags
              wrlong mk_memvalue,#vdp_windowColumn
              ret wcz
              orgh .vdp_regwr_base + $12*16*4 ' window V config
              rdbyte pa,#vdp_flags
              testb mk_memvalue,#7 wc
              bitc pa,#VDPFLAG_WINDOWN
              and mk_memvalue,#31
              mul mk_memvalue,#8
              wrbyte pa,#vdp_flags
              wrlong mk_memvalue,#vdp_windowRow
              ret wcz
              orgh .vdp_regwr_base + $13*16*4 ' DMA length low
              wrbyte mk_memvalue,#vdp_dmalen_w+0
              ret wcz
              orgh .vdp_regwr_base + $14*16*4 ' DMA length high
              wrbyte mk_memvalue,#vdp_dmalen_w+1
              ret wcz
              orgh .vdp_regwr_base + $15*16*4 ' DMA source low
              wrbyte mk_memvalue,#vdp_dmasrc_l+0
              ret wcz
              orgh .vdp_regwr_base + $16*16*4 ' DMA source mid
              wrbyte mk_memvalue,#vdp_dmasrc_l+1
              ret wcz
              orgh .vdp_regwr_base + $17*16*4 ' DMA source high
              debug("high byte DMA source: ",uhex_byte_(mk_memvalue),uhex_long(mk_virtualpc))
              signx mk_memvalue,#7 ' extend it such that we can check fill/copy flag faster
              wrword mk_memvalue,#vdp_dmasrc_l+2
              ret wcz
              orgh .vdp_regwr_base + $18*16*4 ' doesn't exist
              ret wcz

.asetup_1st
              'debug("asetup_1st ",uhex_long_array(#vdp_io_address_w,#1),uhex_word(mk_memvalue))
              mov mk_memtmp0,#$10
              bitz mk_memtmp0,#7 ' we can at least reason about RW from bit 14 (still in Z)
        if_z_and_c bith mk_memtmp0,#1 ' if write and bit 15 set, we know we got CRAM
              wrbyte mk_memtmp0,#vdp_iomode_b
              ret wcz
.asetup_2nd
              'debug("asetup_2nd ",uhex_long_array(#vdp_io_address_w,#1),uhex_word(mk_memvalue))
              rczr mk_memvalue wcz ' TAKE NOTE: bye bye bottom two bits
              bitc mk_memtmp2,#15
              bitz mk_memtmp2,#14
              wrword mk_memtmp2,#vdp_io_address_w
              rdbyte mk_memtmp0,#vdp_iomode_b wc
              bitl mk_memtmp0,#4
        if_nc jmp #.asetup_read ' when does one ever read back from VRAM, anyways?
              ' setup write
              testb mk_memvalue,#4-2 wc ' VSRAM write
              bitc mk_memtmp0,#0
              testb mk_memvalue,#7-2 wc
        if_c  rdbyte pa,#vdp_dma_enable_b wz
 if_c_and_nz  jmp #.do_dma
              wrbyte mk_memtmp0,#vdp_iomode_b
              ret wcz

.asetup_read
              ' command bits that select VRAM/CRAM/VSRAM line up with our flags
              debug("in .asetup_read ",uhex_word(mk_memvalue),uhex_byte(mk_memtmp0))
              testb mk_memvalue,#7-2 wc
              shr mk_memvalue,#4-2
              and mk_memvalue,#3
              or mk_memtmp0,mk_memvalue
              wrbyte mk_memtmp0,#vdp_iomode_b
        if_c  jmp #.do_vramcopy
              ret wcz


.do_dma
              rdlong mk_memtmp1,#vdp_dmasrc_l wc
              rdword mk_memtmp2,#vdp_dmalen_w wz
        if_z  setword mk_memtmp2,#1,#1
        if_c  jmp #.asetup_fill
              wrbyte mk_memtmp0,#vdp_iomode_b ' Yes, after DMA, VDP should be in regular write mode - I think. Thing is really weird. Unless we're doing a fill.
              debug("Doing DMA of ",uhex_word_(mk_memtmp2)," words from ",uhex_long_(mk_memtmp1)," to ",uhex_word_array_(#@vdp_io_address_w,#1),uhex_long(mk_virtualpc))

              ' Increment the source address now so we don't have to later
              mov pa,mk_memtmp1
              add pa,mk_memtmp2
              wrword pa,#vdp_dmasrc_l ' Only increment low 16 bits, because of course (we don't heed this inside the copy loop, but eh)
              wrword #0,#vdp_dmalen_w ' Also think we need to clear this nonsense

              testb mk_memtmp1,#22 wc
        if_c  jmp #.ramdma

              ' oki doki doki, do ROM->VDP DMA. By just calling the dataport write, because that'll handle all the dumb edgecases.

              ' first block is special, because we need to handle non-long-aligned src
              shr mk_memtmp1,#1 wc
        if_c  mov mk_memtmp3,#DMA_BLOCK_SIZE*2 - 1
        if_nc mov mk_memtmp3,#DMA_BLOCK_SIZE*2 - 0
              loc ptrb,#mk_romio_area
        if_c  add ptrb,#2
              mov mk_romio_length,#DMA_BLOCK_SIZE
              mov mk_romio_target,##@mk_romio_area
              mov pa,mk_memtmp1
              call #mk_readrom
              add mk_memtmp1,#DMA_BLOCK_SIZE
.romdma_loop
              rdword mk_memvalue,ptrb++
              movbyts mk_memvalue,#%%2301 ' Swap here. We have another conditional swap in .wr_dataport, but oh well.
              rdlong mk_memtmp0,#vdp_io_address_w
              call #.wr_dataport_internal
              djz mk_memtmp2,#.romdma_ret
              djnz mk_memtmp3,#.romdma_loop
              ' reload src
              mov pa,mk_memtmp1
              mov mk_romio_length,#DMA_BLOCK_SIZE
              call #mk_readrom
              add mk_memtmp1,#DMA_BLOCK_SIZE
              mov mk_memtmp3,#DMA_BLOCK_SIZE*2 - 0
              loc ptrb,#mk_romio_area
              jmp #.romdma_loop
.romdma_ret
              ret wcz

.ramdma
              ' RAM sourced DMA is easier
              shl mk_memtmp1,#1
.ramdma_loop
              setword mk_memtmp1,#main_ram>>16,#1
              rdword mk_memvalue,mk_memtmp1
              add mk_memtmp1,#2
              movbyts mk_memvalue,#%%2301 ' Swap here. We have another conditional swap in .wr_dataport, but oh well.
              rdlong mk_memtmp0,#vdp_io_address_w
              call #.wr_dataport_internal
              djnz mk_memtmp2,#.ramdma_loop
              ret wcz


.asetup_fill
              testb mk_memtmp1,#22 wc ' Actually filling???
        if_nc bith mk_memtmp0,#5
              wrbyte mk_memtmp0,#vdp_iomode_b
        if_nc ret wcz


.do_vramcopy
              rdlong mk_memtmp1,#vdp_dmasrc_l wc
              testb mk_memtmp1,#22 andc
        if_nc ret wcz  ' if fill mode or tranfer mode, ignore???
              rdword mk_memtmp2,#vdp_dmalen_w wz
        if_z  setword mk_memtmp2,#1,#1

               ' Increment the source address now so we don't have to later
              mov pa,mk_memtmp1
              add pa,mk_memtmp2
              wrword pa,#vdp_dmasrc_l ' Only increment low 16 bits.
              wrword #0,#vdp_dmalen_w ' Also think we need to clear this nonsense

              mov ptrb,mk_memtmp1
              rdlong mk_memtmp0,#vdp_io_address_w
              getbyte mk_memtmp1,mk_memtmp0,#2 ' destination increment
              debug("VRAM copy of ",uhex_word_(mk_memtmp2)," bytes from ",uhex_word_(ptrb)," to ",uhex_word_array_(#@vdp_io_address_w,#1))
.copy_loop
              ' VRAM copy is strange (byte-wise...)
              setword mk_memtmp0,#vdp_ram>>16,#1
              setword ptrb,#vdp_ram>>16,#1
              rdbyte mk_memvalue,ptrb++
              wrbyte mk_memvalue,mk_memtmp0
              add mk_memtmp0,mk_memtmp1
              djnz mk_memtmp2,#.copy_loop


              ret wcz



.do_fill
              getbyte mk_memtmp1,mk_memvalue,#1
              rdword mk_memtmp2,#vdp_dmalen_w wz
        if_z  setword mk_memtmp2,#1,#1
              wrword #0,#vdp_dmalen_w
              debug("VRAM fill of ",uhex_word_(mk_memtmp2)," bytes with ",uhex_word_(mk_memtmp1)," to ",uhex_word_array_(#@vdp_io_address_w,#1)," and increment ",uhex_byte_array_(#@vdp_autoinc_b,#1))
              ' VRAM fill is very very strange
              mov ptrb,mk_memtmp0
              call #.wr_dataport_internal
              rdbyte mk_memtmp0,#vdp_autoinc_b
.fill_loop
              add ptrb,mk_memtmp0
              setword ptrb,#vdp_ram>>16,#1
              wrbyte mk_memtmp1,ptrb
              djnz mk_memtmp2,#.fill_loop
              ret wcz

.wr_dataport  ' This is called for DMA, too, please don't touch anything but mk_memtmp0
              rdlong mk_memtmp0,#vdp_io_address_w wc
              'debug("data port write with ",uhex_word_(mk_memvalue),uhex_long_(mk_memtmp0),uhex_long(mk_virtualpc))
        if_nc ret wcz ' write is ignored in read mode
              testb mk_memtmp0,#29 wc ' Fill flag
        if_c  jmp #.do_fill
.wr_dataport_internal
              ' handle address autoincrement
              getbyte pa,mk_memtmp0,#2
              add pa,mk_memtmp0
              wrword pa,#vdp_io_address_w
              bitl mk_memtmp0,#0 wcz 'VDP adresses are word-granular (bit0 endian swaps)
        if_nc skipf #%100 ' skip over endian swap if even address
              ' do stuff
              testb mk_memtmp0,#24 wz ' CRAM flag?
              testb mk_memtmp0,#25 wc ' VSRAM flag?
        if_00 movbyts mk_memvalue,#%%2301 ' Byteswap can only happen in VRAM
        if_00 setword mk_memtmp0,#vdp_ram>>16,#1
    if_not_00 and  mk_memtmp0,#63<<1
        if_01 loc  pa,#\vdp_cram+$120
        if_10 loc  pa,#\vdp_cram
    if_not_00 add  mk_memtmp0,pa
    if_not_11 wrword mk_memvalue,mk_memtmp0
    if_not_10 ret wcz
              '' Update CRAM32
              sub mk_memtmp0,pa
              shl mk_memtmp0,#1
              add mk_memtmp0,##@vdp_cram32
              and mk_memvalue,##$EEE
              shl mk_memvalue,#1
              add mk_memvalue,##@cram2cram32_table
              rdlong pa,mk_memvalue
              wrlong pa,mk_memtmp0
              add mk_memvalue,#8*4
              add mk_memtmp0,#64*4
              rdlong pa,mk_memvalue
              wrlong pa,mk_memtmp0
              add mk_memvalue,#(128*4)-(8*4)
              add mk_memtmp0,#64*4
              rdlong pa,mk_memvalue
              wrlong pa,mk_memtmp0
              ret wcz

.psg
              ret wcz '???

CON ' ZiKore constants

ZK_HLOP = 1<<10

ZK_CARRY_BIT = 0
ZK_NMODE_BIT = 1
ZK_OVER_BIT  = 2 ' also parity
ZK_HALF_BIT  = 4
ZK_ZERO_BIT  = 6
ZK_SIGN_BIT  = 7

ZK_XYMASK     = %0010_1000
ZK_SIGNXYMASK = %1010_1000

ZK_IFF1_BIT = 0
ZK_IFF2_BIT = 1


DAT ' ZiKore Z80 cog resident code
              org
zk_cogbase



zk_nextop
              'debug("skip canary")
              'debug(udec(zk_cycles)," elapsed",uhex_word(zk_pc))
              rdword pa,#zbus_request wz ' get both zbus_request and z80_reset bits
        if_z  jmp #.bus_clear
              testb pa,#8 wc
        if_c  jmp #zk_doreset
              wrbyte #0,#zbus_status ' release bus
              getct zk_lastwait
              jmp #zk_nextop

.bus_clear
              wrbyte #1,#zbus_status ' we're gonna use the bus

zk_irqhook    nop
zk_nextop_nohook
              {
              cmp zk_pc,##$06B2 wz
        'if_nz cmp zk_pc,##$06EF wz
        if_nz cmp zk_pc,##$06D2 wz
        'if_nz cmp zk_pc,##$044E wz
        'if_nz cmp zk_pc,##$0451 wz
        if_nz jmp #.nodebug          '}
              'debug(uhex_word(zk_pc),uhex_long(zk_debc),uhex_word(zk_hl,zk_sp),uhex_byte(zk_accu),ubin_byte(zk_flags))
              'debug(uhex_byte_array(#@fakemem+$FFF0,#16))
.nodebug
              mul zk_cycles,zk_cycletime
              add zk_cycles,zk_lastwait
              getct pa
              sub zk_cycles,pa
              cmps zk_cycles,#1 wc
        if_ae waitx zk_cycles
              getct zk_lastwait

              mov zk_cycles,#1

              mov zk_temphl,zk_hl
              mov zk_hlptr,#zk_hl
              mov zk_tempidx,zk_hl
              mov zk_prefix,#0
              incmod zk_refresh,#127

              call #zk_readcode
              mov zk_opcode,zk_tmp8
              'debug(uhex_byte(zk_opcode))
              rdlut zk_opimpl,zk_opcode
              'debug(uhex_long(zk_opimpl))
              bitl zk_opimpl,#10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
              push #zk_nextop
              execf zk_opimpl

zk_iyprefix
              mov zk_hlptr,#zk_iy
zk_ixprefix
              mov zk_hlptr,#zk_ix

              mov zk_prefix,zk_opcode
              incmod zk_refresh,#127
              add zk_cycles,#1


              call #zk_readcode
              mov zk_opcode,zk_tmp8
              rdlut zk_opimpl,zk_opcode
              bitl zk_opimpl,#10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc jmp #.nodisplace
              ' handle index displacement
              mov zk_temphl,zk_hl
              alts zk_hlptr
              mov zk_tempidx,0-0
              mov zk_hlptr,#zk_hl
              call #zk_readcode
              signx zk_tmp8,#7
              add zk_tempidx,zk_tmp8
              execf zk_opimpl

.nodisplace
              alts zk_hlptr
              mov zk_temphl,0-0
              mov zk_tempidx,zk_temphl
              execf zk_opimpl


zk_bitprefix
              call #\zk_readcode
              mov zk_opcode,zk_tmp8
              add zk_cycles,#1
              incmod zk_refresh,#127

              cmp zk_prefix,#0 wz
        if_z  call #zk_getrz
        if_nz call #zk_read8hl

              mov pa,zk_opcode
              shr pa,#3
              and pa,#7

              testb zk_opcode,#7 wc
              testb zk_opcode,#6 wz
        if_00 jmp #.shift
        if_01 jmp #.bit
              bitz zk_tmp8,pa
              ' write result (slightly complex)
              mov pa,zk_opcode
              and pa,#7
              cmp pa,#6 wz
        if_nz cmp zk_prefix,#0 wz
        if_nz push #zk_write8hl
              jmp #\zk_setrz


.bit
              decod pa
              and pa,zk_tmp8 wz
              muxz zk_flags,#(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
              bitl zk_flags,#ZK_NMODE_BIT
              bith zk_flags,#ZK_HALF_BIT
              setq #1<<ZK_SIGN_BIT
              muxq zk_flags,pa
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_tmp8


.shift
              push #.shiftdone
              altd pa,#zk_shift_impl_tbl
              execf 0-0

.shiftdone
              ' write result (slightly complex)
              mov pa,zk_opcode
              and pa,#7
              cmp pa,#6 wz
        if_nz cmp zk_prefix,#0 wz
        if_nz push #zk_write8hl
              jmp #\zk_setrz


zk_shift_impl_tbl
              long zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
              long zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
              long zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
              long zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
              long zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
              long zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
              long zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
              long zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL


zk_extprefix
              call #\zk_readcode
              mov zk_opcode,zk_tmp8
              add zk_cycles,#1
              incmod zk_refresh,#127
              'debug("extend ",uhex_byte(zk_opcode))

              cmp zk_opcode,#$A0 wc
        if_ae jmp #.blockop
              cmp zk_opcode,#$40 wc
        if_b  ret

              mov pa,zk_opcode
              and pa,#7
              altd pa,#zk_ext_impl_tbl
              execf 0-0

.blockop
              '' The undocumented flags on these are cursed.
              test zk_opcode,#%0100_0100 wz
        if_nz ret ' NOP
              rczr zk_opcode wcz ' get operation type into cz
        if_00 add zk_cycles,#2
        if_01 add zk_cycles,#5
        if_1x add zk_cycles,#1
        if_00 skipf ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01 skipf ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10 skipf ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11 skipf ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

              getbyte zk_ea,zk_debc,#0 ' IN
              call #\zk_portin ' IN
              call #\zk_read8hl ' everything else

              andn zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
              bith zk_flags,#ZK_NMODE_BIT ' CP
              testb zk_tmp8,#7 wc ' IN/OUT
              bitc zk_flags,#ZK_NMODE_BIT ' IN/OUT

              mov zk_optmp0,zk_accu ' LD CP
              getbyte zk_optmp0,zk_hl,#0 ' OUT
              getbyte zk_optmp0,zk_debc,#0 ' IN
              testb zk_opcode,#1 wc ' IN
              sumc zk_optmp0,#1 ' IN
              mov zk_optmp1,zk_tmp8 ' CP
              xor zk_optmp1,zk_optmp0 ' CP

              sub zk_optmp0,zk_tmp8 ' CP only
              add zk_optmp0,zk_tmp8 ' LD,IN,OUT

              xor zk_optmp1,zk_optmp0 ' CP
              and zk_optmp0,#255 wz ' CP,IN,OUT
              bitz zk_flags,#ZK_ZERO_BIT ' CP
              testb zk_optmp0,#7 wc ' CP
              bitc  zk_flags,#ZK_SIGN_BIT ' CP

              testb zk_optmp1,#4 wc   ' CP
              cmpr zk_optmp0,#255 wc  ' IN/OUT
              bitc zk_flags,#ZK_HALF_BIT ' CP
              muxc zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c  sub zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

              skipf ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
              skipf ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
              skipf ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
              skipf ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


              testb zk_optmp0,#1 wc ' LD,CP
              bitc zk_flags,#5 'LD,CP (sets YF)
              testb zk_optmp0,#3 wc ' LD,CP
              bitc zk_flags,#3 'LD,CP (sets XF)

              getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
              and zk_optmp0,#7 ' IN,OUT
              xor zk_optmp0,zk_optmp1 wc ' IN,OUT
              bitnc zk_flags,#ZK_OVER_BIT ' IN,OUT

              mov zk_ea,zk_hl  ' IN
              getword zk_ea,zk_debc,#1 ' LD
              call #\zk_write8 ' LD,IN
              getbyte zk_ea,zk_debc,#0 ' OUT
              call #\zk_portout ' OUT

              getword zk_optmp1,zk_debc,#0 ' LD,CP
              decmod zk_optmp1,zk_ffffh wz ' all
              setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
              setword zk_debc,zk_optmp1,#0 ' LD,CP
              bitnz zk_flags,#ZK_OVER_BIT ' LD,CP
              bitz zk_flags,#ZK_ZERO_BIT ' IN,OUT
              setq #ZK_SIGNXYMASK ' IN,OUT
              muxq zk_flags,zk_optmp1 ' IN,OUT

              testb zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
              testb zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc incmod zk_ea,zk_ffffh    ' LD
        if_c  decmod zk_ea,zk_ffffh    ' LD
              setword zk_debc,zk_ea,#1 ' LD

        if_nc incmod zk_hl,zk_ffffh
        if_c  decmod zk_hl,zk_ffffh

              testb zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz  sub zk_pc,#2
 if_c_and_nz  add zk_cycles,#5
              'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
              ret

zk_ext_impl_tbl
              long zk_cio + (%10_11_11_000000<<10) ' IN [BCDEHL0A],(C)
              long zk_cio + (%00_01_11_000000<<10) ' OUT (C),[BCDEHL0A]
              long zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
              long zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
              long zk_neg
              long zk_irqret
              long zk_imode
              long zk_ext_differentiate + (%0_011_000<<10) ' miscellany


zk_ext_differentiate
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7

              altd pa,#zk_extmath16_impl_tbl
              altd pa,#zk_extld16_impl_tbl
              altd pa,#zk_extmisc_impl_tbl

              execf 0-0

zk_extmath16_impl_tbl
              long zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
              long zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
              long zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
              long zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
              long zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
              long zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
              long zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
              long zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
              long zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
              long zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
              long zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
              long zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
              long zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
              long zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
              long zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
              long zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
              long zk_a2i                       ' LD I,A
              long zk_a2r                       ' LD R,A
              long zk_i2a                       ' LD A,I
              long zk_r2a  + (%1_000<<10)       ' LD A,R
              long zk_rxd + (%000_111_00<<10)   ' RRD
              long zk_rxd + (%111_000_00<<10)   ' RLD
              long zk_nextop                    ' NOP
              long zk_nextop                    ' NOP


zk_rxd
              call #\zk_read8hl
              add zk_cycles,#4
              ' RLD
              rolnib zk_tmp8,zk_accu,#0
              getnib pa,zk_tmp8,#2
              setnib zk_tmp8,#0,#2
              ' RRD
              setnib zk_tmp8,zk_accu,#2
              getnib pa,zk_tmp8,#0
              shr zk_tmp8,#4

              setnib zk_accu,pa,#0
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              and zk_accu,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_accu
              jmp #\zk_write8hl

zk_a2r
              mov zk_refresh,zk_accu
              and zk_refresh,#$7F
        _ret_ mov zk_refreshhi,zk_accu

zk_a2i
        _ret_ mov zk_ivector,zk_accu

zk_r2a
              mov zk_accu,zk_refresh
              setq #$80
              muxq zk_accu,zk_refreshhi
zk_i2a
              mov zk_accu,zk_ivector

              and zk_accu,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              testb zk_irqenable,#ZK_IFF2_BIT wc
              bitc zk_flags,#ZK_OVER_BIT
              andn zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu



zk_imode      ' Don't care, always assume IM1
              ret
zk_irqoff
              andn zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
        _ret_ mov zk_irqhook,#0

zk_irqret     '' RETI/RETN
              '' These are literally the same
              call #\zk_pop16
              mov zk_pc,zk_tmp16
              testb zk_irqenable,#ZK_IFF2_BIT wc
        if_nc ret
zk_irqon
              or zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
              mov zk_irqhook,##(%1111_1011110_010_000000100<<9)+zk_irqptr ' JSE1 zk_irqptr
              jmp #zk_nextop_nohook

zk_irqptr     long zk_doirq
zk_doirq
              andn zk_irqenable,#(1<<ZK_IFF1_BIT)
              mov zk_irqhook,#0
              mov zk_tmp16,zk_pc
              call #\zk_push16
              mov zk_pc,#$38
              jmp #\zk_nextop


zk_jump_indir
        _ret_ mov zk_pc,zk_temphl
zk_hl_to_sp
              add zk_cycles,#2
        _ret_ mov zk_sp,zk_temphl

zk_jump
              call #\zk_readcode16
zk_condret
              add zk_cycles,#1 ' Extra cycle in conditional RET

              testb zk_flags,#ZK_ZERO_BIT wc
              testb zk_flags,#ZK_CARRY_BIT wc
              testb zk_flags,#ZK_OVER_BIT wc
              testb zk_flags,#ZK_SIGN_BIT wc

              modc _nc wc
        if_c  call #\zk_nextop
zk_ret
              call #zk_pop16
              mov zk_optmp0,zk_tmp16 ' For every op!
zk_rst
              mov zk_optmp0,zk_opcode
              and zk_optmp0,#%00111000
zk_pushjmp
              mov zk_tmp16,zk_pc
              mov zk_pc,zk_optmp0
              jmp #\zk_push16
              ret



zk_getrz      ' Get value as indicated by opcode Z field
              mov pa,zk_opcode
              and pa,#7
              'debug("in zk_getrz ",uhex_byte(pa))
              add pa,#zk_getrpa-$-1
              jmprel pa
zk_getry      ' Get value as indicated by opcode Y field
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7
zk_getrpa
              jmprel pa
        _ret_ getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_ getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_ getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_ getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_ getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_ getbyte zk_tmp8,zk_temphl,#0 ' L register
              jmp #zk_read8hl              ' (HL)
        _ret_ getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz      ' Get value as indicated by opcode Z field
              mov pa,zk_opcode
              and pa,#7
              add pa,#zk_setrpa-$-1
              jmprel pa
zk_setry      ' Get value as indicated by opcode Y field
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7
              'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa     jmprel pa
        _ret_ setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_ setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_ setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_ setbyte zk_debc,zk_tmp8,#2   ' E register
              jmp #.seth                   ' H register
              jmp #.setl                   ' L register
              jmp #zk_write8hl             ' (HL)
        _ret_ setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
              setbyte zk_temphl,zk_tmp8,#1
              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl
.setl
              setbyte zk_temphl,zk_tmp8,#0
              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl

zk_push16
              add zk_cycles,#1
              sub zk_sp,#2
              setword zk_sp,#0,#1
              mov zk_ea,zk_sp
              jmp #zk_write16
zk_pop16
              mov zk_ea,zk_sp
              add zk_sp,#2
              setword zk_sp,#0,#1
              jmp #zk_read16

zk_read16hl
              getword zk_ea,zk_tempidx,#0
zk_read16
              call #zk_read8
              getbyte zk_tmp16,zk_tmp8,#0
              add zk_ea,#1
              call #zk_read8
              setbyte zk_tmp16,zk_tmp8,#1
        _ret_ sub zk_ea,#1

zk_read8hl
              getword zk_ea,zk_tempidx,#0
              jmp #zk_read8
zk_readcode
              mov zk_ea,zk_pc
              incmod zk_pc,zk_ffffh
              setword zk_pc,#0,#1
              ' fall through
zk_read8
              add zk_cycles,#3

              testb zk_ea,#15 wc
        if_c  jmp #zk_read_rombyte
              testb zk_ea,#14 wc
        if_nc jmp #.ramread
              '' TODO: I/O
              jmp #opn_statusread
              'mov zk_tmp8,#$03
              'ret wcz

.ramread
              mov pa,zk_ea
              zerox pa,#12
              add pa,##@z80_ram
              rdbyte zk_tmp8,pa
              ret wcz


zk_readcode16
              call #zk_readcode
              getbyte zk_tmp16,zk_tmp8,#0
              call #zk_readcode
        _ret_ setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
              getword zk_ea,zk_tempidx,#0
zk_write16
              getbyte zk_tmp8,zk_tmp16,#0
              call #zk_write8
              add zk_ea,#1
              getbyte zk_tmp8,zk_tmp16,#1
              call #zk_write8
        _ret_ sub zk_ea,#1


zk_write8hl
              getword zk_ea,zk_tempidx,#0
zk_write8
           {  cmp zk_ea,##$FFF8 wz
        if_nz cmp zk_ea,##$FFF9 wz
        if_nz jmp #.nodebug
              debug("write monitor! ",uhex_word(zk_ea),uhex_byte(zk_tmp8))     }
              'debug("in zk_read8 ",uhex_word(zk_ea))
.nodebug
              add zk_cycles,#3


              testb zk_ea,#15 wc
        if_c  ret wcz ' Write through bank area: no.
              testb zk_ea,#14 wc
        if_nc jmp #.ramwrite
              '' TODO: I/O
              cmp zk_ea,##$6000 wc
        if_b  jmp #opn_portwrite
              cmp zk_ea,##$6100 wc
        if_b  jmp #.bankreg' Banking register
              cmp zk_ea,##$7F10 wc
        if_ae cmpr zk_ea,##$7F17 wc
        if_ae jmp #psg_portwrite
              ' Don't care
              ret wcz

.bankreg
              shr zk_bankreg,#1
              testb zk_tmp8,#0 wz
              bitz zk_bankreg,#23
              and zk_bankreg,zk_bankmask
              ret wcz

.ramwrite
              mov pa,zk_ea
              zerox pa,#12
              add pa,##@z80_ram
              wrbyte zk_tmp8,pa
              ret wcz

zk_portout
              add zk_cycles,#4
              'debug("PORT OUT ",uhex_byte(zk_ea,zk_tmp8)," : "{, zk_tmp8} )
              'tjnz zk_ea,#.nope
              'debug(`ZTerm `(zk_tmp8))
.nope
              ret

zk_portin
              mov zk_tmp8,#$FF
              add zk_cycles,#4
              debug("PORT IN ",uhex_byte(zk_ea,zk_tmp8))
              ret wcz


zk_read_rombyte
              add zk_cycles,#3
              mov pa,zk_ea
              setq zk_bankmask
              muxq pa,zk_bankreg
              cmp pa,zk_romstop wcz
        if_ae mov zk_tmp8,#$FF
        if_ae ret wcz
              zerox pa,zk_romio_zerox
              rczr pa wcz
              mov zk_memtmp1,##(@z80_romio_area)>>2
              rczl zk_memtmp1
              cmp pa,zk_romio_cached wz
        if_z  jmp #.cached
              mov zk_romio_cached,pa

        { '' HUB RAM as ROM
              shl pa,#2
              zerox pa,#16 ' <- ROM SIZE HERE (16 = 128k)
              add pa,##fake_rom
              'debug("ROM read from ",uhex_long(pa)," to ",uhex_long(mk_romio_target))
              rdlong zk_memtmp3,pa
              wrlong zk_memtmp3,zk_romio_area_ptr
        '}
#ifdef USE_PSRAM_EITHER
              wrfast  zk_bit31,zk_romio_area_ptr
#ifndef USE_PSRAM16
              shl pa,#PSRAM_ASHIFT ' convert long address to native address (becomes no-op with USE_PSRAM16)
#endif
              setbyte pa,#$EB,#3
              splitb  pa
              rev     pa
              movbyts pa, #%%0123
              mergeb  pa
              locktry #ROM_LOCK wc
        if_nc jmp #$-1
#ifdef USE_PSRAM_SLOW
              drvl  #PSRAM_CLK ' must be 2 ops before xinit
#endif
              drvh  #PSRAM_SELECT
              drvl  zk_psram_pinfield
              xinit zk_psram_addr_cmd,pa
              wypin #(8+PSRAM_WAIT+(2<<PSRAM_ASHIFT))<<PSRAM_CYSHL,#PSRAM_CLK
              setq zk_nco_fast
              xcont #PSRAM_WAIT*PSRAM_CLKDIV+PSRAM_DELAY,#0
              waitxmt
              fltl zk_psram_pinfield
              setq zk_nco_slow
              xcont zk_psram_read_cmd,#0
              waitxfi
              drvl #PSRAM_SELECT
#ifdef USE_PSRAM_SLOW
              fltl  #PSRAM_CLK
#endif
              lockrel #ROM_LOCK
#endif
#ifdef USE_HYPER
              wrfast zk_bit31,zk_romio_area_ptr
              rczr pa wcz
              rczl zk_memtmp3
              and zk_memtmp3,#%11
              shl zk_memtmp3,#9
              setbyte pa,#%101_00000,#3 ' read linear burst
              movbyts pa, #%%0123
              locktry #ROM_LOCK wc
        if_nc jmp #$-1
              drvh #HYPER_SELECT
              drvl #HYPER_BASE addpins 7
              drvl #HYPER_CLK ' Init clock pin with correct (?) alignment
              xinit zk_hyper_addr_cmd1,pa
              wypin #(6+HYPER_WAIT+4),#HYPER_CLK ' setup clock periods
              xcont zk_hyper_addr_cmd2,zk_memtmp3
              setq zk_nco_fast
              xcont #HYPER_WAIT*2+HYPER_DELAY,#0
              waitxmt
              fltl #HYPER_BASE addpins 7
              setq zk_nco_slow
              xcont zk_hyper_read_cmd,#0
              waitxfi
              drvl #HYPER_SELECT
              fltl #HYPER_CLK ' put clock into reset
              lockrel #ROM_LOCK
#endif
.cached
              rdbyte zk_tmp8,zk_memtmp1
              ret wcz



zk_ffffh      long $FFFF
zk_18000h     long $18000
zk_bit31      long  negx

zk_cycles     long 0
zk_pc         long $0100

zk_bankmask   long $FF8000
zk_romstop    long $800000
zk_bankreg    long 0

zk_romio_area_ptr long @z80_romio_area
zk_romio_cached long -1

#ifdef USE_PSRAM16
zk_psram_pinfield long PSRAM_BASE addpins 15
zk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + ($8<<16) + 8
zk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD + 2
#endif
#ifdef USE_PSRAM8
zk_psram_pinfield long PSRAM_BASE addpins 7
zk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + ($8<<16) + 8
zk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE + 4
#endif
#ifdef USE_PSRAM4
zk_psram_pinfield long PSRAM_BASE addpins 3
zk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_4DAC1 + 8
zk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_4P_4DAC1_WFBYTE + 8
#endif
#ifdef USE_HYPER
zk_hyper_addr_cmd1 long (HYPER_BASE<<17)|X_PINS_ON | X_IMM_4X8_1DAC8 + 4
zk_hyper_addr_cmd2 long (HYPER_BASE<<17)|X_PINS_ON | X_IMM_4X8_1DAC8 + 2
zk_hyper_read_cmd  long (HYPER_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE + 4
#endif

zk_nco_fast   long $8000_0000
#ifdef USE_PSRAM_EITHER
#ifdef USE_PSRAM_SLOW
zk_nco_slow   long $2AAA_AAAB
#else
zk_nco_slow   long $4000_0000
#endif
#else
zk_nco_slow   long $4000_0000
#endif

zk_flags      long 0
zk_accu       long 0
zk_debc       long 0
zk_sp         long 0
zk_hl         long 0
zk_ix         long 0
zk_iy         long 0
zk_altflags   long 0
zk_altaccu    long 0
zk_altdebc    long 0
zk_althl      long 0
zk_refresh    long 0
zk_refreshhi  long 0
zk_ivector    long 0
zk_irqenable  long 0


zk_cycletime res 1
zk_lastwait   res 1

zk_opcode     res 1
zk_opimpl     res 1
zk_prefix     res 1
zk_temphl     res 1
zk_tempidx    res 1
zk_hlptr      res 1
zk_tmp16      res 1

zk_optmp0     res 1
zk_optmp1     res 1

zk_romio_zerox


              fit $1F0
              org $1F0
zk_memtmp0    res 1
zk_memtmp1    res 1
zk_memtmp2    res 1
zk_memtmp3    res 1
zk_tmp8       res 1 ' memory read/write value
zk_ea         res 1 ' remapped EA
              fit $1F6

DAT ' ZiKore Z80 LUT resident code
              org $200
zk_lutbase
              '' Opcode table
              long zk_nextop                            ' $00: NOP
              long zk_loadimm16 + (%0000_1_111_0<<10)   ' $01: LD BC,imm16
              long zk_a_and_ptr + (%001110<<10)         ' $02: LD (BC),A
              long zk_incdec16+(%0000_1_1111_10_1_11100<<10) ' $03: INC BC
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $04: INC B
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $05: DEC B
              long zk_loadimm8                          ' $06: LD B,imm8
              long zk_rolla+(%0_010_110_01_11110_00<<10) ' $07: RLCA
              long zk_ex_af                             ' $08: EX AF,AF'
              long zk_math16+(%0010_111_00_1100_00_1110_1_0<<10) ' $09: ADD HL,BC
              long zk_a_and_ptr + (%000010<<10)         ' $0A: LD A,(BC)
              long zk_incdec16+(%0000_1_1111_01_1_11100<<10) ' $0B: DEC BC
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $0C: INC C
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $0D: DEC C
              long zk_loadimm8                          ' $0E: LD C,imm8
              long zk_rolla+(%0_010_001_01_11011_00<<10) ' $0F: RRCA
              long zk_jr + (%01_11_0000_0<<10)          ' $10: DJNZ
              long zk_loadimm16 + (%0001_1_111_0<<10)   ' $11: LD DE,imm16
              long zk_a_and_ptr + (%00110 <<10)+1       ' $12: LD (DE),A
              long zk_incdec16+(%0001_1_1111_10_1_11010<<10) ' $13: INC DE
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $14: INC D
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $15: DEC D
              long zk_loadimm8                          ' $16: LD D,imm8
              long zk_rolla+(%0_010_110_00_11110_00<<10) ' $17: RLA
              long zk_jr + (%11_11_1111_0<<10)          ' $18: JR
              long zk_math16+(%0010_111_00_1100_00_1101_1_0<<10) ' $19: ADD HL,DE
              long zk_a_and_ptr + (%00000 <<10)+1       ' $1A: LD A,(DE)
              long zk_incdec16+(%0001_1_1111_01_1_11010<<10) ' $1B: DEC DE
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $1C: INC E
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $1D: DEC E
              long zk_loadimm8                          ' $1E: LD E,imm8
              long zk_rolla+(%0_010_001_00_11011_00<<10) ' $1F: RRA
              long zk_jr + (%01_10_1111_0<<10)          ' $20: JR NZ
              long zk_loadimm16 + (%0011_1_111_0<<10)   ' $21: LD HL,imm16
              long zk_ld_abs16 + (%01011_00<<10)        ' $22: LD (imm16),HL
              long zk_incdec16+(%0011_1_1111_10_1_10110<<10) ' $23: INC HL
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $24: INC H
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $25: DEC H
              long zk_loadimm8                          ' $26: LD H,imm8
              long zk_daa                               ' $27: DAA
              long zk_jr + (%00_10_1111_0<<10)          ' $28: JR Z
              long zk_math16+(%0010_111_00_1100_00_1011_1_0<<10) ' $29: ADD HL,HL
              long zk_ld_abs16 + (%00110_11111_00<<10)  ' $2A: LD HL,(imm16)
              long zk_incdec16+(%0011_1_1111_01_1_10110<<10) ' $2B: DEC HL
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $2C: INC L
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $2D: DEC L
              long zk_loadimm8                          ' $2E: LD L,imm8
              long zk_cpl                               ' $2F: CPL
              long zk_jr + (%01_01_1111_0<<10)          ' $30: JR NC
              long zk_loadimm16 + (%0111_1_111_0<<10)   ' $31: LD SP,imm16
              long zk_ld_abs + (%001111_00<<10)         ' $32: LD (imm16),A
              long zk_incdec16+(%0111_1_1111_10_1_01110<<10) ' $33: INC SP
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP ' $34: INC (HL)
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP ' $35: DEC (HL)
              long zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
              long zk_scf + (%10 << 10)                 ' $37: SCF
              long zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
              long zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
              long zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
              long zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
              long zk_loadimm8                          ' $3E: LD A,imm8
              long zk_ccf                               ' $3F: CCF
              long zk_nextop                            ' $40: LD B,B (NOP)
              long zk_regmove                           ' $41: LD B,C
              long zk_regmove                           ' $42: LD B,D
              long zk_regmove                           ' $43: LD B,E
              long zk_regmove                           ' $44: LD B,H
              long zk_regmove                           ' $45: LD B,L
              long zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
              long zk_regmove                           ' $47: LD B,A
              long zk_regmove                           ' $48: LD C,B
              long zk_nextop                            ' $49: LD C,C (NOP)
              long zk_regmove                           ' $4A: LD C,D
              long zk_regmove                           ' $4B: LD C,E
              long zk_regmove                           ' $4C: LD C,H
              long zk_regmove                           ' $4D: LD C,L
              long zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
              long zk_regmove                           ' $4F: LD C,A
              long zk_regmove                           ' $50: LD D,B
              long zk_regmove                           ' $51: LD D,C
              long zk_nextop                            ' $52: LD D,D (NOP)
              long zk_regmove                           ' $53: LD D,E
              long zk_regmove                           ' $54: LD D,H
              long zk_regmove                           ' $55: LD D,L
              long zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
              long zk_regmove                           ' $57: LD D,A
              long zk_regmove                           ' $58: LD E,B
              long zk_regmove                           ' $59: LD E,C
              long zk_regmove                           ' $5A: LD E,D
              long zk_nextop                            ' $5B: LD E,E (NOP)
              long zk_regmove                           ' $5C: LD E,H
              long zk_regmove                           ' $5D: LD E,L
              long zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
              long zk_regmove                           ' $5F: LD E,A
              long zk_regmove                           ' $60: LD H,B
              long zk_regmove                           ' $61: LD H,C
              long zk_regmove                           ' $62: LD H,D
              long zk_regmove                           ' $63: LD H,E
              long zk_nextop                            ' $64: LD H,H (NOP)
              long zk_regmove                           ' $65: LD H,L
              long zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
              long zk_regmove                           ' $67: LD H,A
              long zk_regmove                           ' $68: LD L,B
              long zk_regmove                           ' $69: LD L,C
              long zk_regmove                           ' $6A: LD L,D
              long zk_regmove                           ' $6B: LD L,E
              long zk_regmove                           ' $6C: LD L,H
              long zk_nextop                            ' $6D: LD L,L (NOP)
              long zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
              long zk_regmove                           ' $6F: LD L,A
              long zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
              long zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
              long zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
              long zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
              long zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
              long zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
              long zk_halt                              ' $76: HALT
              long zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
              long zk_regmove                           ' $78: LD A,B
              long zk_regmove                           ' $79: LD A,C
              long zk_regmove                           ' $7A: LD A,D
              long zk_regmove                           ' $7B: LD A,E
              long zk_regmove                           ' $7C: LD A,H
              long zk_regmove                           ' $7D: LD A,L
              long zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
              long zk_nextop                            ' $7F: LD A,A (NOP)
              long(zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
              long zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
              long(zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
              long zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
              long(zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
              long zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
              long zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
              long(zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
              long zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
              long(zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
              long zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
              long zk_logic + (%000000_110_0<<10)       ' $A7: AND A
              long(zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
              long zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
              long zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
              long(zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
              long zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
              long zk_logic + (%001000_101_0<<10)       ' $B7: OR A
              long(zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
              long zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
              long zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
              long zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
              long zk_poppair+(%0_0<<10)                  ' $C1: POP BC
              long zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
              long zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
              long zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
              long zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
              long zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
              long zk_rst                               ' $C7: RST 00h
              long zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
              long zk_ret + (%0101_11_00<<10)           ' $C9: RET
              long zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
              long zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
              long zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
              long zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
              long zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
              long zk_rst                               ' $CF: RST 08h
              long zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
              long zk_poppair+(%01_0<<10)                 ' $D1: POP DE
              long zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
              long zk_immio + (%00_00<<10)                ' $D3: OUT (imm8),A
              long zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
              long zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
              long zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
              long zk_rst                               ' $D7: RST 10h
              long zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
              long zk_exx                               ' $D9: EXX
              long zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
              long zk_immio + (%00_11_00<<10)             ' $DB: IN A,(imm8)
              long zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
              long zk_ixprefix                          ' $DD: IX prefix
              long zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
              long zk_rst                               ' $DF: RST 18h
              long zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
              long zk_poppair+(%0011_0<<10)               ' $E1: POP HL
              long zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
              long zk_ex_hlstk                          ' $E3: EX (SP),HL
              long zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
              long zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
              long zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
              long zk_rst                               ' $E7: RST 20h
              long zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
              long zk_jump_indir                          ' $E9: JP (HL)
              long zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
              long zk_ex_dehl                           ' $EB: EX DE,HL
              long zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
              long zk_extprefix + ZK_HLOP               ' $ED: extension prefix
              long zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
              long zk_rst                               ' $EF: RST 28h
              long zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
              long zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
              long zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
              long zk_irqoff                              ' $F3: DI
              long zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
              long zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
              long zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
              long zk_rst                               ' $F7: RST 30h
              long zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
              long zk_hl_to_sp                            ' $F9: LD SP,(HL)
              long zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
              long zk_irqon                               ' $FB: EI
              long zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
              long zk_iyprefix + (%10<<10)              ' $FD: IY prefix
              long zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
              long zk_rst                               ' $FF: RST 38h

              ' PSRAM helper table. Must be at $300
#ifdef USE_PSRAM16
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF
#elseifdef USE_PSRAM8
              long $00
              long $11
              long $22
              long $33
              long $44
              long $55
              long $66
              long $77
              long $88
              long $99
              long $AA
              long $BB
              long $CC
              long $DD
              long $EE
              long $FF
#else
              long 0[16]
#endif


zk_rolla      mov zk_tmp8,zk_accu
zk_shiftop
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

              bitl zk_tmp8,#7 wcz  ' left + SRA
              bitz zk_tmp8,#7 addbits 1 ' only SRA
              bitl zk_tmp8,#0 wcz  ' right
              modc _set wc ' only SLL
              modc _clr wc ' only SLA

              testb zk_flags,#ZK_CARRY_BIT wc' only RL/RR
              bitz zk_flags,#ZK_CARRY_BIT

              rcl zk_tmp8,#1 wz   ' left
              bitc zk_tmp8,#8     ' right (not SRA/SRL)
              shr zk_tmp8,#1 wz   ' right

              setq #ZK_XYMASK
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8

        _ret_ mov zk_accu,zk_tmp8

              bitz zk_flags,#ZK_ZERO_BIT
              test zk_tmp8,#$FF wc
        _ret_ bitnc zk_flags,#ZK_OVER_BIT


zk_cio
              mov zk_optmp1,zk_opcode
              and zk_optmp1,#7<<3
              cmp zk_optmp1,#6<<3 wz
              mov zk_tmp8,#0
        if_nz call #\zk_getry
              getbyte zk_ea,zk_debc,#0
zk_immio
              call #\zk_readcode
              mov zk_ea,zk_tmp8

              mov zk_tmp8,zk_accu
              jmp #\zk_portout

              call #\zk_portin
        _ret_ mov zk_accu,zk_tmp8

              and zk_tmp8,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8

              cmp zk_optmp1,#6<<3 wz
        if_z  ret
              jmp #\zk_setry




zk_incdec8
              call #\zk_getry
              mov zk_optmp0,#1
zk_math8
              call #\zk_getrz
zk_immmath
              call #\zk_readcode
              mov zk_optmp0,zk_tmp8
              mov zk_tmp8,zk_accu

              modc _clr wc
              testb zk_flags,#ZK_CARRY_BIT wc

              ' Flag helper gunk
              mov zk_optmp1,zk_tmp8

              addx zk_tmp8,zk_optmp0
              bitl zk_flags,#ZK_NMODE_BIT
              subx zk_tmp8,zk_optmp0
              bith zk_flags,#ZK_NMODE_BIT

              xor zk_optmp1,zk_tmp8
              test zk_tmp8,#$100 wc
              bitc zk_flags,#ZK_CARRY_BIT
              and zk_tmp8,#255 wz

              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8
              ' Special nonsense for CP
              setq #ZK_XYMASK
              muxq zk_flags,zk_optmp0

              mov zk_accu,zk_tmp8
              call #\zk_setry

              xor zk_optmp1,zk_optmp0
              bitz zk_flags,#ZK_ZERO_BIT
              testb zk_optmp1,#4 wc
              bitc zk_flags,#ZK_HALF_BIT
              test zk_optmp1,#$180 wc
        _ret_ bitc zk_flags,#ZK_OVER_BIT


zk_neg
              cmp zk_accu,#$80 wz
              bitz zk_flags,#ZK_OVER_BIT
              testb zk_accu,#4 wz
              subr zk_accu,#0 wc
              bitc zk_flags,#ZK_CARRY_BIT
              testb zk_accu,#4 xorz
              bitz zk_flags,#ZK_HALF_BIT
              and zk_accu,#$FF wz
              bitz zk_flags,#ZK_ZERO_BIT
              bith zk_flags,#ZK_NMODE_BIT
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_cpl
              xor zk_accu,#$FF
              or zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_accu

zk_math16
              modc _clr wc
zk_cmath16
              testb zk_flags,#ZK_CARRY_BIT wc

              getword zk_tmp16,zk_debc,#0 ' get BC
              getword zk_tmp16,zk_debc,#1 ' get DE
              mov zk_tmp16,zk_temphl      ' get HL/I*
              mov zk_tmp16,zk_sp          ' get SP

              mov zk_optmp1,zk_temphl
              xor zk_optmp1,zk_tmp16

              addx zk_temphl,zk_tmp16
              bitl zk_flags,#ZK_NMODE_BIT
              subx zk_temphl,zk_tmp16
              bith zk_flags,#ZK_NMODE_BIT

              xor zk_optmp1,zk_temphl
              and zk_temphl,zk_ffffh wz

              bitz zk_flags,#ZK_ZERO_BIT
              test zk_optmp1,zk_18000h wc
              bitc zk_flags,#ZK_OVER_BIT

              getbyte pa,zk_temphl,#1
              setq #ZK_SIGNXYMASK
              setq #ZK_XYMASK
              muxq zk_flags,pa

              testb zk_optmp1,#12 wc
              bitc zk_flags,#ZK_HALF_BIT
              testb zk_optmp1,#16 wc
              bitc zk_flags,#ZK_CARRY_BIT

              add zk_cycles,#7

              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl


zk_daa
              mov zk_optmp0,#$00
              mov zk_tmp8,zk_accu
              cmpr zk_tmp8,#$99 wc
              testb zk_flags,#ZK_CARRY_BIT orc
        if_c  add zk_optmp0,#$60
              bitc zk_flags,#ZK_CARRY_BIT
              getnib zk_optmp1,zk_tmp8,#0
              cmpr zk_optmp1,#$9 wc
              testb zk_flags,#ZK_HALF_BIT orc
        if_c  add zk_optmp0,#$06
              testb zk_flags,#ZK_NMODE_BIT wc
              sumc zk_accu,zk_optmp0
              and zk_accu,#255 wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT ' Parity?
              testb zk_accu,#4 wc
              testb zk_tmp8,#4 xorc
              bitc zk_flags,#ZK_HALF_BIT
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_immlogic
              call #\zk_readcode
zk_logic
              call #\zk_getrz

              and zk_accu,zk_tmp8 wcz
              or zk_accu,zk_tmp8 wcz
              xor zk_accu,zk_tmp8 wcz

              bitnc zk_flags,#ZK_OVER_BIT ' parity
              bitz  zk_flags,#ZK_ZERO_BIT
              andn  zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
              bith  zk_flags,#ZK_HALF_BIT ' Only for AND
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_pushaf
              getbyte zk_tmp16,zk_accu,#0
              rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
              add zk_cycles,#2
zk_pushbc     getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde     getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl     mov zk_tmp16,zk_temphl      ' get HL/I*
              mov zk_tmp16,zk_sp          ' get SP

              jmp #\zk_push16

              add zk_tmp16,#1
              sub zk_tmp16,#1

zk_loadimm16
              call #\zk_readcode16
              mov zk_ea,zk_tmp16   ' for LDs with (imm16)
              call #\zk_read16     ' ^^
              jmp #\zk_write16     ' ^^
zk_poppair
              call #\zk_pop16

        _ret_ setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_ setword zk_debc,zk_tmp16,#1 ' set DE
              altd zk_hlptr
        _ret_ setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

              getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_ getbyte zk_flags,zk_tmp16,#0  ' set F




zk_jr         '' JR and DJNZ
              call #\zk_readcode

              getbyte pa,zk_debc,#1
              sub pa,#1 wz
              setbyte zk_debc,pa,#1
              add zk_cycles,#1

              testb zk_flags,#ZK_ZERO_BIT wz
              testb zk_flags,#ZK_CARRY_BIT wz

              modz _nz wz
        if_z  call #\zk_nextop
              ' branch taken
              add zk_cycles,#5
              signx zk_tmp8,#7
        _ret_ add zk_pc,zk_tmp8

zk_exx    '' EXX
              xor zk_debc,zk_altdebc
              xor zk_altdebc,zk_debc
              xor zk_debc,zk_altdebc
              ' Note: not affected by IX/IY substitution
              xor zk_hl,zk_althl
              xor zk_althl,zk_hl
        _ret_ xor zk_hl,zk_althl

zk_ex_dehl    '' EX DE,HL
              ' Note: not affected by IX/IY substitution
              getword zk_optmp0,zk_debc,#1
              setword zk_debc,zk_hl,#1
        _ret_ mov zk_hl,zk_optmp0


zk_ex_af  '' EX AF,AF'
              xor zk_accu,zk_altaccu
              xor zk_altaccu,zk_accu
              xor zk_accu,zk_altaccu
              xor zk_flags,zk_altflags
              xor zk_altflags,zk_flags
        _ret_ xor zk_flags,zk_altflags

zk_ex_hlstk '' EX (SP),HL
              add zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
              mov zk_ea,zk_sp
              call #\zk_read16
              altd zk_hlptr
              mov 0-0,zk_tmp16
              mov zk_tmp16,zk_temphl
              jmp #\zk_write16

zk_ld_abs16 '' LD HL,(imm16) and LD (imm16),HL
              call #\zk_readcode16
              mov zk_ea,zk_tmp16

              getword zk_tmp16,zk_debc,#0 ' get BC
              getword zk_tmp16,zk_debc,#1 ' get DE
              mov zk_tmp16,zk_temphl ' get HL/I*
              mov zk_tmp16,zk_sp ' get SP
              jmp #\zk_write16

              call #\zk_read16
        _ret_ setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_ setword zk_debc,zk_tmp16,#1 ' set DE
              altd zk_hlptr
        _ret_ mov zk_sp,zk_tmp16


zk_scf
              modc _clr wc
zk_ccf
              testb zk_flags,#ZK_CARRY_BIT wc
              bitnc zk_flags,#ZK_CARRY_BIT
              bitc  zk_flags,#ZK_HALF_BIT
              bitl  zk_flags,#ZK_NMODE_BIT
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_accu

zk_ld_abs    '' LD A,(imm16) and LD (imm16),A
              call #\zk_readcode16
              mov zk_ea,zk_tmp16
zk_a_and_ptr '' A and (BC)/(DE) ops
              getword zk_ea,zk_debc,#0 ' get BC
              getword zk_ea,zk_debc,#1 ' get DE
              call #\zk_read8
        _ret_ mov zk_accu,zk_tmp8
              mov zk_tmp8,zk_accu
              jmp #\zk_write8

zk_regmove
              push #zk_setry
              jmp #\zk_getrz

zk_loadimm8
              push #zk_setry
              jmp #\zk_readcode


zk_halt
              '' TODO
              pollse1 wc
              testb zk_irqenable,#ZK_IFF1_BIT andc
        if_nc incmod zk_refresh,#127
        if_nc jmp #$
              ret



              fit $400


DAT ' ZiKore Z80 init code
              orgh
zk_init
              setq #495
              rdlong 0,##@zk_cogbase
              setq2 #511
              rdlong 0,##@zk_lutbase

              rdbyte zk_romio_zerox,#rom_zerox

              wrword #$100,#zbus_request ' Also z80_reset

              ' Clear RAM
              setq ##(8192/4)-1
              wrlong #0,##@z80_ram

              ' Reset PSG here
              setq #(PSG_SIZE/4)-1
              wrlong #15,##psg_regbase

              rdlong pa,#_clkf
              qdiv pa,##round(PSG_FREQUENCY)
              getqx zk_cycletime
              ' Setup IRQ source
              setse1 #$10+ZINT_LOCK
              setxfrq zk_nco_slow
zk_doreset
              debug("Z80 reset START")
              wrbyte #1,#zbus_status ' bus is unavailable during reset
              mov zk_pc,#0
              'mov zk_accu,#$FF
              'mov zk_flags,#$FF
              'mov zk_sp,##$FFFF
              mov zk_irqenable,#0
              mov zk_irqhook,#0
              mov zk_refresh,#0
              mov zk_refreshhi,#0
              mov zk_ivector,#0
              call #opn_doreset
              debug("Z80 reset DONE")

              ' Wait until reset released...
.wait
              rdbyte pa,#z80_reset wz
        if_nz jmp #.wait
              pollse1
              getct zk_lastwait
              debug("Z80 reset RELEASE ",uhex_byte_array(#@z80_ram+$1B89,#1))
              jmp #zk_nextop

CON ' OPN2Cog constants
PSG_NTSC = 3_579_545.0, PSG_PAL = 3_546_893.0
OPN_NTSC  = 7_670_453.0, OPN_PAL = 7_600_489.0

  PSG_FREQUENCY     = PSG_NTSC   ' Clock frequency input on the emulated PSG chip
  OPN_FREQUENCY     = OPN_NTSC   ' Clock frequency input on the emulated OPN2 chip

  OPN_DISTORTION    =  1 ' Widens the gap between positive and negative samples
                         ' Turn this up to 100 or so for brrrrrrrr

  VOLUME_BALANCE = 0.87 ' Balance between OPN2 and PSG. 1.0 is all OPN2, 0.0 is all PSG

 ' WARNING !!  Don't alter the constants below unless you know what you are doing

  OPN_SAMPLE_RATE           = trunc(OPN_FREQUENCY/float(6*4)) ' Sample rate of OPN2cog
  ' (Each opearator consumes 6 cycles and thus each channel consumes 24 cycles.)
  ' OPN2cog outputs each channel sequentially, just like the real thing
  PSG_SAMPLE_RATE           = trunc(OPN_FREQUENCY/float(6*4*6/3))
  ' PSG is updated thrice every full sample


  OPN_VOLUME_MUL = trunc((float($7F7F)*VOLUME_BALANCE)/float(256+OPN_DISTORTION))

  ' EG magic
  EG_CLOCKDIV = 3 ' EG clock divider on real YM2612
  EG_CALLS_PER_SAMPLE = 12 ' EG Task call count
  EG_CALLS_PER_OP = 3.0 ' How many calls to process one OP
  EG_RATEDIV = ((EG_CALLS_PER_OP*6.0*4.0) / float(EG_CALLS_PER_SAMPLE))/float(EG_CLOCKDIV)
  EG_EXTRABITS = 26-10 ' How many extra bits in level variable. MUST BE 16!!!
  EG_FACTOR = EG_RATEDIV * float(1<<EG_EXTRABITS)



  ' PSG stuff
  VOLUME_CORRECTION = 1.0-VOLUME_BALANCE   ' PSG Volume correction value (0.0 - 1.0)
  OSC_FREQ_CALIBRATION  = trunc((PSG_FREQUENCY/16.0)/float(PSG_SAMPLE_RATE)*(float(1<<22)))          ' Calibration of the oscillator frequency
  MAX_AMPLITUDE         = float($7F7F / 4)                      ' maxInt32value / numberOfChannels (this makes room for maximum "swing" on all channels)
  AMPLITUDE_DAMP_FACTOR = 0.7941                               ' This gives a 2db drop per amplitude level (like the real thing)

  NOISE_TAP = %1001
  NOISE_MSB = 15


  ALG_OP1_FB  = 1 << 0 ' modulate with OP1 out (special case for algo 2)
  ALG_USEACCU = 1 << 1 ' modulate with accu
  ALG_CLRACCU = 1 << 2 ' clear accu
  ALG_ADDACCU = 1 << 3 ' add to accu
  ALG_ADDOUT  = 1 << 4 ' add to output

  #0,EG_ATTACK, EG_DECAY,EG_SUSTAIN,EG_RELEASE



  OP_OFFSET = 8   ' Offset from channel to operators == Size of the per-channel registers
  OP_SIZE = 12    ' Size of an operator
  CH_OFFSET = 24  ' Offset from global registers to channels == Size of the global registers
  CH_SIZE   = OP_OFFSET + 4*OP_SIZE ' Total size of a channel
  OPN_SIZE = 6*CH_SIZE + CH_OFFSET  ' Total OPN2 register count

  PSG_SIZE = 8*4

                     ''
  MATRIX_BASEPIN = 8 '' Uncomment all the places marked with DEBUG_MATRIX and
                     '' 6 of the LEDs become timing indicators that light up when a processing a channel took too long!

CON ' OPN2Cog computed constants

  AMPLITUDE_LEVEL_0 = MAX_AMPLITUDE     * VOLUME_CORRECTION
  AMPLITUDE_LEVEL_1 = AMPLITUDE_LEVEL_0 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_2 = AMPLITUDE_LEVEL_1 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_3 = AMPLITUDE_LEVEL_2 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_4 = AMPLITUDE_LEVEL_3 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_5 = AMPLITUDE_LEVEL_4 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_6 = AMPLITUDE_LEVEL_5 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_7 = AMPLITUDE_LEVEL_6 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_8 = AMPLITUDE_LEVEL_7 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_9 = AMPLITUDE_LEVEL_8 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_A = AMPLITUDE_LEVEL_9 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_B = AMPLITUDE_LEVEL_A * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_C = AMPLITUDE_LEVEL_B * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_D = AMPLITUDE_LEVEL_C * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_E = AMPLITUDE_LEVEL_D * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_F = 0.0

EG_RATE_0 = round(0.0*EG_FACTOR)
EG_RATE_1 = round(0.0*EG_FACTOR)
EG_RATE_2 = round(0.000244140625*EG_FACTOR)
EG_RATE_3 = round(0.000244140625*EG_FACTOR)
EG_RATE_4 = round(0.00048828125*EG_FACTOR)
EG_RATE_5 = round(0.00048828125*EG_FACTOR)
EG_RATE_6 = round(0.000732421875*EG_FACTOR)
EG_RATE_7 = round(0.000732421875*EG_FACTOR)
EG_RATE_8 = round(0.0009765625*EG_FACTOR)
EG_RATE_9 = round(0.001220703125*EG_FACTOR)
EG_RATE_10 = round(0.00146484375*EG_FACTOR)
EG_RATE_11 = round(0.001708984375*EG_FACTOR)
EG_RATE_12 = round(0.001953125*EG_FACTOR)
EG_RATE_13 = round(0.00244140625*EG_FACTOR)
EG_RATE_14 = round(0.0029296875*EG_FACTOR)
EG_RATE_15 = round(0.00341796875*EG_FACTOR)
EG_RATE_16 = round(0.00390625*EG_FACTOR)
EG_RATE_17 = round(0.0048828125*EG_FACTOR)
EG_RATE_18 = round(0.005859375*EG_FACTOR)
EG_RATE_19 = round(0.0068359375*EG_FACTOR)
EG_RATE_20 = round(0.0078125*EG_FACTOR)
EG_RATE_21 = round(0.009765625*EG_FACTOR)
EG_RATE_22 = round(0.01171875*EG_FACTOR)
EG_RATE_23 = round(0.013671875*EG_FACTOR)
EG_RATE_24 = round(0.015625*EG_FACTOR)
EG_RATE_25 = round(0.01953125*EG_FACTOR)
EG_RATE_26 = round(0.0234375*EG_FACTOR)
EG_RATE_27 = round(0.02734375*EG_FACTOR)
EG_RATE_28 = round(0.03125*EG_FACTOR)
EG_RATE_29 = round(0.0390625*EG_FACTOR)
EG_RATE_30 = round(0.046875*EG_FACTOR)
EG_RATE_31 = round(0.0546875*EG_FACTOR)
EG_RATE_32 = round(0.0625*EG_FACTOR)
EG_RATE_33 = round(0.078125*EG_FACTOR)
EG_RATE_34 = round(0.09375*EG_FACTOR)
EG_RATE_35 = round(0.109375*EG_FACTOR)
EG_RATE_36 = round(0.125*EG_FACTOR)
EG_RATE_37 = round(0.15625*EG_FACTOR)
EG_RATE_38 = round(0.1875*EG_FACTOR)
EG_RATE_39 = round(0.21875*EG_FACTOR)
EG_RATE_40 = round(0.25*EG_FACTOR)
EG_RATE_41 = round(0.3125*EG_FACTOR)
EG_RATE_42 = round(0.375*EG_FACTOR)
EG_RATE_43 = round(0.4375*EG_FACTOR)
EG_RATE_44 = round(0.5*EG_FACTOR)
EG_RATE_45 = round(0.625*EG_FACTOR)
EG_RATE_46 = round(0.75*EG_FACTOR)
EG_RATE_47 = round(0.875*EG_FACTOR)
EG_RATE_48 = round(1.0*EG_FACTOR)
EG_RATE_49 = round(1.25*EG_FACTOR)
EG_RATE_50 = round(1.5*EG_FACTOR)
EG_RATE_51 = round(1.75*EG_FACTOR)
EG_RATE_52 = round(2.0*EG_FACTOR)
EG_RATE_53 = round(2.5*EG_FACTOR)
EG_RATE_54 = round(3.0*EG_FACTOR)
EG_RATE_55 = round(3.5*EG_FACTOR)
EG_RATE_56 = round(4.0*EG_FACTOR)
EG_RATE_57 = round(5.0*EG_FACTOR)
EG_RATE_58 = round(6.0*EG_FACTOR)
EG_RATE_59 = round(7.0*EG_FACTOR)
EG_RATE_60 = round(8.0*EG_FACTOR)
EG_RATE_61 = round(8.0*EG_FACTOR)
EG_RATE_62 = round(8.0*EG_FACTOR)
EG_RATE_63 = round(8.0*EG_FACTOR)

DAT ' OPN2Cog init code
              orgh
'===========================================================
'                Assembly OPN2 emulator
'===========================================================
opn_init
              'debug    (udec(leftp,rightp),uhex_long(sampleRate))
              loc      ptrb,#@opn_cogbase
              setq     #502-1
              rdlong   0,ptrb
              add      ptrb,## @opn_lutbase - @opn_cogbase
              setq2    #511
              rdlong   0,ptrb

              rdlong opn_arg2,#_clkf
              qdiv opn_arg2,##OPN_SAMPLE_RATE
              mov opn_leftp,#AUDIO_LEFT
              mov opn_rightp,#AUDIO_RIGHT
              getqx opn_sampleRate
              test opn_sampleRate,#255 wz
        if_z  mov opn_arg1,##P_DAC_75R_2V|P_OE|P_DAC_DITHER_PWM
        if_nz mov opn_arg1,##P_DAC_75R_2V|P_OE|P_DAC_DITHER_RND


              fltl     opn_leftp
              fltl     opn_rightp
              wrpin    opn_arg1,opn_leftp
              wrpin    opn_arg1,opn_rightp
              wxpin    opn_sampleRate,opn_leftp
              wxpin    opn_sampleRate,opn_rightp
              wypin    opn_dac_center,opn_leftp
              wypin    opn_dac_center,opn_rightp

              'debug(` TERM EGterm pos 10 10 title 'Envelope Parameters' SIZE 50 26 TEXTSIZE 15 UPDATE)
              'debug(` TERM OPterm pos 600 10 title 'Operator Parameters' SIZE 32 26 TEXTSIZE 15 UPDATE)
              'debug(` TERM CHterm pos 600 670 title 'Channel Parameters' SIZE 32 8 TEXTSIZE 20 UPDATE)
              'debug(` SCOPE Escope pos 0 650 title 'Envelope Scope' SIZE 512 256 TEXTSIZE 20)

              mov pb,##opn_eg_start


              'drvh    #MATRIX_BASEPIN ' DEBUG_MATRIX: prepare LED matrix board

              drvh     opn_leftp
              drvh     opn_rightp

              jmp #\opn_mainLoop


DAT ' OPN2Cog COG/LUT resident code


              org 0
'===========================================================
'                Main Loop
'===========================================================
opn_cogbase
opn_mainLoop

              ' reset register pointer
              rdfast #0,OPN_Address
              ' reload globals
              rflong gl_dacval_dacen_lfo_bfreq

              rflong gl_ch3_kcodes_mode

              rfbyte ch3_op1_detune
              rfbyte ch3_op2_detune
              rfbyte ch3_op3_detune

              rfbyte opn_tempValue ' skip pad byte

              rfword gl_ch3_op1freq
              rfword gl_ch3_op2freq
              rflong gl_ch3_op3freq_afreq
              rflong gl_keyon

              ' reset some counters
              mov opn_current_slot,#0
              mov fb_1to2_alti,fb_1to2_alti_base
              mov op_levels_alti,op_levels_alti_base

              ' handle key-ons
              mov opn_tempValue,gl_keyon
              xor opn_tempValue,prev_keyon
              and opn_tempValue,gl_keyon
              mov prev_keyon,gl_keyon
              or pending_keyon,opn_tempValue


              ' Update LFO
              getnib opn_arg1,gl_dacval_dacen_lfo_bfreq,#4 ' get LFO register
              bitl opn_arg1,#3 wcz ' LFO enable bit
        if_nc mov lfo_phase,#0
        if_nc mov lfo_subcount,#0
        if_nc mov lfo_am,#0
        if_nc mov lfo_fm,#0
        if_nc waitx #12*2 ' equivalent timing for stability
        if_nc jmp #.nolfo

              alts opn_arg1,#lfo_rate_tbl
              decmod lfo_subcount,0-0 wc
        if_c  incmod lfo_phase,#$7F
              mov lfo_am,lfo_phase
              testb lfo_am,#6 wz
        if_z  xor lfo_am,#$7F
              shl lfo_am,#1+2 ' +1 so we can use SHR to compute ch_am, +2 because when we add to the attenutation, it is already 0..$FFF
              mov lfo_fm,lfo_phase
              shr lfo_fm,#2
              testb lfo_phase,#3+2 wc
              and lfo_fm,#7
        if_c  xor lfo_fm,#7
              shl lfo_fm,#3 ' so we can just OR with the sensitivity to get a table index
              ' No LFO sign here, just test lfo_phase bit 4+2

.nolfo
              ' Update timers
              testb gl_ch3_kcodes_mode,#24+0 wz ' Timer A load flag
              incmod timerA_count,timerA_max wc
    if_nz_or_c getword timerA_count,gl_ch3_op3freq_afreq,#1
              testb gl_ch3_kcodes_mode,#24+2 andc ' Timer A enable flag
    if_c_and_z wrbyte #1,#opn_timerAflag
              testb gl_ch3_kcodes_mode,#24+1 wz ' Timer B load flag
              incmod timerB_count,timerB_max wc
    if_nz_or_c getbyte timerB_count,gl_dacval_dacen_lfo_bfreq,#3
    if_nz_or_c shl timerB_count,#4
              testb gl_ch3_kcodes_mode,#24+3 andc ' Timer B enable flag
    if_c_and_z wrbyte #1,#opn_timerBflag



              'debug(`CHterm UPDATE 0 9 ' P A  FRQ          K'  13)
              'debug(`OPterm UPDATE 0 9 '   D  L M'  13)

opn_chLoop    ' Channel loop

              mov ch_out,#0 ' reset output accu

              calld eg_return,pb wcz
              calld eg_return,pb wcz

              ' Run some extra tasks.
              jmprel opn_current_ch
              jmp #opn_task_done ' No extra task for Channel 1 (already reloads globals and runs LFO)
              jmp #psg_run   ' Run PSG in Channel 2
              jmp #opn_task_done ' No extra task for Channel 3 (special mode takes all the cycles)
              jmp #psg_run   ' Run PSG in Channel 4
              jmp #psg_load  ' Load PSG in Channel 5
              jmp #psg_run   ' Run PSG in Channel 6

opn_task_done
              ' load channel registers

              rflong ch_freq_algo_pan
              rfword opn_tempValue ' kcode (don't care)
              rfword ch_am_enable
              'debug(`CHterm 'CH `(current_ch)' 9 '`uhex_long_(ch_freq_algo_pan) `uhex_long_(ch_keycode)' 13)




              ' Compute LFO AM for this channel
              mov ch_lfoam_level,lfo_am
              getnib opn_arg1,ch_freq_algo_pan,#7
              and opn_arg1,#3
              alts opn_arg1,#lfo_am_shift_tbl
              shr ch_lfoam_level,0-0

              ' Prepare LFO FM for this channel
              getnib opn_arg1, ch_freq_algo_pan,#6
              or opn_arg1,lfo_fm ' FM mul table index
              altgw opn_arg1,#lfo_fm_mul_tbl
              getword ch_lfofm_muls
              testb lfo_phase,#4+2 wc
              negc ch_lfofm_muls

              ' lookup algorithm bitfield
              getbyte opn_arg1,ch_freq_algo_pan,#2
              and opn_arg1,#7
              add opn_arg1,#algo_tbl-512
              rdlut ch_algobits,opn_arg1

              mov oploop_ptr,#opn_opLoop
              sets opn_detune_selfmod,#op_detune

              cmp opn_current_ch,#3-1 wz
              testb gl_ch3_kcodes_mode,#24+6 andz
        if_nz callpa ch_freq_algo_pan,#opn_eval_freq
        if_nz jmp #opn_opLoop

              ' Handle CH3 special mode
              mov oploop_ptr,#opn_opLoop_ch3special
              sets opn_detune_selfmod,#ch3_op1_detune - 1
opn_opLoop_ch3special
              altd opn_current_op,#gl_ch3_op1freq
              callpa 0-0,#opn_eval_freq

              add opn_detune_selfmod,#1


opn_opLoop    ' Operator loop


              ' load operator registers
              rfword op_mul_tl
              rfword op_detune
              rflong opn_tempValue
              rflong opn_tempValue

              'debug(`OPterm 'OP `(current_slot)' 9 '`uhex_long_(op_mul_tl_dtc)' 13)

              'debug(udec(current_ch,current_op,current_slot))


              mov phase_mod,#0
              test ch_algobits,#ALG_USEACCU wc
        if_c  add phase_mod,op_accu

'{
              tjz opn_current_op,#opn_op1fb ' Feedback code is outlined. Saves 6 cycles per chan, yay!
              test ch_algobits,#ALG_OP1_FB wc ' Algorithm 2 needs to read the feedback reg....
        if_c  alts opn_current_ch,#ch_feedback1
        if_c  add phase_mod,0-0
opn_op1fbdone
                 '}

              mov op_actfreq,ch_actfreq

              ' detune
              testb  op_mul_tl,#4+2 wc ' detune sign
opn_detune_selfmod
              sumc op_actfreq,op_detune

              ' multiply
              getnib opn_arg1,op_mul_tl,#0
              shl opn_arg1,#1 wz
        if_z  mov opn_arg1,#1
              mul op_actfreq,opn_arg1

              ' get phase and accumulate
              alts opn_current_slot,#op_phase
              mov cur_phase,0-0
              altd opn_current_slot,#op_phase
              add 0-0,op_actfreq

              ' Add modulation
              shr cur_phase,#10
              add cur_phase,phase_mod

              ' Compute attenuation level
              getbyte opn_tempValue,op_mul_tl,#1 ' get TL
              shl opn_tempValue,#5
              alti op_levels_alti,#%100_111_000
              add cur_level,opn_tempValue

              ' Add LFO AM
              testb ch_am_enable,opn_current_op wc
        if_c  add cur_level,ch_lfoam_level

              fle  cur_level,opn_conFFF

              ' Lookup phase in logsin ROM
              testb     cur_phase,#8 wz
              testb     cur_phase,#9 wc
              and       cur_phase,#255
        if_z  xor       cur_phase,#255
              rdlut     opn_tempValue,cur_phase
              getword   opn_tempValue,opn_tempValue,#0 ' get sin value!!
              add       opn_tempValue,cur_level ' apply volume!!
              'fle       tempValue,maxexp  '< impossible, so don't bother

              ' Convert to linear
              getbyte   opn_tempValue2,opn_tempValue,#1
              getbyte   opn_tempValue,opn_tempValue,#0
              rdlut     opn_tempValue,opn_tempValue
              getword   opn_arg1,opn_tempValue,#1 ' get exp value
              shr       opn_arg1,opn_tempValue2
              ' C still is bit 9 of phase...


              ' Do stuff with the output
              tjnz opn_current_op,#.notfbset
              altd opn_current_ch,#ch_feedback1
              negc 0-0, opn_arg1
.notfbset
              test ch_algobits,#ALG_CLRACCU wz
        if_nz negc op_accu,#0
              test ch_algobits,#ALG_ADDACCU wz
        if_nz sumc op_accu,opn_arg1

              shr    opn_arg1,#4 ' Reduce to 9 bit (sign bit still in C)

              test ch_algobits,#ALG_ADDOUT wz
        if_nz sumc ch_out,opn_arg1

              ' clamp (has to be per-op! i think...)
              fles ch_out,#255
              fges ch_out,opn_clamp_min

              add opn_current_slot,#1
              shr ch_algobits,#8
              incmod opn_current_op,#4-1 wc
        if_nc jmp oploop_ptr


              ' Handle CH6 DAC mode
              cmp opn_current_ch,#6-1 wz
        if_ne jmp #.notch6
              testb     gl_dacval_dacen_lfo_bfreq,#15 wz
        if_z  getbyte   ch_out,gl_dacval_dacen_lfo_bfreq,#0
        if_z  xor       ch_out,#$80
        if_z  signx     ch_out,#7
        if_z  shl       ch_out,#1
.notch6

              ' Debug: channel mute
              testb opn_muteChannels,opn_current_ch wc
        if_c  mov ch_out,#0

              call #do_output ' <--- DAC pin write here

              incmod opn_current_ch,#6-1 wc
        if_nc jmp #opn_chLoop




              jmp #opn_mainLoop



opn_op1fb
              ' OP1 feedback handling
              ' down here for speed
              alts opn_current_ch,#ch_feedback2
              mov opn_tempValue,0-0
              alts opn_current_ch,#ch_feedback1
              add opn_tempValue,0-0
              alti fb_1to2_alti ,#%000_111_111
              mov 0-0,0-0

              getbyte opn_tempValue2,ch_freq_algo_pan,#2
              shr opn_tempValue2,#3 wz
              shl opn_tempValue,opn_tempValue2
              sar opn_tempValue,#10-1
        if_nz add phase_mod,opn_tempValue

              jmp #opn_op1fbdone

opn_eval_freq
              ' Compute LFO FM for this channel
              getword ch_lfofm_offset,pa,#0
              shr ch_lfofm_offset,#4
              and ch_lfofm_offset,#$7F ' top 7 bits of fnum

              muls ch_lfofm_offset,ch_lfofm_muls
              shr ch_lfofm_offset,#7+2+1


              ' Get frequency
              getword ch_actfreq,pa,#0 ' get frequency
              add ch_actfreq,ch_lfofm_offset ' Apply LFO FM
              zerox ch_actfreq,#10 ' just fnum

              getword opn_arg1,pa,#0
              shr opn_arg1,#11 ' get fblock

              shl ch_actfreq,opn_arg1
        _ret_ shr ch_actfreq,#2' got actual base frequency



' Parameters
' ----------
opn_muteChannels        long 0'%111_111
opn_leftp               long 0
opn_rightp              long 0
opn_arg1                long 0 ' has DAC mode at startup, is reused as temp var
opn_sampleRate          long 0
opn_lpf_sar             long 3

' Constants
' ---------
opn_dac_center          long $7F80
opn_conFFF              long $FFF
opn_clamp_min           long -256
timerA_max              long $3FF
timerB_max              long $FFF ' timer B is prescaled by 16
'opn_maxexp             long $1FFF
eg_max                  long $3FF << EG_EXTRABITS
ssg_eg_threshold        long $200 << EG_EXTRABITS
psg_oscSubValue         long OSC_FREQ_CALIBRATION
psg_noiseSubValue       long OSC_FREQ_CALIBRATION >> 1
opn_distortconst        long OPN_DISTORTION*OPN_VOLUME_MUL

OPN_Address             long @opn_regbase



' intialized temp
' ---------------
opn_current_ch          long 0
opn_current_op          long 0
opn_current_slot        long 0 ' OP+CH*4
eg_slot                 long 0
psg_out                 long $7F80
opn_filter_left         long 0
opn_filter_right        long 0


' OPN2 internal state
' -------------------
op_phase                long 0[4*6]
eg_state_b              byte EG_RELEASE[4*6]
eg_levels               long ($3FF << EG_EXTRABITS)[4*6] ' EG internal levels (0 to eg_max)
op_levels               long $FFF[4*6] ' Effective levels (0 to FFF).
                        long 0[(4-($&3))&3] ' align buffer
eg_levelbuffer          long ($3FF << EG_EXTRABITS)[4] ' temp buffer for EG. must be 4-aligned
ch_feedback1            long 0[6] ' Feedback buffer stage 1 \ OP1 output is continously clocked through
ch_feedback2            long 0[6] ' Feedback buffer stage 2 / and the average of both stages is used for modultation
prev_keyon              long 0
pending_keyon           long 0
ssgeg_repeat            long 0
ssgeg_invert            long 0
lfo_phase               long 0
lfo_subcount            long 0
timerA_count            long 0
timerB_count            long 0

' ALTI base values
' ----------------
fb_1to2_alti_base       long (ch_feedback2<<9) + ch_feedback1
eg_levb_alti_base       long (eg_levelbuffer<<19) + (op_levels<<9) + eg_levelbuffer
op_levels_alti_base long (cur_level<<19) + (op_levels<<9)
eg_levb_write           long %111_000_111__111_000_000
eg_levb_transfer        long %111_000_111__000_111_111

' PSG internal state
' ------------------
psg_oscState1       long 1
psg_oscState2       long 1
psg_oscState3       long 1
psg_oscStateN       long 1
psg_out1            long 0
psg_out2            long 0
psg_out3            long 0
psg_outN            long 0
psg_noiseValue      long 1 << NOISE_MSB
psg_oscCounter1     long 0
psg_oscCounter2     long 0
psg_oscCounter3     long 0
psg_oscCounterN     long 0


' PSG registers (initialized to avoid click)
' -------------
psg_frequency1      long 0
psg_amplitude1      long 15
psg_frequency2      long 0
psg_amplitude2      long 15
psg_frequency3      long 0
psg_amplitude3      long 15
psg_noiseFeedback   long 0
psg_amplitudeN      long 15


eg_rate_mantissa_tbl byte
byte EG_RATE_0>>(((encod EG_RATE_0)-7)#>0)
byte EG_RATE_1>>(((encod EG_RATE_1)-7)#>0)
byte EG_RATE_2>>(((encod EG_RATE_2)-7)#>0)
byte EG_RATE_3>>(((encod EG_RATE_3)-7)#>0)
byte EG_RATE_4>>(((encod EG_RATE_4)-7)#>0)
byte EG_RATE_5>>(((encod EG_RATE_5)-7)#>0)
byte EG_RATE_6>>(((encod EG_RATE_6)-7)#>0)
byte EG_RATE_7>>(((encod EG_RATE_7)-7)#>0)
byte EG_RATE_8>>(((encod EG_RATE_8)-7)#>0)
byte EG_RATE_9>>(((encod EG_RATE_9)-7)#>0)
byte EG_RATE_10>>(((encod EG_RATE_10)-7)#>0)
byte EG_RATE_11>>(((encod EG_RATE_11)-7)#>0)
byte EG_RATE_12>>(((encod EG_RATE_12)-7)#>0)
byte EG_RATE_13>>(((encod EG_RATE_13)-7)#>0)
byte EG_RATE_14>>(((encod EG_RATE_14)-7)#>0)
byte EG_RATE_15>>(((encod EG_RATE_15)-7)#>0)
byte EG_RATE_16>>(((encod EG_RATE_16)-7)#>0)
byte EG_RATE_17>>(((encod EG_RATE_17)-7)#>0)
byte EG_RATE_18>>(((encod EG_RATE_18)-7)#>0)
byte EG_RATE_19>>(((encod EG_RATE_19)-7)#>0)
byte EG_RATE_20>>(((encod EG_RATE_20)-7)#>0)
byte EG_RATE_21>>(((encod EG_RATE_21)-7)#>0)
byte EG_RATE_22>>(((encod EG_RATE_22)-7)#>0)
byte EG_RATE_23>>(((encod EG_RATE_23)-7)#>0)
byte EG_RATE_24>>(((encod EG_RATE_24)-7)#>0)
byte EG_RATE_25>>(((encod EG_RATE_25)-7)#>0)
byte EG_RATE_26>>(((encod EG_RATE_26)-7)#>0)
byte EG_RATE_27>>(((encod EG_RATE_27)-7)#>0)
byte EG_RATE_28>>(((encod EG_RATE_28)-7)#>0)
byte EG_RATE_29>>(((encod EG_RATE_29)-7)#>0)
byte EG_RATE_30>>(((encod EG_RATE_30)-7)#>0)
byte EG_RATE_31>>(((encod EG_RATE_31)-7)#>0)
byte EG_RATE_32>>(((encod EG_RATE_32)-7)#>0)
byte EG_RATE_33>>(((encod EG_RATE_33)-7)#>0)
byte EG_RATE_34>>(((encod EG_RATE_34)-7)#>0)
byte EG_RATE_35>>(((encod EG_RATE_35)-7)#>0)
byte EG_RATE_36>>(((encod EG_RATE_36)-7)#>0)
byte EG_RATE_37>>(((encod EG_RATE_37)-7)#>0)
byte EG_RATE_38>>(((encod EG_RATE_38)-7)#>0)
byte EG_RATE_39>>(((encod EG_RATE_39)-7)#>0)
byte EG_RATE_40>>(((encod EG_RATE_40)-7)#>0)
byte EG_RATE_41>>(((encod EG_RATE_41)-7)#>0)
byte EG_RATE_42>>(((encod EG_RATE_42)-7)#>0)
byte EG_RATE_43>>(((encod EG_RATE_43)-7)#>0)
byte EG_RATE_44>>(((encod EG_RATE_44)-7)#>0)
byte EG_RATE_45>>(((encod EG_RATE_45)-7)#>0)
byte EG_RATE_46>>(((encod EG_RATE_46)-7)#>0)
byte EG_RATE_47>>(((encod EG_RATE_47)-7)#>0)
byte EG_RATE_48>>(((encod EG_RATE_48)-7)#>0)
byte EG_RATE_49>>(((encod EG_RATE_49)-7)#>0)
byte EG_RATE_50>>(((encod EG_RATE_50)-7)#>0)
byte EG_RATE_51>>(((encod EG_RATE_51)-7)#>0)
byte EG_RATE_52>>(((encod EG_RATE_52)-7)#>0)
byte EG_RATE_53>>(((encod EG_RATE_53)-7)#>0)
byte EG_RATE_54>>(((encod EG_RATE_54)-7)#>0)
byte EG_RATE_55>>(((encod EG_RATE_55)-7)#>0)
byte EG_RATE_56>>(((encod EG_RATE_56)-7)#>0)
byte EG_RATE_57>>(((encod EG_RATE_57)-7)#>0)
byte EG_RATE_58>>(((encod EG_RATE_58)-7)#>0)
byte EG_RATE_59>>(((encod EG_RATE_59)-7)#>0)
byte EG_RATE_60>>(((encod EG_RATE_60)-7)#>0)
byte EG_RATE_61>>(((encod EG_RATE_61)-7)#>0)
byte EG_RATE_62>>(((encod EG_RATE_62)-7)#>0)
byte EG_RATE_63>>(((encod EG_RATE_63)-7)#>0)

eg_rate_shift_tbl byte
byte ((encod EG_RATE_0)-7)#>0
byte ((encod EG_RATE_1)-7)#>0
byte ((encod EG_RATE_2)-7)#>0
byte ((encod EG_RATE_3)-7)#>0
byte ((encod EG_RATE_4)-7)#>0
byte ((encod EG_RATE_5)-7)#>0
byte ((encod EG_RATE_6)-7)#>0
byte ((encod EG_RATE_7)-7)#>0
byte ((encod EG_RATE_8)-7)#>0
byte ((encod EG_RATE_9)-7)#>0
byte ((encod EG_RATE_10)-7)#>0
byte ((encod EG_RATE_11)-7)#>0
byte ((encod EG_RATE_12)-7)#>0
byte ((encod EG_RATE_13)-7)#>0
byte ((encod EG_RATE_14)-7)#>0
byte ((encod EG_RATE_15)-7)#>0
byte ((encod EG_RATE_16)-7)#>0
byte ((encod EG_RATE_17)-7)#>0
byte ((encod EG_RATE_18)-7)#>0
byte ((encod EG_RATE_19)-7)#>0
byte ((encod EG_RATE_20)-7)#>0
byte ((encod EG_RATE_21)-7)#>0
byte ((encod EG_RATE_22)-7)#>0
byte ((encod EG_RATE_23)-7)#>0
byte ((encod EG_RATE_24)-7)#>0
byte ((encod EG_RATE_25)-7)#>0
byte ((encod EG_RATE_26)-7)#>0
byte ((encod EG_RATE_27)-7)#>0
byte ((encod EG_RATE_28)-7)#>0
byte ((encod EG_RATE_29)-7)#>0
byte ((encod EG_RATE_30)-7)#>0
byte ((encod EG_RATE_31)-7)#>0
byte ((encod EG_RATE_32)-7)#>0
byte ((encod EG_RATE_33)-7)#>0
byte ((encod EG_RATE_34)-7)#>0
byte ((encod EG_RATE_35)-7)#>0
byte ((encod EG_RATE_36)-7)#>0
byte ((encod EG_RATE_37)-7)#>0
byte ((encod EG_RATE_38)-7)#>0
byte ((encod EG_RATE_39)-7)#>0
byte ((encod EG_RATE_40)-7)#>0
byte ((encod EG_RATE_41)-7)#>0
byte ((encod EG_RATE_42)-7)#>0
byte ((encod EG_RATE_43)-7)#>0
byte ((encod EG_RATE_44)-7)#>0
byte ((encod EG_RATE_45)-7)#>0
byte ((encod EG_RATE_46)-7)#>0
byte ((encod EG_RATE_47)-7)#>0
byte ((encod EG_RATE_48)-7)#>0
byte ((encod EG_RATE_49)-7)#>0
byte ((encod EG_RATE_50)-7)#>0
byte ((encod EG_RATE_51)-7)#>0
byte ((encod EG_RATE_52)-7)#>0
byte ((encod EG_RATE_53)-7)#>0
byte ((encod EG_RATE_54)-7)#>0
byte ((encod EG_RATE_55)-7)#>0
byte ((encod EG_RATE_56)-7)#>0
byte ((encod EG_RATE_57)-7)#>0
byte ((encod EG_RATE_58)-7)#>0
byte ((encod EG_RATE_59)-7)#>0
byte ((encod EG_RATE_60)-7)#>0
byte ((encod EG_RATE_61)-7)#>0
byte ((encod EG_RATE_62)-7)#>0
byte ((encod EG_RATE_63)-7)#>0

lfo_rate_tbl long 108, 77, 71, 67, 62, 44, 8, 5

lfo_am_shift_tbl long 7,3,1,0

lfo_fm_mul_tbl word
word   2 ' Sens 0 val 0
word   2 ' Sens 1 val 0
word   2 ' Sens 2 val 0
word   2 ' Sens 3 val 0
word   2 ' Sens 4 val 0
word   2 ' Sens 5 val 0
word   4 ' Sens 6 val 0
word   8 ' Sens 7 val 0
word   2 ' Sens 0 val 1
word   2 ' Sens 1 val 1
word   2 ' Sens 2 val 1
word   2 ' Sens 3 val 1
word   2 ' Sens 4 val 1
word   2 ' Sens 5 val 1
word   4 ' Sens 6 val 1
word   8 ' Sens 7 val 1
word   2 ' Sens 0 val 2
word   2 ' Sens 1 val 2
word   2 ' Sens 2 val 2
word  33 ' Sens 3 val 2
word  33 ' Sens 4 val 2
word  65 ' Sens 5 val 2
word 130 ' Sens 6 val 2
word 260 ' Sens 7 val 2
word   2 ' Sens 0 val 3
word   2 ' Sens 1 val 3
word  33 ' Sens 2 val 3
word  33 ' Sens 3 val 3
word  65 ' Sens 4 val 3
word  96 ' Sens 5 val 3
word 192 ' Sens 6 val 3
word 384 ' Sens 7 val 3
word   2 ' Sens 0 val 4
word  33 ' Sens 1 val 4
word  33 ' Sens 2 val 4
word  65 ' Sens 3 val 4
word  65 ' Sens 4 val 4
word 129 ' Sens 5 val 4
word 258 ' Sens 6 val 4
word 516 ' Sens 7 val 4
word   2 ' Sens 0 val 5
word  33 ' Sens 1 val 5
word  33 ' Sens 2 val 5
word  65 ' Sens 3 val 5
word  65 ' Sens 4 val 5
word 129 ' Sens 5 val 5
word 258 ' Sens 6 val 5
word 516 ' Sens 7 val 5
word   2 ' Sens 0 val 6
word  33 ' Sens 1 val 6
word  65 ' Sens 2 val 6
word  96 ' Sens 3 val 6
word  96 ' Sens 4 val 6
word 160 ' Sens 5 val 6
word 320 ' Sens 6 val 6
word 640 ' Sens 7 val 6
word   2 ' Sens 0 val 7
word  33 ' Sens 1 val 7
word  65 ' Sens 2 val 7
word  96 ' Sens 3 val 7
word 129 ' Sens 4 val 7
word 192 ' Sens 5 val 7
word 384 ' Sens 6 val 7
word 768 ' Sens 7 val 7


psg_amplitudeTable  long trunc(AMPLITUDE_LEVEL_0)
                    long trunc(AMPLITUDE_LEVEL_1)
                    long trunc(AMPLITUDE_LEVEL_2)
                    long trunc(AMPLITUDE_LEVEL_3)
                    long trunc(AMPLITUDE_LEVEL_4)
                    long trunc(AMPLITUDE_LEVEL_5)
                    long trunc(AMPLITUDE_LEVEL_6)
                    long trunc(AMPLITUDE_LEVEL_7)
                    long trunc(AMPLITUDE_LEVEL_8)
                    long trunc(AMPLITUDE_LEVEL_9)
                    long trunc(AMPLITUDE_LEVEL_A)
                    long trunc(AMPLITUDE_LEVEL_B)
                    long trunc(AMPLITUDE_LEVEL_C)
                    long trunc(AMPLITUDE_LEVEL_D)
                    long trunc(AMPLITUDE_LEVEL_E)
                    long trunc(AMPLITUDE_LEVEL_F)



opn_arg2                res 1
opn_arg3                res 1

' OPN2 global/channel regs
' ------------------------
gl_dacval_dacen_lfo_bfreq res 1
gl_ch3_kcodes_mode        res 1
' \/ The order of these 4 is important (CH3 special mode) \/
gl_ch3_op1freq            res 1
gl_ch3_op2freq            res 1
gl_ch3_op3freq_afreq      res 1
ch_freq_algo_pan          res 1

gl_keyon                  res 1
ch_am_enable              res 1

' OPN2 current operator regs
' --------------------------
op_mul_tl               res 1


' OPN2 current EG operator regs
' -----------------------------
opn_tempValue3          res 1 ' here so it can get overwritten when the EG reads operator data
eg_ar_dr_sr_rr          res 1
eg_rs_sl_ssgeg          res 1

' OPN2 temporary
' --------------
op_accu                 res 1
ch_out                  res 1
ch_algobits             res 1
cur_level               res 1
eg_oplevel              res 1
eg_opstate              res 1
ch_actfreq              res 1
op_actfreq              res 1
cur_phase               res 1
phase_mod               res 1
eg_pending_keyon        res 1
eg_keyon                res 1
eg_op_keyonoff          res 1
eg_kcode                res 1
lfo_am                  res 1
lfo_fm                  res 1
ch_lfoam_level          res 1
ch_lfofm_offset         res 1
eg_rate                 res 1
fb_1to2_alti            res 1
eg_levb_alti            res 1
op_levels_alti          res 1
oploop_ptr              res 1
ch_lfofm_muls           res 1
' \/ order of these is important
ch3_op1_detune          res 1
ch3_op2_detune          res 1
ch3_op3_detune          res 1
op_detune               res 1


' PSG temporary
' -------------
psg_noiseFreq       res  1

' other gunk
' ----------
eg_return           res  1
opn_tempValue       res  1
opn_tempValue2      res  1


                    fit 502 ' Doesn't use interrupts, so their addresses may be reused

'===========================================================
'    LUT stuff
'===========================================================
                        org $200
opn_lutbase
opn_sinexp_tab          file "OPN2_ROM.DAT" ' Quarter sine and exponent ROM, interleaved.
                                            ' See romgen.rb for more details.
''
''
''
algo_tbl byte
'' Algorithm 0:
''
'' 1->2->3->4->
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 1:
''
'' 1-+
''   +->3->4->
'' 2-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 2:
''
'' 1----+
''      +->4->
'' 2->3-+
''
byte ALG_CLRACCU
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT + ALG_OP1_FB
'' Algorithm 3:
''
'' 1->2-+
''      +->4->
'' 3----+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 4:
''
'' 1->2-+
''      +->
'' 3->4-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 5:
''
''   +->2-+
'' 1-+->3-+->
''   +->4-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 6:
''
'' 1->2-+
''    3-+->
''    4-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_ADDOUT
byte ALG_ADDOUT
'' Algorithm 7:
'' 1-+
'' 2-+
'' 3-+->
'' 4-+
''
byte ALG_ADDOUT
byte ALG_ADDOUT
byte ALG_ADDOUT
byte ALG_ADDOUT
''
''
''

'===========================================================
'    Output current channel's sample
'===========================================================
do_output
              ' YM2612 output distortion (gap between -1 and 0)
              abs       ch_out  wc
              fle       ch_out,#256
              mul       ch_out,#OPN_VOLUME_MUL ' OPN2 volume!

              neg       opn_arg1,opn_filter_left
              neg       opn_arg2,opn_filter_right

              testb     ch_freq_algo_pan,#31 wz ' left pan bit
        if_z  sumc      opn_arg1,ch_out
              sumc      opn_arg1,opn_distortconst
              testb     ch_freq_algo_pan,#30 wz ' right pan bit
        if_z  sumc      opn_arg2,ch_out
              sumc      opn_arg2,opn_distortconst

              ' apply low-pass filter and mix PSG
              sar       opn_arg1,opn_lpf_sar
              add       opn_filter_left,opn_arg1

              sar       opn_arg2,opn_lpf_sar
              add       opn_filter_right,opn_arg2

              mov       opn_arg1,psg_out
              mov       opn_arg2,psg_out
              add       opn_arg1,opn_filter_left
              add       opn_arg2,opn_filter_right

              { ' DEBUG_MATRIX
              mov tempValue,#MATRIX_BASEPIN+1
              add tempValue,current_ch
              testp    rightp   wc
        if_c  drvl tempValue 'Took too long!
        'if_nc fltl tempValue
              '}

              ' wait for DAC cycle
              testp    opn_rightp wc
  if_nc       jmp #$-1
              wypin      opn_arg1,opn_leftp
       _ret_  wypin      opn_arg2,opn_rightp


'===========================================================
'    Envelope Generator (EG) section
'===========================================================
opn_eg_start
              mov ptrb,OPN_Address
              add ptrb,#CH_OFFSET
              mov eg_levb_alti,eg_levb_alti_base

              'debug(`EGterm UPDATE 0 9 ' R S  D A   SSG  K L  `uhex_long_(OPN_Address)' 13)
opn_eg_chloop
              rdbyte eg_kcode,ptrb[4]
              add ptrb,#OP_OFFSET
              mov eg_pending_keyon,pending_keyon ' buffer this to avoid partially keying a channel
              mov eg_keyon,gl_keyon

opn_eg_loop

              ' load parameters
              setq #2
              rdlong opn_tempValue3,ptrb++


              calld pb,eg_return

              'mov eg_ar_dr_sr_rr,##$3F_10_1A_31

              ' get current level/state
              alts eg_slot,#eg_levels
              mov eg_oplevel,0-0
              altgb eg_slot,#eg_state_b
              getbyte eg_opstate

              'setbyte eg_rs_sl_ssgeg,#0,#2

              ' Handle SSG-EG
              cmp eg_oplevel,ssg_eg_threshold wc ' SSG-EG only runs when level is over $200...
              testb eg_rs_sl_ssgeg,#16 + 3 wz ' and of course only when it's actually on
   if_c_or_nz waitx #2*(9-1) ' Stablize timing
   if_c_or_nz jmp #.no_ssg_eg

              testb eg_rs_sl_ssgeg,#16 + 0 wc ' Is hold mode? 1/3/5/7 (otherwise, continuous mode)
              ' Handle invert state
        if_c  testb eg_rs_sl_ssgeg,#16 + 2 wz
        if_nc testb ssgeg_invert,eg_slot wz
              testb eg_rs_sl_ssgeg,#16 + 1 xorz
              bitz ssgeg_invert,eg_slot

              cmp eg_opstate,#EG_ATTACK wz
              ' Handle hold
         if_c testb eg_rs_sl_ssgeg,#16 + 1 orz
  if_c_and_nz mov eg_oplevel,eg_max
              ' Handle restart
 if_nc_and_nz cmp eg_opstate,#EG_RELEASE wz
 if_nc_and_nz bith ssgeg_repeat,eg_slot

.no_ssg_eg


              testb eg_pending_keyon,eg_slot wc
              testb ssgeg_repeat,eg_slot orc
              testb eg_keyon,eg_slot wz
              rczl eg_op_keyonoff ' bit 0 is now keyon state and bit 1 is now pending keyon
         if_c bitl pending_keyon,eg_slot


              calld pb,eg_return


              ' if key on/off
        if_c  mov eg_opstate,#EG_ATTACK
        if_c  altd eg_slot,#op_phase
        if_c  mov 0-0,#0 ' reset phase
        if_nz mov eg_opstate,#EG_RELEASE


              ' Set SSG-EG invert on actual key-on only
        if_c  bitl ssgeg_repeat,eg_slot wcz

        if_nz  testb eg_rs_sl_ssgeg,#16 + 3 wc
        if_nz  testb eg_rs_sl_ssgeg,#16 + 2 andc
        if_nz  bitc ssgeg_invert,eg_slot

              ' Handle release for SSG-EG
              cmp eg_opstate,#EG_RELEASE wz
              testb eg_rs_sl_ssgeg,#16 + 3 andz
        if_z  mov eg_oplevel,eg_max
        if_z  bitl ssgeg_invert,eg_slot


              ' transition ATTACK to DECAY when max amplitude reached
              cmp eg_opstate,#EG_ATTACK wz
        if_z  cmp eg_oplevel,#0 wz
        if_z  mov eg_opstate,#EG_DECAY


              ' Handle attenuation change

              ' get rate
              altgb eg_opstate,#eg_ar_dr_sr_rr
              getbyte eg_rate

              'debug(udec(eg_slot,eg_opstate),uhex_long(eg_ar_dr_sr_rr))
              'debug(`EGterm 'OP `(eg_slot)' 9 '`uhex_long_(eg_ar_dr_sr_rr) `uhex_long_(eg_sl_rs_ssgeg) `uhex_byte_(eg_opstate) `uhex_long_(eg_oplevel)' 13)

              ' Apply rate scaling
              cmp eg_rate,#0 wz
              mov opn_tempValue,eg_kcode
              shr opn_tempValue,eg_rs_sl_ssgeg
        if_nz add eg_rate,opn_tempValue
              fle eg_rate,#63

              altgb eg_rate,#eg_rate_mantissa_tbl
              getbyte opn_arg2
              altgb eg_rate,#eg_rate_shift_tbl
              getbyte opn_arg3

              cmp eg_opstate,#EG_ATTACK wz
        if_nz jmp #.notattack

              ' Handle Attack
              cmp eg_rate,#62 wc ' Rates > 62 force level to 0 on keyon, but don't do anything else
              testb eg_op_keyonoff,#1 wz
  if_nc_and_z mov eg_oplevel,#0

              ' Weird attenuation-decreasement algorithm
              getword opn_tempValue,eg_oplevel,#1
              bitnot opn_tempValue,#0 addbits 15
              muls opn_tempValue,opn_arg2
              sar opn_tempValue,#4
              shl opn_tempValue,opn_arg3
        if_c  add eg_oplevel,opn_tempValue
              fges eg_oplevel,#0

              jmp #.adsrjoin
.notattack    ' Handle Decay/Sustain/Release
              shl opn_arg2,opn_arg3
              testb eg_rs_sl_ssgeg,#16+3 wz ' SSG-EG enabled?
              cmp eg_oplevel,ssg_eg_threshold wc ' SSG-EG only applies in top half of envelope..
         if_z shl opn_arg2,#2 ' ..and quadruples the rate
   if_nz_or_c add eg_oplevel,opn_arg2
.adsrjoin
              calld pb,eg_return

              fle eg_oplevel,eg_max


              ' transition DECAY TO SUSTAIN when sustain level reached
              cmp eg_opstate,#EG_DECAY wz
              getbyte opn_tempValue,eg_rs_sl_ssgeg,#1
              shl opn_tempValue,#5+EG_EXTRABITS
              cmp eg_oplevel,opn_tempValue wc
  if_nc_and_z mov eg_opstate,#EG_SUSTAIN
  if_nc_and_z mov eg_oplevel,opn_tempValue ' Hack! Force sustain level if we shot past


              ' save level/state
              altd eg_slot,#eg_levels
              mov 0-0,eg_oplevel
              altsb eg_slot,#eg_state_b
              setbyte eg_opstate


              ' Make effective level
              testb ssgeg_invert,eg_slot wc
        if_c  subr eg_oplevel,ssg_eg_threshold
              fges eg_oplevel,#0
              shr eg_oplevel,#EG_EXTRABITS - 2
              ' Save effective level for later copying
              alti eg_levb_alti,eg_levb_write
              mov 0-0,eg_oplevel


              incmod eg_slot,#24-1 wc
              test eg_slot,#3 wz
        if_nz jmp #opn_eg_loop

              ' copy effective levels for one channel all at once to avoid glitches
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0

        if_c  jmp #opn_eg_start
              jmp #opn_eg_chloop

'===========================================================
'    PSG emulation section. Mostly copied from SNEcog.
'===========================================================
psg_load
              ' Update registers
              mov ptra,OPN_Address
              add ptra,#OPN_SIZE
              setq      #7
              rdlong    psg_frequency1,ptra
              shl       psg_frequency1,#22
              shl       psg_frequency2,#22
              shl       psg_frequency3,#22
              wrbyte    #1, ptra[6*4+1]
              mov       opn_arg1,psg_noiseFeedback
              and       opn_arg1,#3
              cmp       opn_arg1, #3                wz      '|
        if_ne decod     psg_noiseFreq, #26                  '|
        if_ne shl       psg_noiseFreq, opn_arg1             '| These 4 lines handles selection of "external" noise frequency on/off
        if_e  mov       psg_noiseFreq, psg_frequency3       '|
              fge       psg_noiseFreq, psg_noiseSubValue ' fix case where noise freq is zero

              jmp #\opn_task_done

psg_run

.AmpN
              test     psg_noiseFeedback, #256           wz ' If bit 8 is zero; Reset noise register
  if_z        mov      psg_noiseValue, #1
.Noise1       sub      psg_oscCounterN, psg_noiseSubValue wc ' Noise generator
  if_nc       waitx    #(7-1)*2 ' wait equivalent time for timing stability
  if_nc       jmp      #.Amp1
              add      psg_oscCounterN, psg_noiseFreq
'-----------------------------------------------------------
              test     psg_noiseFeedback, #4             wz ' Is it periodic or white noise ?
  if_nz       test     psg_noiseValue, #NOISE_TAP        wc ' C = White noise !
  if_z        test     psg_noiseValue, #1                wc ' C = Periodic noise !
              bitc     psg_noiseValue, #NOISE_MSB + 1
              shr      psg_noiseValue, #1                wc
              alts     psg_amplitudeN,#psg_amplitudeTable
              negnc    psg_outN, 0-0
'-----------------------------------------------------------
.Amp1
.Square1      sub      psg_oscCounter1, psg_oscSubValue  wc ' Square wave generator 1
  if_c        add      psg_oscCounter1, psg_frequency1
  if_c        xor      psg_oscState1, #1                 wz
  if_c        alts     psg_amplitude1,#psg_amplitudeTable
  if_c        negz     psg_out1, 0-0
'-----------------------------------------------------------
.Amp2
.Square2      sub      psg_oscCounter2, psg_oscSubValue  wc ' Square wave generator 2
  if_c        add      psg_oscCounter2, psg_frequency2
  if_c        xor      psg_oscState2, #1                 wz
  if_c        alts     psg_amplitude2,#psg_amplitudeTable
  if_c        negz     psg_out2, 0-0
'-----------------------------------------------------------
.Amp3
.Square3      sub      psg_oscCounter3, psg_oscSubValue  wc ' Square wave generator 3
  if_c        add      psg_oscCounter3, psg_frequency3
  if_c        xor      psg_oscState3, #1                 wz
  if_c        alts     psg_amplitude3,#psg_amplitudeTable
  if_c        negz     psg_out3, 0-0

'===========================================================
'      Mix channels and update FRQA/FRQB PWM-values
'===========================================================
.mixer
              mov      psg_out,opn_dac_center
              add      psg_out,psg_out1
              add      psg_out,psg_out2
              add      psg_out,psg_out3
              add      psg_out,psg_outN

              jmp #\opn_task_done


fit 1024

DAT ' OPN2Cog I/O interface
        orgh

psg_portwrite
              loc ptrb,#psg_regbase - 8*4
              test zk_tmp8,#$80 wc
        if_nc jmp #.second
              getnib zk_memtmp0,zk_tmp8,#1
              wrbyte zk_memtmp0,#psg_register
              shl zk_memtmp0,#2
              add ptrb,zk_memtmp0
              rdlong zk_memtmp0,ptrb
              setq #%1111
              muxq zk_memtmp0,zk_tmp8
              wrlong zk_memtmp0,ptrb
              ret wcz
.second
              rdbyte zk_memtmp0,#psg_register
              cmpr zk_memtmp0,#5+8 wc
              testb zk_memtmp0,#0 orc
              shl zk_memtmp0,#2
              add ptrb,zk_memtmp0
              rdlong zk_memtmp0,ptrb
        if_nc shl zk_tmp8,#4
        if_nc setq ##%111111<<4
        if_c  setq #%1111
              muxq zk_memtmp0,zk_tmp8
              wrlong zk_memtmp0,ptrb
              ret wcz


opn_statusread
              mov zk_tmp8,#0

              rdword zk_memtmp0 ,#opn_timerAflag ' timer B in high byte
              testb zk_memtmp0,#0 wc
              bitc zk_tmp8,#0
              testb zk_memtmp0,#8 wc
              bitc zk_tmp8,#1
              ret wcz

opn_portwrite
              and zk_tmp8,#255 ' make sure we only get one byte
              testb zk_ea,#0 wc
        if_nc jmp #.address
              loc ptrb,#opn_regbase
              rdword zk_memtmp1,#opn_register
              testb zk_ea,#1 wc
              testb zk_memtmp1,#8 xorc
        if_c  ret wcz
              cmp zk_memtmp1,#$28 wz
        if_e  jmp #.keyon ' Only on first port!
              cmp zk_memtmp1,#$30 wc
        if_b  jmp #.common_reg ' Only on first port!

              ' All the channel registers use bits 0..1 and the port to select them
              mov zk_memtmp3,zk_memtmp1
              and zk_memtmp3,#3 wcz
        if_00 ret wcz
              testb zk_memtmp1,#8 wc
        if_c  add zk_memtmp3,#3 ' got channel no
              mov pa,zk_memtmp3
              mul pa,#CH_SIZE
              add ptrb,pa
              add ptrb,#CH_OFFSET
              '' Also precompute operator no
              mov zk_memtmp2,zk_memtmp1
              rev zk_memtmp2
              shr zk_memtmp2,#28
              and zk_memtmp2,#3

              getnib pa,zk_memtmp1,#1
              cmp pa,#$C wc
        if_c  cmpsub pa,#$3 wc
        if_nc ret wcz
              mul pa,#16
              jmprel pa
.opn_chreg_base
              orgh .opn_chreg_base + ($3-3)*16*4 '' $3x MUL/DT
              mov zk_memtmp1,zk_memtmp2
              mul zk_memtmp1,#OP_SIZE
              add ptrb,zk_memtmp1
              wrbyte zk_tmp8,ptrb[OP_OFFSET+0] ' write MUL/DT
              jmp #.update_detune_faster

              orgh .opn_chreg_base + ($4-3)*16*4 '' $4x TL
              and zk_tmp8,#$7f
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              wrbyte zk_tmp8,ptrb[OP_OFFSET+1] ' write TL
              ret wcz

              orgh .opn_chreg_base + ($5-3)*16*4 '' $5x AR/RS
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2

              mov zk_memtmp0,zk_tmp8
              and zk_memtmp0,#$1F
              shl zk_memtmp0,#1
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+4] ' write AR
              shr zk_tmp8,#6
              xor zk_tmp8,#3
              wrbyte zk_tmp8,ptrb[OP_OFFSET+8] ' write RS
              ret wcz

              orgh .opn_chreg_base + ($6-3)*16*4 '' $6x DR/AM
              ' Set AM bit
              rdbyte zk_memtmp0,ptrb[6]
              testb zk_tmp8,#7 wc
              bitc zk_memtmp0,zk_memtmp2
              wrbyte zk_memtmp0,ptrb[6]

              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              and zk_tmp8,#$1F
              shl zk_tmp8,#1
              wrbyte zk_tmp8,ptrb[OP_OFFSET+5] ' write DR
              ret wcz
              orgh .opn_chreg_base + ($7-3)*16*4 '' $7x SR
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              and zk_tmp8,#$1F
              shl zk_tmp8,#1
              wrbyte zk_tmp8,ptrb[OP_OFFSET+6] ' write SR
              ret wcz

              orgh .opn_chreg_base + ($8-3)*16*4 '' $8x RR/SL
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2

              getnib zk_memtmp0,zk_tmp8,#0
              shl zk_memtmp0,#2
              add zk_memtmp0,#2
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+7] ' write RR
              getnib zk_memtmp0,zk_tmp8,#1
              cmp zk_memtmp0,#$F wz
        if_z  mov zk_memtmp0,#$10
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+9] ' write SL
              ret wcz

              orgh .opn_chreg_base + ($9-3)*16*4 '' $9x SSG-EG
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              wrbyte zk_tmp8,ptrb[OP_OFFSET+10] ' write SSG-EG
              ret wcz

              orgh .opn_chreg_base + ($A-3)*16*4 '' $Ax Frequency

              testb zk_memtmp1,#3 wc
        if_c  jmp #.ch3extrafreq
              loc pa,#opn_frqhi
              add pa,zk_memtmp3
              testb zk_memtmp1,#2 wc
        if_nc jmp #.lofreq
              wrbyte zk_tmp8,pa
              ret wcz

              orgh .opn_chreg_base + ($B-3)*16*4 '' $Bx ALGO/FB/PAN/LFOsens
              testbn zk_memtmp1,#3 wc
        if_nc ret wcz ' unused register $B8..$BF

              testb zk_memtmp1,#2 wc ' NC = algo/FB register; C = pan/LFOsens
        if_nc and zk_tmp8,#$3F
        if_c  and zk_tmp8,#$F7
        if_nc wrbyte zk_tmp8,ptrb[2]
        if_c  wrbyte zk_tmp8,ptrb[3]
              ret wcz

              ' --------------------------------

.lofreq
              rdbyte zk_memtmp0,pa
              rolbyte zk_memtmp0,zk_tmp8,#0
              debug("got freq for ch",udec_(zk_memtmp3),uhex_word(zk_memtmp0))
              zerox zk_memtmp0,#13
              wrword zk_memtmp0,ptrb[0]
              ' Compute kcode
              mov zk_tmp8,zk_memtmp0
              shr zk_tmp8,#11-2
              shr zk_memtmp0,#7
              and zk_memtmp0,#$F
              sub zk_memtmp0,#6
              fges zk_memtmp0,#0
              fles zk_memtmp0,#3
              setq #%11100
              muxq zk_memtmp0,zk_tmp8
              wrbyte zk_memtmp0,ptrb[4]

              mov zk_memtmp2,#3
.dtlp
              call #.update_detune
              djnf zk_memtmp2,#.dtlp
              ret wcz



.ch3extrafreq
              test zk_memtmp1,#$100 wc
        if_c  ret wcz
              mov zk_memtmp2,zk_memtmp3
              decmod zk_memtmp2,#2 ' get operator N
              debug("CH3 special write to ",uhex_byte(zk_memtmp1)," is operator ",udec(zk_memtmp2))

              loc pa,#opn_frqhi+6
              add pa,zk_memtmp2
              testb zk_memtmp1,#2 wc
        if_c  wrbyte zk_tmp8,pa
        if_c  ret wcz

              loc ptrb,#opn_regbase+CH_OFFSET+(2*CH_SIZE) ' Always channel 3
              mov zk_memtmp3,#2 ' Always channel 3

              rdbyte zk_memtmp0,pa
              rolbyte zk_memtmp0,zk_tmp8,#0
              zerox zk_memtmp0,#13
              loc pa,#opn_regbase+12
              add pa,zk_memtmp2
              add pa,zk_memtmp2
              wrword zk_memtmp0,pa
              ' Compute kcode
              mov zk_tmp8,zk_memtmp0
              shr zk_tmp8,#11-2
              shr zk_memtmp0,#7
              and zk_memtmp0,#$F
              sub zk_memtmp0,#6
              fges zk_memtmp0,#0
              fles zk_memtmp0,#3
              setq #%11000
              muxq zk_memtmp0,zk_tmp8
              loc pa,#opn_regbase+4
              add pa,zk_memtmp2
              wrbyte zk_memtmp0,pa

              ' fall through

.update_detune
              mov zk_memtmp1,zk_memtmp2
              mul zk_memtmp1,#OP_SIZE
              add ptrb,zk_memtmp1
              rdbyte zk_tmp8,ptrb[OP_OFFSET+0] ' read MUL/DT
.update_detune_faster
              sub ptrb,zk_memtmp1

              rdbyte zk_memtmp0,ptrb[4] ' channel kcode
              '' Do detune adjustment
              loc pa,#detune_adjustment
              shl zk_memtmp0,#2
              shr zk_tmp8,#4
              setq #3
              muxq zk_memtmp0,zk_tmp8
              add pa,zk_memtmp0
              rdbyte zk_memtmp0,pa
              add ptrb,zk_memtmp1
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+2] ' write detune lookup
              sub ptrb,zk_memtmp1

              cmp zk_memtmp3,#2 wz 'Is CH3?
              cmp zk_memtmp2,#3 wc ' is not OP4?
        if_nc_or_nz ret wcz
              ' update detune for CH3 special
              loc pb,#opn_regbase+4
              add pb,zk_memtmp2
              rdbyte zk_memtmp0,pb ' operator kcode
              '' Do detune adjustment
              loc pa,#detune_adjustment
              shl zk_memtmp0,#2
              'shr zk_tmp8,#4
              setq #3
              muxq zk_memtmp0,zk_tmp8
              add pa,zk_memtmp0
              rdbyte zk_memtmp0,pa
              add pb,#4
              wrbyte zk_memtmp0,pb ' write detune lookup
              ret wcz

.common_reg
              cmp zk_memtmp1,#$2B wcz
        if_e  wrbyte zk_tmp8,ptrb[1] ' DAC enable
        if_ne cmp zk_memtmp1,#$29 wz
        if_nc_or_z ret wcz ' Also return on nonexistant registers $2C..$2F and $29
              cmp zk_memtmp1,#$2A wz
        if_e  wrbyte zk_tmp8,ptrb[0] ' DAC data
        if_e  ret wcz
              cmp zk_memtmp1,#$27 wz
        if_e  jmp #.tctrl   ' CH3 special mode and timer ctrl
              cmp zk_memtmp1,#$26 wz
        if_e  wrbyte zk_tmp8,ptrb[3] ' Timer B freq
        if_e  ret wcz
              cmp zk_memtmp1,#$22 wz
        if_e  wrbyte zk_tmp8,ptrb[2] ' LFO ctrl
        if_e  ret wcz
              cmp zk_memtmp1,#$24 wcz
        if_b  ret wcz ' Return on unused registers $00..$21 and $23
              ' Must be Timer A frequency
              rdword zk_memtmp0,ptrb[18/2]
        if_e  shl zk_tmp8,#2
        if_e  setq ##%11_11111100
        if_a  setq #%11
              muxq zk_memtmp0,zk_tmp8
              wrword zk_memtmp0,ptrb[18/2]
              ret wcz

.tctrl
              wrbyte zk_tmp8,ptrb[7]
              testb zk_tmp8,#4 wc ' Timer A reset
        if_c  wrbyte #0,#opn_timerAflag
              testb zk_tmp8,#5 wc ' Timer B reset
        if_c  wrbyte #0,#opn_timerBflag
              ret wcz


.keyon
              getnib zk_memtmp3,zk_tmp8,#1
              and zk_tmp8,#%111
              test zk_tmp8,#%011 wcz
        if_00 ret wcz ' invalid channel
              test zk_tmp8,#%100 wc
        if_c  sub zk_tmp8,#1
              rdlong zk_memtmp0,ptrb[20/4]
              altsn zk_tmp8,#zk_memtmp0
              setnib zk_memtmp3
              wrlong zk_memtmp0,ptrb[20/4]
              ret wcz

.address
              testb zk_ea,#1 wc
              bitc zk_tmp8,#8
              wrword zk_tmp8,#opn_register
              ret wcz

opn_doreset
              loc ptrb,#opn_regbase
              wrlong #$80,ptrb++ ' reduce DAC DC click
              setq #5-1
              wrlong #0,ptrb++
              mov zk_memtmp0,#6
.chlp
              wrlong ##$C0_00_00_00,ptrb++ ' Pan initializes to center
              wrlong #0,ptrb++

              mov zk_memtmp1,#4
.oplp
              wrlong ##$00_00_7F_00,ptrb++ ' Maximum (=quietest) TL
              wrlong ##$3E_00_3E_00,ptrb++ ' Maximum DR/RR so the chip actually resets
              wrlong #0,ptrb++
              djnz zk_memtmp1,#.oplp
              djnz zk_memtmp0,#.chlp
              wrword #0,#opn_timerAflag
              ret wcz




detune_adjustment byte ' table used to compute detune amount
byte   0,  0,  1,  2 ,    0,  0,  1,  2 ,    0,  0,  1,  2 ,    0,  0,  1,  2
byte   0,  1,  2,  2 ,    0,  1,  2,  3 ,    0,  1,  2,  3 ,    0,  1,  2,  3
byte   0,  1,  2,  4 ,    0,  1,  3,  4 ,    0,  1,  3,  4 ,    0,  1,  3,  5
byte   0,  2,  4,  5 ,    0,  2,  4,  6 ,    0,  2,  4,  6 ,    0,  2,  5,  7
byte   0,  2,  5,  8 ,    0,  3,  6,  8 ,    0,  3,  6,  9 ,    0,  3,  7, 10
byte   0,  4,  8, 11 ,    0,  4,  8, 12 ,    0,  4,  9, 13 ,    0,  5, 10, 14
byte   0,  5, 11, 16 ,    0,  6, 12, 17 ,    0,  6, 13, 19 ,    0,  7, 14, 20
byte   0,  8, 16, 22 ,    0,  8, 16, 22 ,    0,  8, 16, 22 ,    0,  8, 16, 22

DAT ' OPN2Cog register area
        orgh
        alignl

opn_regbase long 0[OPN_SIZE/4]
psg_regbase long 15[PSG_SIZE/4]
opn_frqhi   byte 0[6+3]

        alignl

'' YM2612 global registers (6 + 6*14 = 90 longs)
'' -----------------------
'' byte dac_val,dac_enable
'' byte lfo
'' byte timerBfreq
'' byte ch3_kcodes[3]
'' byte ch3_mode '(also timer stuff)
'' byte ch3_detune[3]
'' byte glpad
'' word ch3_specialfreqs[3]
'' word timerAfreq
'' long key_on
'' 6x channel regs
''

'' YM2612 channel registers (2 + 4*3 = 14 longs)
'' ------------------------
'' word frequency
'' byte algorithm '(also S1 feedback)
'' byte pan_lfo
'' byte keycode_cache ' (not a real register)
'' byte ch_padding1
'' byte am
'' byte ch_padding2
'' 4x operator regs
''

'' YM2612 operator registers (= 3 longs)
'' -------------------------
'' byte mul_dt
'' byte tl
'' byte detune_cache ' (not a real register)
'' byte op_pad1
'' byte ar
'' byte dr
'' byte sr
'' byte rr
'' byte rs
'' byte sl
'' byte ssg_eg
'' byte op_pad2
''

'' SN76489 registers:
''
'' Reg bits function
'' -----------------------------------
'' 00  9..0 channel 1 freq
'' 01  3..0 channel 1 attunation
'' 02  9..0 channel 2 freq
'' 03  3..0 channel 2 attunation
'' 04  9..0 channel 3 freq
'' 05  3..0 channel 3 attunation
'' 06  4..0 noise control
'' 07  7..0 noise attunation



DAT ' MEMORY
              orgh $1_0000
main_ram
              byte 0[$1_0000] ' 68k RAM

              byte 0[16] ' padding
mk_romio_area
              byte 0[256]
              byte 0[16] ' padding
mk_romque_area
              byte 0[256]

mk_vectorcache
              long 0[64]

vdp_cram ' also VSRAM
              byte 0[512]

vdp_cram32
              long 0[64*3]

renderbuffer_loc
              byte 0[RENDERBUFFER_SIZE*2]

outbuffer_loc
              long $FF00FF00[OUTBUFFER_WIDTH*2]

cram2cram32_table
              file "CRAM2RGB.DAT"

z80_ram
              byte 0[8*1024]

              byte 0[16] ' padding
z80_romio_area
              byte 0[16]

              orgh $3_0000
vdp_ram
              byte 0[$1_0000] ' Graphics RAM


              orgh $4_0000
save_ram
              byte 0[$1_0000] ' Non-volatile SRAM


              orgh UPPER_LOAD
              file "megayume_upper.binary"