CON

  SUBMODE_NTSC = 0
  SUBMODE_PAL = 1<<8 ' Can be combined with others...
  SUBMODE_FORCE_ALTPILLAR = 1<<9 ' TODO NYI Can be combined with others...
  SUBMODE_FORCE_REC601 = 1<<10 ' Force Rec601 color space for YPbPr
  SUBMODE_FORCE_REC709 = 1<<11 ' Force Rec709 color space for YPbPr

  #0,MODE_RGBHV,MODE_RGBS,MODE_SoG,MODE_YPBPR,MODE_COMPOSITE,MODE_SVIDEO,MODE_SVID_AND_COMP,MODE_DVI,MODE_DVI_VGA,MODE_HDMI,MODE_HDMI_VGA,MODE_LCD6

  MODE_VGA = MODE_RGBHV

  #0,SUBMODE_AUTO,SUBMODE_1X,SUBMODE_2X,SUBMODE_3X,SUBMODE_4X,SUBMODE_5X, ... ' Analog line-multiply modes
  SUBMODE_TMDS_640x480,SUBMODE_TMDS_768x480,SUBMODE_TMDS_800x480,SUBMODE_TMDS_854x480


  #0, LCD_ILI9342

  ' MADCTL values for ILI submode
  ILI_HFLIP = %00000100 << 8 ' Doesn't work in bypass mode
  ILI_VFLIP = %00010000 << 8
  ILI_BGR   = %00001000 << 8 ' Toggle this if colors are wrong


  TMDS_REVERSE_FLAG = 64<<8

  MAX_INIT = 64


  WIDTH = 320
  WIDTH_ALT = 256 ' Not used in NeoYume

  HEIGHT = 224
  BORDER_TOP = 8
  BORDER_BOTTOM = 8
  HEIGHT_TOTAL = HEIGHT+BORDER_BOTTOM+BORDER_TOP

  VDPBIT_INTERLACE = 1
  VDPBIT_ALTRES = 0

  VDP_INVERT_ALTRES = true

  VDPR_OFFSET = 2 ' lines that rendering has to run ahead

PUB start(pins,extrapins,mode,submode,buffer,extrastride,buflines,linectr,vdpmode,audio_mb_period) : cogn | cmode,timing,initf,stride

case mode
  MODE_RGBHV..MODE_YPBPR: ' All arbitrary-resolution analog modes
    case submode&255
      SUBMODE_1X: timing := @timing_native
      SUBMODE_3X: timing := @timing_line3x
      other: timing := @timing_line2x
      
    case mode
      MODE_RGBHV:
        cmode := @cmode_rgbhv_tmds
        initf := @init_rgbhv
      MODE_RGBS:
        cmode := @cmode_rgbs
        initf := @init_rgbs
      MODE_SoG:
        cmode := @cmode_sync_on_green
        initf := @init_soggy
      MODE_YPBPR:
        if submode&SUBMODE_FORCE_REC709 || (long[timing][1] >= 3 && not(submode&SUBMODE_FORCE_REC601))
          cmode := @cmode_ypbpr709
          debug("YPbPr matrix set to Rec709")
        else
          cmode := @cmode_ypbpr601
          debug("YPbPr matrix set to Rec601")
        initf := @init_soggy
  MODE_COMPOSITE..MODE_SVID_AND_COMP: ' NTSC/PAL encoded modes
    timing := @timing_native ' Always
    if submode&SUBMODE_PAL
      cmode := @cmode_pal
    else
      cmode := @cmode_ntsc

    case mode
      MODE_COMPOSITE: initf := @init_composite
      MODE_SVIDEO: initf := @init_svideo
      MODE_SVID_AND_COMP: initf := @init_compsvid

  MODE_DVI..MODE_HDMI_VGA: ' All TMDS modes
    cmode := @cmode_rgbhv_tmds
    case mode
      MODE_DVI: initf := @init_dvi
      MODE_DVI_VGA: initf := @init_dvivga
      MODE_HDMI: initf := @init_hdmi
      MODE_HDMI_VGA: initf := @init_hdmivga
    case submode&255
      SUBMODE_TMDS_768x480: timing := @timing_tmds_768x480
      SUBMODE_TMDS_800x480: timing := @timing_tmds_800x480
      SUBMODE_TMDS_854x480: timing := @timing_tmds_854x480
      other: timing := @timing_tmds_640x480
  other:
    abort -1

clkset(computeClockMode(long[timing]),long[timing])

stride := WIDTH*4+extrastride

return startx(pins,extrapins,buffer,stride,buffer+stride*buflines,linectr,vdpmode,timing,cmode,initf,audio_mb_period)

PUB startx(pins,extrapins,buffer_base,buffer_stride,buffer_wrap,linectr,vdpmode,timing,color,initfunc,audio_mb_period) : cogn

cogn := coginit(HUBEXEC_NEW,@video_init,@pins)
waitms(1) ' wait so stack frame isn't rugpulled

DAT ' Color modes

cmode_rgbhv_tmds ' RGBHV and TMDS hybrid mode
long $00_00_00_00   ' DAC blanking value
long TMDS_BLANK     ' Blanking color
long TMDS_HSYNC     ' HSync color
long TMDS_VSYNC     ' VSync color
long TMDS_HVSYNC    ' HSync+VSync color
long 0              ' Color burst color (NTSC/PAL only)
long 0              ' Color burst frequency  (NTSC/PAL only)
long $5A_00_00_00   ' CY
long $00_5A_00_00   ' CI
long $00_00_5A_00   ' CQ
long 0              ' CQ XOR value (NTSC/PAL only)

cmode_rgbs ' RGB + CSync mode
long $00_00_00_00   ' DAC blanking value
long $00_00_00_00   ' Blanking color
long $00_00_00_01   ' HSync color
long $00_00_00_01   ' VSync color
long $00_00_00_00   ' HSync+VSync color
long 0              ' Color burst color (NTSC/PAL only)
long 0              ' Color burst frequency  (NTSC/PAL only)
long $5A_00_00_00   ' CY
long $00_5A_00_00   ' CI
long $00_00_5A_00   ' CQ
long 0              ' CQ XOR value (NTSC/PAL only)

cmode_sync_on_green ' RGB SoG mode
long $00_00_00_00   ' DAC blanking value
long Y_BLANK        ' Blanking color
long Y_SYNC         ' HSync color
long Y_SYNC         ' VSync color
long Y_BLANK        ' HSync+VSync color
long 0              ' Color burst color (NTSC/PAL only)
long 0              ' Color burst frequency  (NTSC/PAL only)
long $5A_00_00<<8 + BLANK_LEVEL   ' CY
long $00_5A_00<<8 + BLANK_LEVEL   ' CI
long $00_00_5A<<8 + BLANK_LEVEL   ' CQ
long 0              ' CQ XOR value (NTSC/PAL only)

cmode_ypbpr601 ' YPbPr (with Rec. 601 matrix for SDTV)
long $00_00_00_00   ' DAC blanking value
long Y_BLANK        ' Blanking color
long Y_SYNC         ' HSync color
long Y_SYNC         ' VSync color
long Y_BLANK        ' HSync+VSync color
long 0              ' Color burst color (NTSC/PAL only)
long 0              ' Color burst frequency  (NTSC/PAL only)
long ( 45&$FF) << 24 + (-38&$FF) << 16 + ( -7&$FF) << 8 + 128   ' CY
long ( 27&$FF) << 24 + ( 53&$FF) << 16 + ( 10&$FF) << 8 + BLANK_LEVEL   ' CI
long (-15&$FF) << 24 + (-30&$FF) << 16 + ( 45&$FF) << 8 + 128   ' CQ
long 0              ' CQ XOR value (NTSC/PAL only)
    
cmode_ypbpr709 ' YPbPr (with Rec. 709 matrix for HDTV)
long $00_00_00_00   ' DAC blanking value
long Y_BLANK        ' Blanking color
long Y_SYNC         ' HSync color
long Y_SYNC         ' VSync color
long Y_BLANK        ' HSync+VSync color
long 0              ' Color burst color (NTSC/PAL only)
long 0              ' Color burst frequency  (NTSC/PAL only)
long ( 45&$FF) << 24 + (-41&$FF) << 16 + ( -4&$FF) << 8 + 128   ' CY
long ( 19&$FF) << 24 + ( 64&$FF) << 16 + (  7&$FF) << 8 + BLANK_LEVEL   ' CI
long (-10&$FF) << 24 + (-35&$FF) << 16 + ( 45&$FF) << 8 + 128   ' CQ
long 0              ' CQ XOR value (NTSC/PAL only)

cmode_ntsc
long $00_00_00_00
long %01            ' Blanking color
long %11            ' HSync color
long %11            ' VSync color
long %01            ' HSync+VSync color
long COLOR_BURST_NTSC ' Color burst color (NTSC/PAL only)
long round(4_294_967_296.0*3_579_545.0/float(VIDEO_CLKFREQ))-1            ' Color burst frequency  (NTSC/PAL only)
long CY_NTSC        ' CY
long CI_NTSC        ' CI
long CQ_NTSC        ' CQ
long 0              ' CQ XOR value (NTSC/PAL only)

cmode_pal
long $00_00_00_00
long %01            ' Blanking color
long %11            ' HSync color
long %11            ' VSync color
long %01            ' HSync+VSync color
long COLOR_BURST_PAL ' Color burst color (NTSC/PAL only)
long round(4_294_967_296.0*4_433_618.0/float(VIDEO_CLKFREQ))              ' Color burst frequency  (NTSC/PAL only)
long CY_PAL         ' CY
long CU_PAL         ' CI
long CV_PAL_EVEN    ' CQ
long CV_PAL_ODD^CV_PAL_EVEN ' CQ XOR value (NTSC/PAL only)


DAT ' Timings

' Note: native timing must have an even number of sync NCO cycles per scanline
'       and exactly 3 Vsync lines
'       Otherwise interlace timing will be off
timing_native
long VIDEO_CLKFREQ  ' CLKFREQ
long 1              ' active line multiplier
long 4              ' V front porch
long 3              ' V sync
long 15             ' V back porch
long 0              ' extra pillar
long 256            ' blank line
long 7+14           ' H front porch
long 26             ' H sync
long 25+14          ' H back porch
long round(2147483648.0/float(CLK_MULTIPLIER*10)) ' Sync NCO
long round(2147483648.0/float(CLK_MULTIPLIER*8)) ' Pixel NCO
long round(2147483648.0/float(CLK_MULTIPLIER*10)) ' Alt-res NCO
long 2              ' Breezeway (NTSC/PAL only - subtracts from H.BP)
long 12             ' Burst (NTSC/PAL only - subtracts from H.BP)

timing_line2x
long VIDEO_CLKFREQ  ' CLKFREQ
long 2              ' active line multiplier
long 10             ' V front porch
long 2              ' V sync
long 32             ' V back porch
long 0              ' extra pillar
long 320            ' blank line
long 8              ' H front porch
long 48             ' H sync
long 24             ' H back porch
long round(2147483648.0/25.65) ' Sync NCO
long round(2147483648.0/25.65)      ' Pixel NCO
long round(2147483648.0/25.65*256.0/320.0)              ' Alt-res NCO
long 0              ' Breezeway (NTSC/PAL only - subtracts from H.BP)
long 0              ' Burst (NTSC/PAL only - subtracts from H.BP)

timing_line3x
long VIDEO_CLKFREQ  ' CLKFREQ
long 3              ' active line multiplier
long 15             ' V front porch
long 3              ' V sync
long 48             ' V back porch
long 0              ' extra pillar
long 320            ' blank line
long 8              ' H front porch
long 48             ' H sync
long 24             ' H back porch
long round(2147483648.0/25.65*1.5) ' Sync NCO
long round(2147483648.0/25.65*1.5)      ' Pixel NCO
long round(2147483648.0/25.65*1.5*256.0/320.0)              ' Alt-res NCO
long 0              ' Breezeway (NTSC/PAL only - subtracts from H.BP)
long 0              ' Burst (NTSC/PAL only - subtracts from H.BP)


timing_tmds_640x480
long VIDEO_CLKFREQ  ' CLKFREQ
long 2              ' active line multiplier
long 10             ' V front porch
long 2              ' V sync
long 32             ' V back porch
long 0              ' extra pillar
long 640            ' blank line
long 56             ' H front porch
long 96             ' H sync
long 234            ' H back porch
long $0CCCCCCD      ' Sync NCO
long 0              ' Pixel NCO
long 2              ' Alt-res NCO
long 0              ' Unused
long 2              ' Guard Bands (HDMI only - subtracts from H.BP)

timing_tmds_768x480
long VIDEO_CLKFREQ  ' CLKFREQ
long 2              ' active line multiplier
long 10             ' V front porch
long 2              ' V sync
long 32             ' V back porch
long 64             ' extra pillar
long 768            ' blank line
long 56             ' H front porch
long 96             ' H sync
long 106            ' H back porch
long $0CCCCCCD      ' Sync NCO
long 0              ' Pixel NCO
long 2              ' Alt-res NCO
long 0              ' Unused
long 2              ' Guard Bands (HDMI only - subtracts from H.BP)

timing_tmds_800x480
long VIDEO_CLKFREQ  ' CLKFREQ
long 2              ' active line multiplier
long 10             ' V front porch
long 2              ' V sync
long 32             ' V back porch
long 80             ' extra pillar
long 800            ' blank line
long 56             ' H front porch
long 96             ' H sync
long 74             ' H back porch
long $0CCCCCCD      ' Sync NCO
long 0              ' Pixel NCO
long 2              ' Alt-res NCO
long 0              ' Unused
long 2              ' Guard Bands (HDMI only - subtracts from H.BP)

timing_tmds_854x480
long VIDEO_CLKFREQ  ' CLKFREQ
long 2              ' active line multiplier
long 10             ' V front porch
long 2              ' V sync
long 32             ' V back porch
long 107            ' extra pillar
long 854            ' blank line
long 56             ' H front porch
long 96             ' H sync
long 20             ' H back porch
long $0CCCCCCD      ' Sync NCO
long 0              ' Pixel NCO
long 2              ' Alt-res NCO
long 0              ' Unused
long 2              ' Guard Bands (HDMI only - subtracts from H.BP)

DAT ' Cog-resident code
              org
video_cog_code              

hsync_ntsc ' also PAL
              setq nco_sync
              xcont hsync_tip,hsync_color
              xcont hsync_breeze,blank_color
              xor cq_val,cq_xor
              setcq cq_val ' here because we know tip must be in progress
              xcont hsync_burst,burst_color
              xcont hsync_bpshort,blank_color
              jmp #vline_update

vsync_ntsc    ' SDTV serrated sync
              cmp lines_left,#7 wc
        if_c  cmpr lines_left,#3 wc ' If NC, do equalization
        if_nc call #ntsc_equ_pulse
        if_c  call #ntsc_sync_pulse
              xor cq_val,cq_xor ' Make sure PAL phase is alternating
              call #vline_update ' update client on time
        if_nc call #ntsc_equ_pulse
        if_c  call #ntsc_sync_pulse
              ret

ntsc_halfline
              setq nco_sync
              xcont hsync_tip,blank_color
        _ret_ xcont vsync_half,blank_color

ntsc_equ_pulse
              setq nco_sync
              xcont hsync_tip,hsync_color
        _ret_ xcont vsync_half,blank_color

ntsc_sync_pulse
              setq nco_sync
              xcont vsync_half,vsync_color
        _ret_ xcont hsync_tip,hvsync_color


scanfunc_2x_rgb24 ' scan out 2 pixels with 2x doubling -> 40 streamer cycles
              ' actual function takes 18cy (inc. call overhead)
              ' so 11 instructions can go between calls
              rflong scantmp
              andn scantmp,#255 ' mask alpha/control channel (DMA would do this for us)
              xcont pixel_multiplier,scantmp
              rflong scantmp
              andn scantmp,#255
        _ret_ xcont pixel_multiplier,scantmp


line_scancomp_alt
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color
              xcont altres_pillar,border_color

              mov scantimecomp,#WIDTH_ALT/2
              mov scanfunc,#scanfunc_2x_rgb24
              call scantask
.comploop     cmpsub scantimecomp,#1 wc
        if_c  call scanfunc
        if_c  call audio_poll_func
        if_c  jmp #.comploop
              xcont altres_pillar,border_color
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color
              call audio_poll_func
        _ret_ xcont hsync_fp,blank_color

line_scancomp ' Software-scaled line with scan-compensated task
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color

              mov scantimecomp,#WIDTH/2
              mov scanfunc,#scanfunc_2x_rgb24
              call scantask
.comploop     cmpsub scantimecomp,#1 wc
        if_c  call scanfunc
        if_c  call audio_poll_func
        if_c  jmp #.comploop
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color
        _ret_ xcont hsync_fp,blank_color

dummy_func
              ret

vsync_pin     long -1
border_color  long $00_00_00_00
altres_pillar long (WIDTH - WIDTH_ALT)/2
linecmd       long WIDTH
linecmd_alt   long WIDTH_ALT
bitbangcmd    long 1
packetblank   long 32
bit31         long 1<<31
min31         long $C000_0000
max31         long $3FFF_FFFF

hsync_func     long hsync_normal
vbi_hsync_func long hsync_normal
vsync_func     long vsync_normal
line_func      long line_native
altline_func   long line_native_altnco
borderline_func long line_border
blankline_func long line_blank
audio_poll_func long dummy_func
scanfunc        long dummy_func
scantask        long dummy_func

' Audio poller upper - pin number is patched in on demand
audio_poll_repo
              cmp audio_inbuf_level,#4 wc
.pptchd if_c  testp #0-0 wc ' TESTP is a D-only instr
        if_c  altd audio_inbuf_level,.inbuf_incr
.pptchs if_c  rdpin 0-0,#0-0
              ret wcz
.inbuf_incr   long audio_inbuffer + (1<<9)


                         '|||| 48K rate here!!!       | Disable copy protection
spdif_status  long %00_00_0010_00000000_00000000_00000100
                                                   '|||| 24 bit sample length (load bearing)
              long %00000000_00000000_00000000_0000_1011
' Sample rate is overwritten by init code when appropriate


' application parameters (must by synced with startx arglist)
app_params
vpins                   res 1 ' furled up analog+digital
extravpins              res 1 ' used for VSYNC etc
scanbuffer_base         res 1
scanbuffer_stride       res 1
scanbuffer_wrap         res 1 ' base + (stride*lines)
linectr_ptr             res 1
vdpmode_ptr             res 1
timing_ptr              res 1
color_ptr               res 1
initfunc_ptr            res 1
audio_period            res 1
app_params_end


' Timing variables
timing_vars
dummy_clkfreq   res 1 ' handled by Spin code
line_multiplier res 1
fp_lines        res 1
sync_lines      res 1
bp_lines        res 1
extra_pillar    res 1 ' permanent pillarbox (left and right) in nco_sync units
blankline       res 1 ' blank line in nco_sync units
hsync_fp      res 1
hsync_tip     res 1
hsync_bp      res 1
nco_sync      res 1
nco_main      res 1 ' only for analog modes!
pixel_multiplier ' alias
nco_alt       res 1 ' only for analog modes!
hsync_breeze  res 1 ' NTSC/PAL only - subtracts from bp
hsync_guardband ' alias - HDMI only
hsync_burst   res 1 ' NTSC/PAL only - subtracts from bp
timing_vars_end

' Color space variables
color_vars
dac_blanking  res 1 ' DAC blanking values
blank_color   res 1
hsync_color   res 1
vsync_color   res 1
hvsync_color  res 1
burst_color   res 1 ' NTSC/PAL only
burst_freq    res 1 ' NTSC/PAL only
cy_val        res 1
ci_val        res 1
cq_val        res 1
cq_xor        res 1 ' NTSC/PAL only
color_vars_end

subline_incmod res 1
borderline res 1
hsync_bpshort res 1 ' NTSC/PAL: BP - (breeze+burst)
blankline_packets res 1 ' rest of blanking line after packets (HDMI only)
vsync_half res 1 ' Half line - hsync pulse

lines_left res 1 ' lines left in current section
scanptr res 1
vdp_mode res 1
bob_lines res 1

scantimecomp res 1 ' Time compensator for threaded scan conversion

subline res 1
virtual_line res 1
virtual_frame res 1

temp1 res 1
temp2 res 1
temp3 res 1
temp4 res 1
scantmp res 1

spleft res 1
spright res 1


' audio-related, all needs zero-ing before use
audio_clear_start
audio_hist        res 4
audio_inbuffer    res 4
audio_inbuf_level res 1
resample_ratio_frac res 1
resample_ratio_int res 1
resample_antidrift_period res 1
resample_phase_frac res 1
resample_phase_int  res 1
resample_antidrift_phase res 1
spdif_phase res 1
hdmi_regen_counter res 1
audio_clear_end

hdmi_regen_period res 1

' Unrelated TERC4-related nonsense
serbyte       res 1
u1 ' alias for resampler
serch0        res 1
u2 ' alias for resampler
serch1        res 1
u3 ' alias for resampler
serch2        res 1
 ' Byte 0 is HSync flag(00/FF), Byte 1 is VSync(00/FF), Byte 2 is Island start bit (FF/FE) - must match the timeslot the packet will be sent in
packet_extra  res 1 ' can't be in overlay because common code writes it


              fit $0B0
              org $0B0
video_ovl_area              


DAT ' LUT resident code

              ' 200 to 2FF is reserved for palette (not used here)
              ' 300 to 35F is used as buffer space (3 encoded HDMI packets fit)
              ' so code starts at 360, space for 160 instructions
              org $300
packet_aviinfo res 32
packet_audio   res 32
packet_aclk    res 32
packet_aclk_v  res 32
              fit $380
              org $380
video_lut_code
video_entry
              'xinit blankline,blank_color
frame_loop
              'debug(udec(virtual_frame),uhex_long(linecmd,extra_pillar,hsync_fp,hsync_tip,hsync_bp,nco_sync,nco_main))
              mov subline,subline_incmod

              mov lines_left,fp_lines
.front_porch 
              call vbi_hsync_func
              cmp lines_left,#1 wz
        if_z  setbyte packet_extra,#$FF,#1 ' Last line of FP builds packet for 1st line of Sync
              call blankline_func  
              djnz lines_left,#.front_porch

              testb vdp_mode,#VDPBIT_INTERLACE wc
              testbn virtual_frame,#0 andc
              cmp vsync_func,#vsync_ntsc wz
  if_c_and_z  call #ntsc_halfline

              mov lines_left,sync_lines
.vsync
              cmp lines_left,#1 wz
        if_z  setbyte packet_extra,#$00,#1 ' Last line of Sync builds packet for 1st line of BP
              call vsync_func
              djnz lines_left,#.vsync

              testb vdp_mode,#VDPBIT_INTERLACE wc
              testbn virtual_frame,#0 andc
              cmp vsync_func,#vsync_ntsc wz
  if_c_and_z  xor cq_val,cq_xor
  if_c_and_z  call #ntsc_halfline

              mov lines_left,bp_lines
.back_porch
              call vbi_hsync_func
              call blankline_func   
              djnz lines_left,#.back_porch

              rdlong vdp_mode,vdpmode_ptr ' read VDP mode here, once.

              neg virtual_line,#BORDER_TOP - VDPR_OFFSET ' TODO SHOULD FLE INSTEAD
              mov subline,#0
              mov lines_left,#BORDER_TOP
              mul lines_left,line_multiplier

              ' Bob interlace for line2x modes
              testb vdp_mode,#VDPBIT_INTERLACE wc
              testbn virtual_frame,#0 andc
        if_c  add lines_left,bob_lines
        if_c  sub subline,bob_lines

.top_border
              call hsync_func
              call borderline_func
              djnz lines_left,#.top_border

              mov lines_left,#HEIGHT
              mul lines_left,line_multiplier
              mov scanptr,scanbuffer_base
              add virtual_frame,#1
.visible
              call hsync_func
              rdfast bit31,scanptr ' fire up FIFO
              cmp subline,#0 wz
        if_z  add scanptr,scanbuffer_stride
              cmp scanptr,scanbuffer_wrap wc
        if_ae mov scanptr,scanbuffer_base
              
              testb vdp_mode,#VDPBIT_ALTRES wc
        if VDP_INVERT_ALTRES
        if_c  mov pa,line_func
        if_nc mov pa,altline_func
        else
        if_nc mov pa,line_func
        if_c  mov pa,altline_func
        end
              call pa
              'call borderline_func

              djnz lines_left,#.visible


              mov lines_left,#BORDER_BOTTOM
              mul lines_left,line_multiplier


              ' Bob interlace for line2x modes
              testb vdp_mode,#VDPBIT_INTERLACE wc
              testb virtual_frame,#0 andc ' got incremented inbetween
        if_c  sub lines_left,bob_lines
.bottom_border
              call hsync_func
              call borderline_func
              djnz lines_left,#.bottom_border

              jmp #frame_loop


vline_update ' update line count to client and scanptr
              setq #1
              wrlong virtual_line,linectr_ptr
              incmod subline,subline_incmod wc
        if_c  add virtual_line,#1
              ret wcz
              
line_native  ' native scanline
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color
              setq nco_main
              xcont linecmd,#0 ' No color needed for DMA
        if_nz setq nco_sync
        if_nz xcont extra_pillar,border_color
              setq nco_sync
        _ret_ xcont hsync_fp,blank_color

line_native_altnco ' alt-res scanline with NCO switch
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color
              setq nco_alt
              xcont linecmd_alt,#0 ' No color needed for DMA
        if_nz setq nco_sync
        if_nz xcont extra_pillar,border_color
              setq nco_sync
        _ret_ xcont hsync_fp,blank_color

line_native_altpillar ' alt-res scanline with pillarbox
              cmp extra_pillar,#0 wz
        if_nz xcont extra_pillar,border_color
              setq nco_main
              xcont altres_pillar,border_color
              xcont linecmd_alt,#0 ' No color needed for DMA
              xcont altres_pillar,border_color
        if_nz setq nco_sync
        if_nz xcont extra_pillar,border_color
              setq nco_sync
        _ret_ xcont hsync_fp,blank_color

fp_audio_pollloop ' this will poll audio unitl the front porch begins
              xcont hsync_fp,blank_color
audio_pollloop
              call audio_poll_func
        _ret_ jnxmt #audio_pollloop

line_border ' border line
              setq nco_sync
              xcont borderline,border_color
              mov scanfunc,#dummy_func
              call scantask
              jmp #fp_audio_pollloop
line_blank ' blanking line
              setq nco_sync
              xcont blankline,blank_color
              mov scanfunc,#dummy_func
              call scantask
              jmp #fp_audio_pollloop


hsync_normal
              setq nco_sync
              xzero hsync_tip,hsync_color ' when this latches, FP is beginning
              tjs vsync_pin,#.no_v
              drvh vsync_pin ' should only be 4 cycles late
.no_v         xcont hsync_bp,blank_color
              jmp #vline_update
      

vsync_normal ' Vsync line including sync etc
              setq nco_sync
              xzero hsync_tip,hvsync_color ' when this latches, FP is beginning
              tjs vsync_pin,#.no_v
              drvl vsync_pin ' should only be 4 cycles late
.no_v         xcont hsync_bp,vsync_color
              xor cq_val,cq_xor ' Make sure PAL phase is alternating
              call #vline_update ' update client on time
              xcont blankline,vsync_color
        _ret_ xcont hsync_fp,vsync_color

              fit $400
DAT ' HDMI overlay code
              org video_ovl_area
hdmi_overlay

' TERC4 encoder table
' bit 0 on ch0 is HSync, so VGA sync bit is set to match
terctable     long TERC_0 * $401004 + %10
              long TERC_1 * $401004 + %11
              long TERC_2 * $401004 + %10
              long TERC_3 * $401004 + %11
              long TERC_4 * $401004 + %10
              long TERC_5 * $401004 + %11
              long TERC_6 * $401004 + %10
              long TERC_7 * $401004 + %11
              long TERC_8 * $401004 + %10
              long TERC_9 * $401004 + %11
              long TERC_A * $401004 + %10
              long TERC_B * $401004 + %11
              long TERC_C * $401004 + %10
              long TERC_D * $401004 + %11
              long TERC_E * $401004 + %10
              long TERC_F * $401004 + %11

tmds_ch1_mask      long $3FF << 12
tmds_ch2_mask      long $3FF << 22

spdif_parity_mask  long $7_FFFFFF

'' HDMI-related small functions

'island_tx_h
              'mov pa,##TMDS_GUARDDAT_H
island_tx
              ' guard character in PA, length in PB, data at PTRA
              xcont hsync_guardband,pa
              rep @.loop,pb ' PB is latched, we can clobber it
              rdlut pb,ptra++
              xcont bitbangcmd,pb
.loop
        _ret_ xcont hsync_guardband,pa

audio_island_tx_hv
              mov pa,##TMDS_GUARDDAT_HV
              mov temp1,hvsync_color
              loc ptrb,#\packet_aclk_v
              jmp #audio_island_tx
audio_island_tx_h
              mov pa,##TMDS_GUARDDAT_H
              mov temp1,hsync_color
              loc ptrb,#\packet_aclk
audio_island_tx
              cmpsub hdmi_regen_counter,hdmi_regen_period wc
        if_nc xcont packetblank,temp1
              loc ptra,#\packet_audio
              xcont hsync_guardband,pa
              rep @.loop,#32
              rdlut pb,ptra++
              xcont bitbangcmd,pb
.loop
        if_nc jmp #.no2nd
              rep @.loop2,#32
              rdlut pb,ptrb++
              xcont bitbangcmd,pb
.loop2
.no2nd
        _ret_ xcont hsync_guardband,pa


hsync_hdmi_vbi ' Hsync during V blanking
              call audio_poll_func
              xzero hsync_tip,hsync_color ' this is the data preamble
              tjs vsync_pin,#.no_v
              drvh vsync_pin ' should only be 4 cycles late
.no_v         
              call #audio_island_tx_h
              xcont hsync_bp,blank_color
              call audio_poll_func
              jmp #vline_update

hsync_hdmi_previd ' Hsync during active video
              call audio_poll_func
              xzero hsync_tip,hsync_color
              call #audio_island_tx_h
              xcont hsync_bpshort,##TMDS_PREVID
              call audio_poll_func
              xcont hsync_guardband,##TMDS_GUARDVID ' take note that this is a mere 20 cycles
              jmp #vline_update

vsync_hdmi
              call audio_poll_func
              xzero hsync_tip,hvsync_color
              tjs vsync_pin,#.no_v
              drvl vsync_pin ' should only be 4 cycles late
.no_v         
              call #audio_island_tx_hv
              cmp lines_left,sync_lines wz
        if_nz jmp #.no_infopkt
              ' send extra data on first line of Vsync (arbitrary convenient time)
              xcont hsync_bp,##TMDS_PREDAT_V ' Preamble in backporch
              call audio_poll_func
              call #vline_update ' update client on time
              mov pb,#INFO_PACKETS*32
              loc ptra,#\packet_aviinfo
              callpa ##TMDS_GUARDDAT_V,#island_tx
              xcont blankline_packets,vsync_color ' Shortened
.vsyn_task    mov scanfunc,#dummy_func
              call scantask
              call audio_poll_func
              xcont hsync_fp,vsync_color
              jmp #audio_pollloop
.no_infopkt
              xcont hsync_bp,vsync_color
              call #vline_update ' update client on time
              xcont blankline,vsync_color
              jmp #.vsyn_task

'' Packet-related functions

build_audio 
              'debug("Welcome to build_audio la-la-land")
              call scanfunc
              call audio_poll_func
              sub scantimecomp,#2
              call scanfunc
              mov packet_header,#$02
              loc ptrb,#\packet_audio ' Where we will put thy hallowed packet

              mov temp3,#0
.sploop

              tjz resample_phase_int,#.dosp
.feed
              tjz audio_inbuf_level,#.spdone
              sub scantimecomp,#2 ' feed loop
              call scanfunc

              mov audio_hist+0,audio_hist+1
              mov audio_hist+1,audio_hist+2
              mov audio_hist+2,audio_hist+3
              mov audio_hist+3,audio_inbuffer+0
              mov audio_inbuffer+0,audio_inbuffer+1
              mov audio_inbuffer+1,audio_inbuffer+2
              mov audio_inbuffer+2,audio_inbuffer+3
              sub audio_inbuf_level,#1
              call scanfunc
              djnz resample_phase_int,#.feed ' always fall through if ratio < 2

.dosp         ' Create an output sample using cubic resampling
              sub scantimecomp,#6+6 ' dosp (cubic)
              call scanfunc

              getword u1,resample_phase_frac,#1
              mov u2,u1
              mul u2,u1
              shr u2,#16
              mov u3,u2
              mul u3,u1
              shr u3,#16

              call scanfunc

              mov temp1,u3
              sub temp1,u2
              sub temp1,u2
              add temp1,u1
              sar temp1,#2
              getword temp4,audio_hist+0,#1
              muls temp4,temp1
              neg spleft,temp4
              muls temp1,audio_hist+0 ' muls ignores upper half
              neg spright,temp1

              call scanfunc

              mov temp1,u3
              mul temp1,#3
              mov temp2,u2
              mul temp2,#5
              subr temp1,temp2
              mov temp2,temp1 ' +u2*5 -u3*3 (for later)
              sub temp1,##$20000
              sar temp1,#2
              getword temp4,audio_hist+1,#1
              muls temp4,temp1
              sub spleft,temp4

              call scanfunc

              muls temp1,audio_hist+1 ' muls ignores upper half
              sub spright,temp1

              neg temp1,temp2 ' -u2*5 +u3*3
              add temp1,u2
              sub temp1,u1
              sar temp1,#2
              getword temp4,audio_hist+2,#1
              muls temp4,temp1
              sub spleft,temp4
              muls temp1,audio_hist+2 ' muls ignores upper half
              sub spright,temp1

              call scanfunc

              neg temp1,u3
              add temp1,u2
              sar temp1,#2
              getword temp4,audio_hist+3,#1
              muls temp4,temp1
              sub spleft,temp4
              muls temp1,audio_hist+3 ' muls ignores upper half
              sub spright,temp1

              call scanfunc

              fges spleft,min31
              fles spleft,max31
              fges spright,min31
              fles spright,max31

              call scanfunc

              shr spleft,#7
              shr spright,#7
              zerox spleft,#23
              zerox spright,#23

              decmod resample_antidrift_phase,resample_antidrift_period wc
        if_c  mov resample_phase_frac,#0
        if_nc add resample_phase_frac,resample_ratio_frac wc
              addx resample_phase_int,resample_ratio_int

              call scanfunc

              ' Set sample as valid in header
              alts temp3,#8
              bith packet_header,#0-0
              ' Advance channel status
              incmod spdif_phase,#191 wc
        if_c  alts temp3,#20
        if_c  bith packet_header,#0-0

              call scanfunc

              ' Add S/PDIF status bit
              cmp spdif_phase,#64 wc
        if_c  altb spdif_phase,#spdif_status
        if_c  testb 0-0,spdif_phase wc
              bitc spleft,#26
              bitc spright,#26

              call scanfunc
              ' set parity bits
              test spleft,spdif_parity_mask wc
              bitc spleft,#27
              test spright,spdif_parity_mask wc
              bitc spright,#27
              ' store into subpacket
              mov temp2,temp3
              shl temp2,#1

              altd temp2,#packet_data0+0
              mov 0-0,spleft
              altd temp2,#packet_data0+0
              setbyte 0-0,spright,#3

              call scanfunc

              getnib temp1,spright,#6
              rolnib temp1,spleft,#6
              rolbyte temp1,spright,#2
              altr temp2,#packet_data0+1
              rolbyte temp1,spright,#1

              add hdmi_regen_counter,#1

              incmod temp3,#2-1 wc ' This limits it to encoding 2 samples per scanline, which ought to be enough
              ' Hacky check to fix sampling jitter:
              '  Packets where frac->int overflow occurs are only allowed in first packet slot
              '  This is probably bad and a better way should be found.
              mov temp1,resample_phase_frac
.jptch1 if_nc add temp1,resample_ratio_frac wc ' Check if next frac add or
.jptch2 if_nc cmp resample_antidrift_phase,#1 wc ' antidrift overflows
              call scanfunc
        if_nc jmp #.sploop
.spdone
              ' fall straight into packet encoder


terc_encode   ' PACKET ENCODER
              call scanfunc
              sub scantimecomp,#3
              call audio_poll_func
              call scanfunc

              ' Compute header checksum
              mov temp2,#0
              mov temp1,packet_header
              rev temp1
              setq temp1
              rep #1,#6
              crcnib temp2,#PACKET_CRC

              call scanfunc

              setbyte packet_header,temp2,#3
              'debug("Header CRC: ",uhex(temp2))
              'debug(uhex_long(packet_header))

              ' Compute subpacket checksums
              ' TODO can we do this in reverse?
              mov temp3,#0
.spackcrclp
              sub scantimecomp,#3

              mov temp2,#0
              alts temp3,#packet_data0
              mov temp1,0-0
              rev temp1

              call scanfunc

              setq temp1
              rep #1,#8
              crcnib temp2,#PACKET_CRC

              call scanfunc

              alts temp3,#packet_data0+1
              mov temp1,0-0
              rev temp1
              setq temp1
              rep #1,#6
              crcnib temp2,#PACKET_CRC

              call scanfunc

              altd temp3,#packet_data0+1
              setbyte 0-0,temp2,#3
              'debug("Subpacket CRC: ",uhex(temp2))
              add temp3,#2
              cmp temp3,#8 wc
      if_b    jmp #.spackcrclp

              '' Encode to TERC4
              mov serbyte,#0
              'setd packetptr,#packet_buffer
              ' Assume PTRB is an appropriate LUT pointer to deposit 32 longs of encoded TERC4
.serloop
              sub scantimecomp,#3 + (3*4)
              call scanfunc

              ' serialize ch0
              cmp serbyte,#0 wz
        if_z  rolbyte serch0,packet_extra,#2 ' FE for first packet in island, FF otherwise
        if_nz rolbyte serch0,#$FF,#0
              altgb serbyte,#packet_header
              rolbyte serch0
              'rolbyte serch0,packet_vsync,#0 ' VSYNC on(?)
              'rolbyte serch0,#$FF,#0 ' HSYNC on
              rolword serch0,packet_extra,#0 ' Set sync status

              altgw serbyte,#packet_data3
              rolword temp1

              call scanfunc

              altgw serbyte,#packet_data2
              rolword temp1
              splitw temp1
              rolword serch1,temp1,#0
              rolword serch2,temp1,#1

              altgw serbyte,#packet_data1
              rolword temp1
              altgw serbyte,#packet_data0
              rolword temp1
              splitw temp1

              call scanfunc

              rolword serch1,temp1,#0
              rolword serch2,temp1,#1

              mergeb serch0
              mergeb serch1
              mergeb serch2
              'debug("TERC bytes ",uhex_long(serch0,serch1,serch2))

              mov temp4,#4
.byteenc
              getnib temp1,serch0,#0
              alts temp1,#terctable
              mov temp2,0-0 ' This also copies HSync bit for VGA
              getnib temp1,serch0,#1

              call scanfunc

              alts temp1,#terctable
              mov temp3,0-0 ' This also copies HSync bit for VGA

              getnib temp1,serch1,#0
              setq tmds_ch1_mask
              alts temp1,#terctable
              muxq temp2,0-0
              getnib temp1,serch1,#1
              alts temp1,#terctable
              muxq temp3,0-0

              call scanfunc

              getnib temp1,serch2,#0
              setq tmds_ch2_mask
              alts temp1,#terctable
              muxq temp2,0-0
              getnib temp1,serch2,#1
              alts temp1,#terctable
              muxq temp3,0-0

              wrlut temp2,ptrb++
              wrlut temp3,ptrb++
              'debug("packet enc ",uhex_(temp2))
              'debug("packet enc ",uhex_(temp3))

              call scanfunc
              shr serch0,#8
              shr serch1,#8
              shr serch2,#8
              djnz temp4,#.byteenc

              incmod serbyte,#3   wc
    if_nc     jmp #.serloop  


              sub scantimecomp,#1
              jmp scanfunc ' tail call

' TERC packet pre-encoding buffers
packet_header res 1
packet_data0  res 2
packet_data1  res 2
packet_data2  res 2
packet_data3  res 2

              fit 496


DAT ' Hub init code
              orgh

video_init
              ' load common code
              loc pa,#@video_cog_code
              setq #video_ovl_area-1
              rdlong 0,pa

              loc pa,#@video_lut_code
              setq2 #511-(video_lut_code-512)
              rdlong video_lut_code-512,pa

              setq #(app_params_end - app_params - 1)
              rdlong app_params,ptra

              debug(uhex_long(vpins,extravpins))
              debug(uhex_long(scanbuffer_base,scanbuffer_stride,scanbuffer_wrap))

              setq #(timing_vars_end - timing_vars - 1)
              rdlong timing_vars,timing_ptr

              debug(udec(fp_lines,sync_lines,bp_lines))

              setq #(color_vars_end - color_vars - 1)
              rdlong color_vars,color_ptr

              setxfrq nco_sync

              mov subline_incmod,line_multiplier
              cmpsub subline_incmod,#1

              mov bob_lines,line_multiplier
              shr bob_lines,#1

              mov borderline,blankline ' dup

              ' setup basic CSC parameters
              setcy cy_val
              setci ci_val
              setcq cq_val
              setdacs dac_blanking ' default CSC color when streamer masked

              mov virtual_frame,#0
              neg virtual_line,#64 ' Initialize to sufficiently nonsensical value

              jmp initfunc_ptr




init_rgbhv ' Separate H/V sync RGB (=VGA)
              call #util_vgacommon

              setcmod #%0_01_1_000_1 ' Normal mode + invert sync
              mov pa,##X_DACS_X_X_X_0|X_IMM_1X32_4DAC8
              ' TODO: figure out how interlacing works for RGBHV
              call #util_setsyncs
              call #util_setactive
              
              jmp #video_entry

init_rgbs ' Combined sync RGB
              setcmod #%0_01_1_000_1 ' Normal mode + invert sync
              mov pa,##X_DACS_X_X_X_0|X_IMM_1X32_4DAC8
              call #util_ntscsync ' Use NTSC-style sync for native 1x timing
              call #util_setsyncs
              call #util_setactive

              getbyte pa,vpins,#0 ' get analog pin base
              call #util_hsyncpin
              call #util_rgbpins
              
              jmp #video_entry


init_soggy ' Sync-on-Green or YPbPr
              setcmod #%0_01_1_010_0 ' Normal mode + DAC0 to green
              mov pa,##X_DACS_X_X_X_0|X_IMM_1X32_4DAC8
              call #util_ntscsync ' Use NTSC-style sync for native 1x timing
              call #util_setsyncs
              call #util_setactive

              getbyte pa,vpins,#0 ' get analog pin base
              call #util_rgbpins
              
              jmp #video_entry

init_composite
            setcmod #%0_11_1_000_0 ' Composite mode

            getbyte pa,vpins,#0 ' get analog pin base
            ' just a single pin
            call #util_sdtvpins

            call #util_sdtvcommon
            jmp #video_entry

init_svideo
            setcmod #%0_10_1_000_0 ' SVideo mode

            getbyte pa,vpins,#0 ' get analog pin base
            add pa,#0 addpins 1' two pins
            call #util_sdtvpins

            call #util_sdtvcommon
            jmp #video_entry

init_compsvid ' SVideo + Composite dual
            setcmod #%0_10_1_000_0 ' SVideo mode

            getbyte pa,vpins,#0 ' get analog pin base
            add pa,#0 addpins 2 ' three pins
            call #util_sdtvpins

            call #util_sdtvcommon
            jmp #video_entry


init_dvivga ' DVI+VGA dual (DVI-I)
            call #util_vgacommon ' then fall through
init_dvi    ' Plain DVI-D
            call #util_tmdscommon
            jmp #video_entry

init_hdmivga ' HDMI + VGA
            call #util_vgacommon  ' then fall through
init_hdmi    ' HDMI (=DVI + audio)

            ' load the overlay
            loc pa,#@hdmi_overlay
            setq #495-video_ovl_area
            rdlong video_ovl_area,pa

            ' Set sync functions
            mov hsync_func,#hsync_hdmi_previd
            mov vbi_hsync_func,#hsync_hdmi_vbi
            mov vsync_func,#vsync_hdmi

            ' Setup the audio processing
            mov audio_poll_func,#audio_poll_repo
            setq #(audio_clear_end-audio_clear_start)-1
            rdlong audio_clear_start,##$80000 ' read from unmapped memory to get zeroes


            ' Audio packets will be sent at the end of HSync
            ' and the remaining cycles will be the preamble
            mov hsync_color,##TMDS_PREDAT_H ' Override the HSync color
            mov hvsync_color,##TMDS_PREDAT_HV ' Override the HVSync color
            sub hsync_tip,#64+4 ' 32 data, 2*2 guard

            ' Set bpshort to accomodate guard band
            mov hsync_bpshort,hsync_bp
            sub hsync_bpshort,hsync_guardband
            debug(udec(hsync_bp,hsync_bpshort,hsync_guardband))

            mov blankline_packets,blankline
            sub blankline_packets,#INFO_PACKETS*32+4 ' 32 per packet, 4 for the guard bands

            ' Make sure all packets are consistently sloppy
            setq #9-1
            rdlong packet_header,##$80000 ' read from unmapped memory to get zeroes


            ' Setup AVI InfoFrame
            mov packet_header,##$0D_02_82 ' AVI InfoFrame version 2
            ' only the first 4 bytes are really of interest
            'setbyte packet_data0,#%0_00_0_00_01,#1 ' Byte 1: RGB, no active format, no bar data, overscan on
            'setbyte packet_data0,#%10_00_1000,#2 ' Byte 2: Rec. 709 colors, no aspect info
            'setbyte packet_data0,#%1_000_10_00,#3 ' Byte 3: IT content, Full RGB range, no non-uniform scaling
            mov packet_data0,##%1_000_10_00___10_00_1000___0_00_0_00_01 << 8

            call #util_infoframe_chksum

            mov packet_extra,##$FE_FF_00 ' Will send this during VSync as first packet
            loc ptrb,#\packet_aviinfo
            call #terc_encode ' There shouldn't be a scanfunc set now
            
            ' Setup resampling rate
            ' If it matches any standard rate we know then we disable resampling
            rdlong temp2,#@clkfreq ' grab system clock
            ' Check 32kHz
            loc pa,#\32_000
            call #util_check_sr_fuzzy
      if_c  setnib spdif_status+0,#%0011,#6
      if_c  jmp #.nctssetup
            loc pa,#\44_100
            call #util_check_sr_fuzzy
      if_c  setnib spdif_status+0,#%0000,#6
      if_c  jmp #.nctssetup
            loc pa,#\48_000
            call #util_check_sr_fuzzy ' gets 48k ideal period into temp1
            setnib spdif_status+0,#%0010,#6 ' Always set 48k
      if_c  jmp #.nctssetup

            ' Ok, resample whatever it is to 48k
            qdiv temp1,audio_period ' temp1 still has 48kHz period
            getqx resample_ratio_int
            getqy pa
            qfrac pa,audio_period
            getqx resample_ratio_frac
            mov resample_antidrift_period,audio_period wc ' Always set NC
            sub resample_antidrift_period,#1
            mov resample_antidrift_phase,resample_antidrift_period ' Init to max value because DECMOD
.nctssetup
      if_c  mov temp1,audio_period ' If not resampling, use input rate

            ' Disable de-jitter code if not resampling or fractional ratio >= 0.5
            tjz resample_antidrift_period,#.yes_djkill
            tjns resample_ratio_frac,#.no_djkill
.yes_djkill mov build_audio:jptch1,#0 ' NOP
            mov build_audio:jptch2,#0 ' NOP
            debug("Disabled de-jitter!")
.no_djkill

            ' Setup audio clock packet
            mov packet_header,#$00_00_00_01 ' Clock packet
            debug(udec(temp1,temp2,audio_period))
            mov temp3,##10000
            mul temp3,temp1
            shr temp3,#1 wc
            add temp2,temp3
            rcl temp3,#1
            qdiv temp2,temp3 ' clkfreq/period (rounded)
            getqx temp2 ' gives multiplier that shifts 1280/period into optimal range

            mul temp1,temp2 ' CTS value
            mov hdmi_regen_period,temp2
            mul hdmi_regen_period,#10
            mul temp2,##1280 ' N value
            debug("N: ",udec_(temp2)," CTS: ",udec_(temp1))
            debug(udec(hdmi_regen_period))

            ' Pack them into the clown car, honk honk
            setr temp3,#packet_data0
            rep @.nctspck,#4
            alti temp3,#%111_000_000
            movbyts temp1,#%%0123
            alti temp3,#%111_000_000
            movbyts temp2,#%%3012
.nctspck
            mov packet_extra,##$FF_00_FF ' No start bit, hsync
            loc ptrb,#\packet_aclk
            call #terc_encode
            setbyte packet_extra,#$FF,#1 ' VSync version
            loc ptrb,#\packet_aclk_v
            call #terc_encode



            mov packet_extra,##$FE_00_FF ' Prepare for real-time audio (during HSync!)
            
            ' encode a null packet (DEBUG DEBUG?)
            setq #9-1
            rdlong packet_header,##$80000 ' read from unmapped memory to get zeroes
            loc ptrb,#\packet_audio ' Where to store it
            call #terc_encode

            call #util_tmdscommon

            mov scantask,##build_audio

            jmp #video_entry


util_check_sr_fuzzy
'' Compute period of sample rate in PA into temp1 (using clkfreq in temp2)
'' Set C if audio_period is close enough
            mov pb,pa
            shr pb,#1
            add pb,temp2
            qdiv pb,pa
            getqx temp1
            mov pb,temp1
            sub pb,audio_period
            abs pb
      _ret_ cmp pb,#1 wc

util_infoframe_chksum
            setbyte packet_data0+0,#0,#0
            setbyte packet_header+0,#0,#3
            setbyte packet_data0+1,#0,#3
            setbyte packet_data1+1,#0,#3
            setbyte packet_data2+1,#0,#3
            setbyte packet_data3+1,#0,#3

            getbyte temp1,packet_header,#2 ' grab length
            add temp1,#4-1
            mov temp2,#0
.chklp
            altgb temp1,#packet_header
            getbyte temp3
            sub temp2,temp3
            djnf temp1,#.chklp
            debug("infoframe checksum ",uhex_(temp2))
      _ret_ setbyte packet_data0,temp2,#0

util_tmdscommon ' common TMDS TX setup
            mov pa,#%10_01_1_000_1
            testb vpins,#encod TMDS_REVERSE_FLAG wc
            bitc pa,#7
            setcmod pa
            
            getbyte pa,vpins,#1 ' get digital pin base
            and pa,#%111000
            add pa,#0 addpins 7
            wrpin ##TMDS_DRIVE_MODE,pa
            drvl pa

            getbyte temp2,vpins,#1 ' get digital pin base
            and temp2,#%111000

            setd audio_poll_repo:pptchd,temp2
            sets audio_poll_repo:pptchs,temp2
            
            shl temp2,#17
            bith temp2,#encod X_PINS_ON

            mov pa,##X_DACS_X_X_X_0|X_IMM_1X32_4DAC8
            or pa,temp2
            call #util_setsyncs
            jmp #util_setactive_extra ' tail call


util_vgacommon ' common RGBHV DAC setup
            call #util_vsyncpin
            getbyte pa,vpins,#0 ' get analog pin base
            call #util_hsyncpin
            jmp #util_rgbpins ' tail call



util_rgbpins
            add pa,#1 addpins 2 ' 3 pins, 1 up
            cogid pb
            shl pb,#8
            or pb,##P_DAC_75R_2V|P_CHANNEL
            wrpin pb,pa
      _ret_ drvl pa

util_sdtvpins
util_hsyncpin
            cogid pb
            shl pb,#8
            or pb,##P_DAC_124R_3V|P_CHANNEL ' Yes, 124R is correct, 75R can't hit bright yellow
            wrpin pb,pa
      _ret_ drvl pa

util_vsyncpin
            getbyte vsync_pin,extravpins,#0
            wrpin #0,vsync_pin ' Should we give this a mode?
      _ret_ drvl vsync_pin

util_ntscsync
              ' Set NTSC/PAL-style sync if possible
              mov vsync_half,blankline
              add vsync_half,hsync_bp
              add vsync_half,hsync_tip
              add vsync_half,hsync_fp
              shr vsync_half,#1
              sub vsync_half,hsync_tip

              cmp line_multiplier,#1 wz
        if_z  cmp sync_lines,#3 wz
        if_z  sub fp_lines,#3
        if_z  add sync_lines,#6
        if_z  sub bp_lines,#3
        if_z  mov vsync_func,#vsync_ntsc
              ret wcz

util_sdtvcommon
              setcfrq burst_freq
              mov hsync_bpshort,hsync_bp
              sub hsync_bpshort,hsync_breeze
              sub hsync_bpshort,hsync_burst
              mov hsync_func,#hsync_ntsc
              mov vbi_hsync_func,#hsync_ntsc

              call #util_ntscsync

              call #util_setactive
              
              mov pa,##X_DACS_3_2_1_0|X_IMM_1X32_4DAC8
              ' fall through
util_setsyncs
              or hsync_breeze,pa
              or hsync_burst,pa ' is also hsync_guardband
              or hsync_bpshort,pa
              or vsync_half,pa
              or hsync_fp,pa
              or hsync_tip,pa
              or hsync_bp,pa
              or bitbangcmd,pa
              or packetblank,pa
              or blankline_packets,pa
        _ret_ or blankline,pa

util_setactive ' set default active line handling
              mov temp2,#0
util_setactive_extra
              mov pa,##X_DACS_3_2_1_0|X_IMM_1X32_4DAC8
              or pa,temp2
              or borderline,pa
              cmp extra_pillar,#0 wz
        if_nz or extra_pillar,pa

              tjz nco_main,#.softscan
              cmp nco_alt,#0 wz
        if_z  mov altline_func,##line_native_altpillar ' Use pillarboxing if no alt NCO set
              or altres_pillar,pa

              mov pa,##X_DACS_3_2_1_0|X_RFLONG_RGB24
              or pa,temp2
              or linecmd,pa
        _ret_ or linecmd_alt,pa
.softscan
              ' Use emulated pixel-doubling
              mul altres_pillar,pixel_multiplier
              or altres_pillar,pa
              or pixel_multiplier,pa
              mov line_func,#line_scancomp
        _ret_ mov altline_func,#line_scancomp_alt
'              mov line_func,#line_soft2x
'        _ret_ mov altline_func,#line_soft2x_alt

init_ili9342 ' 6-bit digital LCD interface
            ' TODO
            jmp #$


CON

' clock source used below
    #0, CLKSRC_XTAL, CLKSRC_XIN

' setup one of these based on your P2 HW input clock,
' this will only be used if the PLL settings get automatically computed (see code below)
    'CLKIN_HZ = _xtalfreq ' also only enable CLKSRC_XTAL below as CLKSRC
    'CLKIN_HZ = _xinfreq  ' also only enable CLKSRC_XIN below as CLKSRC
    CLKIN_HZ = 20000000 ' assume 20MHz crystal by default

    CLKSRC = CLKSRC_XTAL ' enable this for crystal clock source (default)
    'CLKSRC = CLKSRC_XIN ' enable this for direct input clock source on XI (no crystal)

' parameters used when automatically determining PLL settings
    TOLERANCE_HZ = 500000    ' pixel clock accuracy will be constrained by this when no exact ratios are found
    MAXVCO_HZ    = 350000000 ' for safety, but you could try to overclock even higher at your own risk
    MINVCO_HZ    = 100000000
    MINPLLIN_HZ  = 500000    ' setting lower can find more PLL ratios but may begin to introduce more PLL jitter

PRI computeClockMode(desiredHz) : mode | vco, finput, f, p, div, m, error, bestError
    bestError := -1
    repeat p from 0 to 30 step 2
        ' compute the ideal VCO frequency f at this value of P
        if p <> 0
            if desiredHz > MAXVCO_HZ/p ' test it like this to not overflow
                quit
            f := desiredHz * p
        else
            f := desiredHz
            if f > MAXVCO_HZ
                quit
        ' scan through D values, and find best M, retain best case
        repeat div from 1 to 64
            'compute the PLL input frequency from the crystal through the divider
            finput := CLKIN_HZ/div
            if finput < MINPLLIN_HZ ' input getting too low, and only gets lower so quit now
                quit

            ' determine M value needed for this ideal VCO frequency and input frequency
            m := f / finput

            ' check for the out of divider range case
            if m +> 1024
                quit

            ' zero is special and gets a second chance
            if m == 0
                m++

            ' compute the actual VCO frequency at this particular M, D setting
            vco := finput * m
            if vco +< MINVCO_HZ
                quit
            if vco +> MAXVCO_HZ
                next

            ' compute the error and check next higher M value if possible, it may be closer
            error := abs(f - vco)
            if m < 1024 and (vco + finput) +< MAXVCO_HZ
                if error > abs(f - (vco + finput))
                    error := abs(f - (vco + finput))
                    m++

            ' retain best allowed frequency error and divider bits found so far
            if error +< bestError and error +< TOLERANCE_HZ+1
                bestError := error
                mode := ((div-1) << 18) + ((m-1) << 8) + (((p/2 - 1) & $f) << 4)

            ' quit whenever perfect match found
            if bestError == 0
                quit

        if bestError == 0
            quit

    ' final clock mode format is this #%0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS
    if mode
        ' also set 15 or 30pF capacitor loading based on input crystal frequency
        mode |= (1<<24) ' enable PLL
        if (CLKSRC == CLKSRC_XTAL) ' enable oscillator and caps for crystal
            mode |= (CLKIN_HZ < 16000000) ? %1111 : %1011
        else
            mode |= %0111 ' don't enable oscillator

CON ' Clocky business

    MASTER_CLK = 3_579_545*15
    CLK_MULTIPLIER = 6
    VIDEO_CLKFREQ = MASTER_CLK*CLK_MULTIPLIER


CON  ' CSC constant calculation

    ONE_IRE = 255.0 / 180.0

    BLANKING_LEVEL = ONE_IRE*40.0
    PEDESTAL = 0.0'ONE_IRE*7.5 ' NTSC only, other standards (including NTSC-J) don't have pedestal

    BLANK_LEVEL = round(BLANKING_LEVEL)

    B2W_NTSC = ONE_IRE*100.0 - PEDESTAL
    YSCALE_NTSC = 127.0*(B2W_NTSC/255.0)
    IQSCALE_NTSC = YSCALE_NTSC * 1.33

    B2W_PAL = ONE_IRE*100.0
    YSCALE_PAL = 127.0*(B2W_PAL/255.0)
    UVSCALE_PAL = YSCALE_PAL * 1.33 ' Can't set correct amplitude (around 1.47) because weird overflow?

    CY_NTSC      = (round(0.299*YSCALE_NTSC)&$FF)<<24 + (round(0.587*YSCALE_NTSC)&$FF)<<16 + (round(0.114*YSCALE_NTSC)&$FF)<<8 + round(BLANKING_LEVEL+PEDESTAL)
    CI_NTSC      = (round(+0.5959*IQSCALE_NTSC)&$FF)<<24 + (round(-0.2746*IQSCALE_NTSC)&$FF)<<16 + (round(-0.3216*IQSCALE_NTSC)&$FF)<<8 + round(BLANKING_LEVEL)
    CQ_NTSC      = (round(+0.2115*IQSCALE_NTSC)&$FF)<<24 + (round(-0.5227*IQSCALE_NTSC)&$FF)<<16 + (round(+0.3112*IQSCALE_NTSC)&$FF)<<8 + 128

    CY_PAL      = (round(0.299*YSCALE_PAL)&$FF)<<24 + (round(0.587*YSCALE_PAL)&$FF)<<16 + (round(0.114*YSCALE_PAL)&$FF)<<8 + round(BLANKING_LEVEL)
    CU_PAL      = (round(-0.147*UVSCALE_PAL)&$FF)<<24 + (round(-0.289*UVSCALE_PAL)&$FF)<<16 + (round(+0.436*UVSCALE_PAL)&$FF)<<8 + round(BLANKING_LEVEL)
    CV_PAL_ODD  = (round(+0.615*UVSCALE_PAL)&$FF)<<24 + (round(-0.515*UVSCALE_PAL)&$FF)<<16 + (round(-0.100*UVSCALE_PAL)&$FF)<<8 + 128
    CV_PAL_EVEN = (round(-0.615*UVSCALE_PAL)&$FF)<<24 + (round(+0.515*UVSCALE_PAL)&$FF)<<16 + (round(+0.100*UVSCALE_PAL)&$FF)<<8 + 128


    COLOR_BURST_NTSC  = $7C9900_01
    'COLOR_BURST_PAL  = $4DFF0001
    'COLOR_BURST_NTSC = $7FAF00_01
    COLOR_BURST_PAL   = $D8A351_01
    'COLOR_BURST_NTSC = $B9FF00_01



    Y_BLANK = 0
    Y_SYNC = 256-BLANK_LEVEL

CON  ' TMDS definitions
    TMDS_CONTROL_00 = %1101010100
    TMDS_CONTROL_01 = %0010101011
    TMDS_CONTROL_10 = %0101010100
    TMDS_CONTROL_11 = %1010101011

    TMDS_BLANK       = TMDS_CONTROL_00<<22 + TMDS_CONTROL_00<<12 + TMDS_CONTROL_00<<2 + %10
    TMDS_HSYNC       = TMDS_CONTROL_00<<22 + TMDS_CONTROL_00<<12 + TMDS_CONTROL_01<<2 + %11
    TMDS_VSYNC       = TMDS_CONTROL_00<<22 + TMDS_CONTROL_00<<12 + TMDS_CONTROL_10<<2 + %10
    TMDS_HVSYNC      = TMDS_CONTROL_00<<22 + TMDS_CONTROL_00<<12 + TMDS_CONTROL_11<<2 + %11
  
    TMDS_PREVID      = TMDS_CONTROL_00<<22 + TMDS_CONTROL_01<<12 + TMDS_CONTROL_00<<2 + %10 ' Video preamble (should never have H/V sync)
    TMDS_GUARDVID    = %1011001100_0100110011_1011001100_10 ' Video Guard character
  
    TMDS_PREDAT_B    = TMDS_CONTROL_01<<22 + TMDS_CONTROL_01<<12 + TMDS_CONTROL_00<<2 + %10 ' Data preamble in blanking
    TMDS_PREDAT_H    = TMDS_CONTROL_01<<22 + TMDS_CONTROL_01<<12 + TMDS_CONTROL_01<<2 + %11 ' Data preamble in HSync
    TMDS_PREDAT_V    = TMDS_CONTROL_01<<22 + TMDS_CONTROL_01<<12 + TMDS_CONTROL_10<<2 + %10 ' Data preamble in VSync
    TMDS_PREDAT_HV   = TMDS_CONTROL_01<<22 + TMDS_CONTROL_01<<12 + TMDS_CONTROL_11<<2 + %11 ' Data preamble in HSync+VSync

    TMDS_GUARDDAT_B  = %0100110011_0100110011<<12 + TERC_C<<2 + %10 ' Data Guard character in blanking
    TMDS_GUARDDAT_H  = %0100110011_0100110011<<12 + TERC_D<<2 + %11 ' Data Guard character in HSync
    TMDS_GUARDDAT_V  = %0100110011_0100110011<<12 + TERC_E<<2 + %10 ' Data Guard character in VSync
    TMDS_GUARDDAT_HV = %0100110011_0100110011<<12 + TERC_F<<2 + %11 ' Data Guard character in HSync+VSync

    TERC_0 = %1010011100
    TERC_1 = %1001100011
    TERC_2 = %1011100100
    TERC_3 = %1011100010
    TERC_4 = %0101110001
    TERC_5 = %0100011110
    TERC_6 = %0110001110
    TERC_7 = %0100111100
    TERC_8 = %1011001100
    TERC_9 = %0100111001
    TERC_A = %0110011100
    TERC_B = %1011000110
    TERC_C = %1010001110
    TERC_D = %1001110001
    TERC_E = %0101100011
    TERC_F = %1011000011

    TMDS_DRIVE_MODE = P_REPOSITORY|P_OE|P_LOW_FAST|P_HIGH_1K5|P_SYNC_IO
    'TMDS_DRIVE_MODE = P_DAC_124R_3V|P_BITDAC|($F7)<<8

    PACKET_CRC = $83 ' Error-correcting polynomial for HDMI auxillary data
    INFO_PACKETS = 1 ' How many once-per-frame info packets
